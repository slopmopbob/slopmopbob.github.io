<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spawn Engine Editor v3</title>
    <!-- Google Fonts - Raleway throughout -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Warm Walnut Base */
            --bg-dark: #1a1512;
            --bg-panel: #201a14;
            --bg-card: #282119;
            --bg-input: #151210;
            --bg-hover: #352b22;

            /* Lavender/Sage Accents */
            --accent-primary: #a78db6;
            --accent-secondary: #c4a8d0;
            --accent-tertiary: #8a7396;
            --accent-gold: #9cb68d;
            --accent-highlight: #e8e0d4;

            /* Aliases for inline references */
            --copper: var(--accent-primary);
            --accent-copper: var(--accent-primary);
            --copper-dark: var(--accent-tertiary);

            /* Status Colors (muted fantasy tones) */
            --accent-success: #4a7c59;
            --accent-warning: #a67c52;
            --accent-danger: #8b3a3a;

            /* Text Colors */
            --text-primary: #e8e0d4;
            --text-secondary: #c4bab0;
            --text-muted: #7a6e63;

            /* Border & Decorative */
            --border-color: #4a3f36;
            --border-ornate: #5a4d42;
            --glow-copper: rgba(167, 141, 182, 0.3);

            /* Node Colors (fantasy-themed) */
            --node-attribute: #4a7c59;
            --node-variable: #c9a86c;
            --node-context: #5c6d8e;
            --node-layer: #7c5295;
            --node-item: #8b6bb8;
            --node-trait: #8b6bb8;
            --node-modifier: #a65d7a;
            --node-compound: #8b3a3a;
            --node-derived: #4a7c8b;
            --node-ticksystem: #3a6b8b;
            --node-action: #c9a86c;

            /* Relationship colors */
            --node-weight-influence: #a87bc9;
            --node-rate-modifier: #c9a86c;
            --node-value-modifier: #6db385;
            --node-eligibility-gate: #e05252;
            --node-requires: #5c9fd4;
            --node-replaces: #d45c8c;

            /* Pattern for background */
            --pattern-opacity: 0.03;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Raleway', 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            /* Subtle diamond pattern background */
            background-image:
                linear-gradient(45deg, transparent 45%, rgba(167, 141, 182, var(--pattern-opacity)) 45%, rgba(167, 141, 182, var(--pattern-opacity)) 55%, transparent 55%),
                linear-gradient(-45deg, transparent 45%, rgba(167, 141, 182, var(--pattern-opacity)) 45%, rgba(167, 141, 182, var(--pattern-opacity)) 55%, transparent 55%);
            background-size: 30px 30px;
            background-color: var(--bg-dark);
        }

        /* Heading emphasis - same font, bolder weight */
        h1, h2, h3, .header-title, .modal-title, .detail-title {
            font-family: 'Raleway', 'Segoe UI', system-ui, sans-serif;
            font-weight: 600;
            letter-spacing: 0.03em;
        }

        /* ========================================
           MAIN LAYOUT
           ======================================== */
        .app-container {
            display: grid;
            grid-template-rows: auto 1fr;
            height: 100vh;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(180deg, var(--bg-panel) 0%, var(--bg-dark) 100%);
            border-bottom: 1px solid var(--border-ornate);
            position: relative;
        }

        /* Ornate border decoration */
        .header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), var(--accent-gold), var(--accent-primary), transparent);
        }

        .header-title {
            font-size: 1.2rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            color: var(--accent-highlight);
            text-shadow: 0 0 20px var(--glow-copper);
        }

        .header-title .version {
            font-family: 'Raleway', sans-serif;
            font-size: 0.65rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border: 1px solid var(--accent-secondary);
        }

        .header-actions {
            display: flex;
            gap: 0.5rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 240px 1fr 320px;
            height: 100%;
            overflow: hidden;
        }

        .main-layout.detail-collapsed {
            grid-template-columns: 240px 1fr;
        }

        .main-layout.detail-collapsed .detail-panel {
            display: none;
        }

        /* ========================================
           SIDEBAR (Left Panel)
           ======================================== */
        .sidebar {
            background: linear-gradient(180deg, var(--bg-panel) 0%, var(--bg-dark) 100%);
            border-right: 1px solid var(--border-ornate);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .sidebar-section {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-section-title {
            font-family: 'Raleway', sans-serif;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-secondary);
            margin-bottom: 0.5rem;
        }

        .config-meta {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .config-meta input {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 0.5rem 0.75rem;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: 'Raleway', sans-serif;
            transition: all 0.2s ease;
        }

        .config-meta input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 10px var(--glow-copper);
        }

        .tree-container {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        /* System Overview Panel */
        .sidebar-overview {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .overview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .overview-header:hover {
            background: var(--bg-hover);
            color: var(--text-secondary);
        }

        .overview-toggle {
            font-size: 0.6rem;
        }

        .overview-content {
            padding: 0.5rem;
        }

        .overview-content.collapsed {
            display: none;
        }

        .overview-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .overview-stat {
            text-align: center;
            padding: 0.5rem;
            background: var(--bg-card);
            border-radius: 4px;
        }

        .overview-stat-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-light);
        }

        .overview-stat-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .overview-health {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .health-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 3px;
        }

        .health-item.warning {
            background: rgba(201, 168, 108, 0.15);
            color: #c9a86c;
        }

        .health-item.error {
            background: rgba(165, 67, 67, 0.15);
            color: #c75050;
        }

        .health-item.success {
            background: rgba(109, 179, 133, 0.15);
            color: #6db385;
            cursor: default;
        }

        .health-item.clickable:hover {
            filter: brightness(1.2);
            transform: translateX(2px);
        }

        .health-item.clickable:active {
            transform: translateX(1px);
        }

        .health-item .health-action {
            margin-left: auto;
            font-size: 0.6rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .health-item.clickable:hover .health-action {
            opacity: 0.7;
        }

        .health-icon {
            font-size: 0.8rem;
        }

        .overview-density {
            margin-top: 0.5rem;
        }

        .density-bar {
            display: flex;
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            background: var(--bg-input);
        }

        .density-segment {
            transition: width 0.3s ease;
        }

        .density-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.35rem;
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .density-legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .density-legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .tree-section {
            margin-bottom: 0.5rem;
        }

        .tree-section-header {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.5rem 0.6rem;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.8rem;
            font-weight: 500;
            font-family: 'Raleway', sans-serif;
            letter-spacing: 0.03em;
            transition: all 0.2s ease;
        }

        .tree-section-header:hover {
            background: var(--bg-hover);
            color: var(--accent-highlight);
        }

        .tree-section-header .arrow {
            font-size: 0.6rem;
            transition: transform 0.2s;
        }

        .tree-section-header.collapsed .arrow {
            transform: rotate(-90deg);
        }

        .tree-section-header .count {
            margin-left: auto;
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-input);
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
        }

        .tree-items {
            padding-left: 1rem;
            border-left: 1px solid var(--border-color);
            margin-left: 0.6rem;
        }

        .tree-items.collapsed {
            display: none;
        }

        .tree-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.5rem;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.8rem;
            transition: all 0.15s ease;
        }

        .tree-item:hover {
            background: var(--bg-hover);
            color: var(--accent-highlight);
        }

        .tree-item.selected {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border: 1px solid var(--accent-secondary);
        }

        .tree-item .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .tree-item .dot.attribute { background: var(--node-attribute); }
        .tree-item .dot.variable { background: var(--node-variable); }
        .tree-item .dot.context { background: var(--node-context); }
        .tree-item .dot.layer { background: var(--node-layer); }
        .tree-item .dot.item { background: var(--node-item); }
        .tree-item .dot.trait { background: var(--node-trait); }
        .tree-item .dot.modifier { background: var(--node-modifier); }
        .tree-item .dot.compound { background: var(--node-compound); }
        .tree-item .dot.derived { background: var(--node-derived); }
        .tree-item .dot.action { background: var(--node-action); }

        /* Hierarchical Layer Tree Styles */
        .layer-tree {
            padding: 0.5rem 0;
        }

        .tree-section-divider {
            display: flex;
            align-items: center;
            margin: 0.75rem 0.5rem 0.5rem 0.5rem;
            padding-top: 0.5rem;
        }

        .tree-section-divider:first-child {
            margin-top: 0;
            padding-top: 0;
        }

        .divider-label {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            background: var(--bg-panel);
            padding: 0 0.5rem;
            white-space: nowrap;
        }

        .tree-section-divider::before,
        .tree-section-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-color);
        }

        .tree-section-divider::before {
            margin-right: 0.5rem;
        }

        .tree-section-divider::after {
            margin-left: 0.5rem;
        }

        .tree-sort-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin: 0.5rem;
            padding: 0.4rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .tree-sort-btn {
            padding: 0.25rem 0.5rem;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 3px;
            font-size: 0.65rem;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .tree-sort-btn:hover {
            background: var(--bg-hover);
            color: var(--text-color);
        }

        .tree-sort-btn.active {
            background: var(--accent-highlight);
            color: var(--bg-dark);
            border-color: var(--accent-highlight);
        }

        .tree-folder {
            margin-bottom: 0.15rem;
        }

        .tree-folder-header {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.4rem 0.5rem;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.8rem;
            transition: all 0.15s ease;
            background: var(--bg-card);
        }

        .tree-folder-header:hover {
            background: var(--bg-hover);
        }

        .tree-folder-header.selected {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border: 1px solid var(--accent-secondary);
        }

        .folder-toggle {
            font-size: 0.6rem;
            color: var(--text-muted);
            width: 10px;
            text-align: center;
            flex-shrink: 0;
        }

        .folder-icon {
            width: 8px;
            height: 8px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .folder-name {
            flex: 1;
            color: var(--text-light);
            font-weight: 500;
        }

        .folder-subtitle {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-style: italic;
            margin-right: 0.25rem;
        }

        .folder-count {
            font-size: 0.65rem;
            color: var(--text-muted);
            background: var(--bg-input);
            padding: 0.1rem 0.35rem;
            border-radius: 6px;
            flex-shrink: 0;
        }

        .folder-add-btn {
            font-size: 0.75rem;
            color: var(--text-muted);
            background: transparent;
            border: 1px solid transparent;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.15s ease;
            flex-shrink: 0;
            margin-left: 0.25rem;
        }

        .tree-folder-header:hover .folder-add-btn {
            opacity: 0.6;
        }

        .folder-add-btn:hover {
            opacity: 1 !important;
            color: var(--accent-highlight);
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }

        .tree-view-section-title:hover .folder-add-btn {
            opacity: 0.6;
        }

        .tree-item-name {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tree-item-rel-count {
            font-size: 0.65rem;
            margin-left: auto;
            flex-shrink: 0;
            opacity: 0.7;
        }

        .tree-item:hover .tree-item-rel-count {
            opacity: 1;
        }

        .tree-item-delete {
            font-size: 0.7rem;
            color: var(--text-muted);
            background: transparent;
            border: none;
            padding: 0.1rem 0.25rem;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.15s ease;
            flex-shrink: 0;
            margin-left: 0.25rem;
            line-height: 1;
        }

        .tree-item:hover .tree-item-delete {
            opacity: 0.5;
        }

        .tree-item-delete:hover {
            opacity: 1 !important;
            color: var(--error-color);
            background: rgba(180, 60, 60, 0.2);
        }

        .tree-item-order {
            font-size: 0.6rem;
            color: var(--accent-tertiary);
            background: rgba(140, 120, 90, 0.2);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            flex-shrink: 0;
            font-weight: 600;
        }

        .tree-folder-contents {
            padding-left: 0.75rem;
            margin-left: 0.35rem;
            border-left: 1px solid var(--border-color);
        }

        .tree-folder-layer .tree-folder-header {
            background: linear-gradient(90deg, var(--bg-card) 0%, rgba(108, 92, 152, 0.1) 100%);
        }

        .tree-folder-layer .tree-folder-header:hover {
            background: linear-gradient(90deg, var(--bg-hover) 0%, rgba(108, 92, 152, 0.2) 100%);
        }

        .tree-folder-orphan .tree-folder-header {
            background: var(--bg-input);
            border: 1px dashed var(--border-color);
        }

        /* Drag-to-reorder styles */
        .tree-item.draggable {
            cursor: grab;
        }

        .tree-item.draggable:active {
            cursor: grabbing;
        }

        .tree-item.dragging {
            opacity: 0.5;
            background: var(--bg-hover);
        }

        .tree-item.drag-over {
            border-top: 2px solid var(--accent-highlight);
            margin-top: -2px;
        }

        .tree-item.drag-over-below {
            border-bottom: 2px solid var(--accent-highlight);
            margin-bottom: -2px;
        }

        .tree-folder-header.draggable {
            cursor: grab;
        }

        .tree-folder-header.dragging {
            opacity: 0.5;
        }

        .tree-folder-header.drag-over {
            border-top: 2px solid var(--accent-highlight);
            margin-top: -2px;
        }

        .add-node-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            margin: 0.75rem;
            padding: 0.6rem;
            background: var(--bg-card);
            border: 1px dashed var(--border-ornate);
            border-radius: 3px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-family: 'Raleway', sans-serif;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-node-btn:hover {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border-color: var(--accent-secondary);
            border-style: solid;
            color: var(--text-primary);
            box-shadow: 0 0 15px var(--glow-copper);
        }

        /* ========================================
           MAIN VIEW (Center Panel)
           ======================================== */
        .main-view {
            display: flex;
            flex-direction: column;
            background: var(--bg-dark);
            overflow: hidden;
            min-height: 0;
        }

        .view-tabs {
            display: flex;
            gap: 0.25rem;
            padding: 0.5rem 1rem;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
        }

        .view-tab {
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-family: 'Raleway', sans-serif;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
        }

        .view-tab:hover {
            background: var(--bg-hover);
            color: var(--accent-highlight);
            border-color: var(--border-ornate);
        }

        .view-tab.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            color: var(--text-primary);
            border-color: var(--accent-secondary);
            box-shadow: 0 0 10px var(--glow-copper);
        }

        .view-content {
            flex: 1;
            overflow: auto;
            padding: 1rem;
        }

        /* Tree View Styles */
        .tree-view {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .tree-view-section {
            background: var(--bg-panel);
            border-radius: 4px;
            padding: 1rem 1.25rem;
            border: 1px solid var(--border-color);
        }

        .tree-view-section-title {
            font-family: 'Raleway', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-highlight);
            letter-spacing: 0.05em;
        }

        .tree-view-section-title .icon {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            box-shadow: 0 0 6px currentColor;
        }

        .tree-view-nodes {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .tree-view-node {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 0.5rem 0.85rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .tree-view-node:hover {
            border-color: var(--accent-primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .tree-view-node.selected {
            border-color: var(--accent-secondary);
            background: linear-gradient(135deg, rgba(167, 141, 182, 0.2), rgba(138, 115, 150, 0.15));
            box-shadow: 0 0 10px var(--glow-copper);
        }

        /* Layer folder styles */
        .tree-layer-folder {
            margin-bottom: 0.75rem;
        }

        .tree-layer-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .tree-layer-header:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        .tree-layer-header.selected {
            border-color: var(--accent-secondary);
            background: linear-gradient(135deg, rgba(167, 141, 182, 0.2), rgba(138, 115, 150, 0.15));
            box-shadow: 0 0 10px var(--glow-copper);
        }

        .tree-layer-toggle {
            font-size: 0.65rem;
            color: var(--text-muted);
            transition: transform 0.2s ease;
            width: 1rem;
            text-align: center;
        }

        .tree-layer-toggle.expanded {
            transform: rotate(90deg);
        }

        .tree-layer-name {
            flex: 1;
        }

        .tree-layer-count {
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-dark);
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
        }

        .tree-layer-roll-range {
            font-size: 0.65rem;
            color: var(--accent-secondary);
        }

        .tree-layer-children {
            margin-left: 1.25rem;
            margin-top: 0.35rem;
            padding-left: 0.75rem;
            border-left: 1px dashed var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .tree-layer-children.collapsed {
            display: none;
        }

        .tree-trait-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.6rem;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 3px;
            transition: background 0.15s ease;
        }

        .tree-trait-item:hover {
            background: var(--bg-hover);
        }

        .tree-trait-item.selected {
            background: linear-gradient(135deg, rgba(167, 141, 182, 0.15), rgba(138, 115, 150, 0.1));
            border-left: 2px solid var(--accent-secondary);
            padding-left: calc(0.6rem - 2px);
        }

        .tree-trait-item .trait-mode {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-left: auto;
        }

        .tree-trait-item .trait-mode.threshold {
            color: var(--accent-warning);
        }

        .tree-trait-item .tree-trait-name {
            flex: 1;
        }

        /* Add trait button on layer header */
        .tree-add-trait-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            font-size: 0.9rem;
            font-weight: bold;
            width: 20px;
            height: 20px;
            padding: 0;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tree-layer-header:hover .tree-add-trait-btn {
            opacity: 0.7;
        }

        .tree-add-trait-btn:hover {
            opacity: 1 !important;
            color: var(--accent-highlight);
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        /* Delete button on traits */
        .tree-delete-trait-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 0.9rem;
            padding: 0 0.25rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s ease;
            margin-left: auto;
        }

        .tree-trait-item:hover .tree-delete-trait-btn {
            opacity: 0.5;
        }

        .tree-delete-trait-btn:hover {
            opacity: 1 !important;
            color: var(--accent-danger);
        }

        /* Presets View Styles */
        .presets-view {
            padding: 1rem;
        }

        .preset-groups-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* v3.3 Session 4: .preset-group-item CSS deleted â€” replaced by .pg-tree-* */

        .preset-card {
            transition: all 0.2s ease;
        }

        .preset-card:hover {
            border-color: var(--copper) !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .preset-card.selected {
            box-shadow: 0 0 10px var(--glow-copper);
        }

        /* Graph View Styles */
        .graph-view {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;  /* Clip content but allow viewBox to handle scroll */
        }

        .graph-svg {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        .graph-svg.panning {
            cursor: grabbing;
        }

        /* During drag-to-connect, disable pointer events on overlays so mouseup reaches SVG */
        .graph-view.drag-connect-active .graph-zoom-controls,
        .graph-view.drag-connect-active .graph-bottom-right,
        .graph-view.drag-connect-active .balance-legend,
        .graph-view.drag-connect-active .balance-toggle,
        .graph-view.drag-connect-active .graph-action-btn {
            pointer-events: none;
            opacity: 0.5;
        }

        .graph-node {
            cursor: move;
        }

        .graph-node rect {
            fill: var(--bg-card);
            stroke: var(--border-ornate);
            stroke-width: 1;
            rx: 4;
            transition: all 0.2s ease;
        }

        .graph-node:hover rect {
            stroke: var(--accent-primary);
            stroke-width: 2;
            filter: drop-shadow(0 0 8px var(--glow-copper));
        }

        .graph-node.selected rect {
            stroke: var(--accent-secondary);
            stroke-width: 2;
            fill: rgba(167, 141, 182, 0.15);
            filter: drop-shadow(0 0 12px var(--glow-copper));
        }

        .graph-node text {
            fill: var(--text-primary);
            font-size: 11px;
            font-family: 'Raleway', sans-serif;
            pointer-events: none;
        }

        .graph-edge {
            stroke-width: 2;
            fill: none;
            transition: opacity 0.2s ease, stroke 0.2s ease, stroke-width 0.2s ease;
            cursor: pointer;
            opacity: 0.15; /* Dimmed by default for readability */
        }

        /* Invisible wider stroke for easier hovering */
        .graph-edge-hitarea {
            stroke: transparent;
            stroke-width: 16;
            fill: none;
            cursor: pointer;
        }

        .graph-edge.highlight {
            stroke-width: 3;
            filter: drop-shadow(0 0 6px currentColor);
            opacity: 1 !important;
        }

        .graph-edge.dimmed {
            opacity: 0.08;
        }

        /* Edge delete button - hidden by default, shown on hover */
        .edge-delete-btn {
            display: none;
            cursor: pointer;
            pointer-events: none;
        }

        .graph-edge-group:hover .edge-delete-btn {
            display: block;
            pointer-events: auto;
        }

        .edge-delete-btn circle {
            transition: fill 0.15s ease;
        }

        .edge-delete-btn:hover circle {
            fill: var(--accent-error);
        }

        .edge-delete-btn:hover text {
            fill: var(--bg-primary);
        }

        /* Edge hover - brighten the edge and show animated flow */
        .graph-edge-group:hover .graph-edge {
            stroke-width: 2.5;
            opacity: 1;
        }

        /* Animated flow effect on hover */
        .edge-flow-path {
            fill: none;
            stroke-dasharray: 4 12;
            stroke-width: 3;
            opacity: 0;
            pointer-events: none;
        }

        .graph-edge-group:hover .edge-flow-path {
            opacity: 0.6;
            animation: edgeFlow 0.6s linear infinite;
        }

        @keyframes edgeFlow {
            from { stroke-dashoffset: 16; }
            to { stroke-dashoffset: 0; }
        }

        .connection-preview-line {
            stroke: var(--accent-primary);
            stroke-width: 2.5;
            stroke-dasharray: 6 8;
            opacity: 0.7;
            pointer-events: none;
            animation: edgeFlow 0.8s linear infinite;
        }

        /* Incompatibility edges - dashed red lines */
        .graph-incompat-edge {
            stroke: #c45c5c !important;
            stroke-width: 2;
            stroke-dasharray: 6 4;
            opacity: 0.25;
            marker-end: none !important;
            transition: opacity 0.2s ease, stroke-width 0.2s ease;
        }

        .graph-incompat-edge.highlight,
        .graph-incompat-group:hover .graph-incompat-edge {
            stroke-width: 3;
            opacity: 1 !important;
            filter: drop-shadow(0 0 8px rgba(196, 92, 92, 0.9));
        }

        .graph-incompat-group.dimmed .graph-incompat-edge {
            opacity: 0.08;
        }

        /* Duration binding edges - dashed blue lines */
        .graph-duration-edge {
            stroke: var(--node-ticksystem) !important;
            stroke-width: 2;
            stroke-dasharray: 8 4;
            opacity: 0.4;
            marker-end: none !important;
            transition: opacity 0.2s ease, stroke-width 0.2s ease;
        }

        .graph-duration-edge.highlight,
        .graph-duration-group:hover .graph-duration-edge {
            stroke-width: 3;
            opacity: 1 !important;
            filter: drop-shadow(0 0 8px rgba(58, 107, 139, 0.9));
        }

        .graph-duration-group.dimmed .graph-duration-edge {
            opacity: 0.08;
        }

        /* Duration label on edges */
        .graph-duration-label {
            fill: var(--node-ticksystem);
            font-size: 10px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
        }

        /* Red highlight for nodes connected by incompatibility */
        .graph-node.incompat-highlight rect:not(.density-ring) {
            stroke: #c45c5c !important;
            stroke-width: 2;
            filter: drop-shadow(0 0 8px rgba(196, 92, 92, 0.7));
        }

        .graph-node.dimmed rect {
            opacity: 0.3;
        }

        .graph-node.dimmed text {
            opacity: 0.3;
        }

        .graph-node.highlight rect {
            stroke: var(--accent-primary);
            stroke-width: 2;
            filter: drop-shadow(0 0 6px var(--glow-copper));
        }

        /* Problem Node Highlighting */
        .graph-node.problem-highlight rect {
            stroke-width: 3;
            animation: problemPulse 1.5s ease-in-out infinite;
        }

        .graph-node.problem-warning rect {
            stroke: var(--accent-warning) !important;
            filter: drop-shadow(0 0 8px rgba(201, 168, 108, 0.6));
        }

        .graph-node.problem-error rect {
            stroke: var(--accent-danger) !important;
            filter: drop-shadow(0 0 8px rgba(165, 67, 67, 0.6));
        }

        @keyframes problemPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Problem context panel */
        .graph-context-problem {
            padding: 0.25rem;
        }

        .problem-title {
            font-weight: 600;
            font-size: 0.75rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .problem-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .problem-node {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.35rem 0.5rem;
            background: var(--bg-card);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .problem-node:hover {
            background: var(--bg-hover);
            transform: translateX(2px);
        }

        .problem-node-name {
            font-size: 0.75rem;
            color: var(--text-primary);
        }

        .problem-node-type {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        /* Balance Visualization - Connection Density */
        .graph-node .density-ring {
            fill: none;
            stroke-width: 3;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .balance-mode .graph-node .density-ring {
            opacity: 0.7;
        }

        .graph-node .density-ring.density-none {
            stroke: var(--accent-danger);
            stroke-dasharray: 4 2;
        }

        .graph-node .density-ring.density-low {
            stroke: var(--accent-warning);
        }

        .graph-node .density-ring.density-medium {
            stroke: var(--accent-success);
        }

        .graph-node .density-ring.density-high {
            stroke: var(--accent-primary);
            stroke-width: 4;
        }

        /* Drag-to-connect styles */
        .graph-node {
            cursor: grab;
        }

        .graph-node.dragging-source {
            cursor: grabbing;
        }

        .graph-node.dragging-source rect {
            stroke: var(--accent-primary) !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 8px var(--accent-primary));
        }

        .graph-node.drop-target rect {
            stroke: var(--accent-success) !important;
            stroke-width: 3px !important;
            filter: drop-shadow(0 0 8px var(--accent-success));
        }

        .drag-temp-line {
            pointer-events: none;
            animation: dash-flow 0.5s linear infinite;
        }

        @keyframes dash-flow {
            to {
                stroke-dashoffset: -10;
            }
        }

        .graph-node .density-ring.density-hub {
            stroke: var(--accent-gold);
            stroke-width: 5;
            filter: drop-shadow(0 0 4px var(--accent-gold));
        }

        /* Connection count badge */
        .graph-node .connection-badge {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .balance-mode .graph-node .connection-badge {
            opacity: 1;
        }

        .connection-badge circle {
            fill: var(--bg-panel);
            stroke: var(--border-ornate);
            stroke-width: 1;
        }

        .connection-badge text {
            fill: var(--text-secondary);
            font-size: 9px;
            font-weight: 600;
        }

        /* Incompatibility badge on nodes */
        .graph-node .incompat-badge {
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        /* Influence flow arrows */
        .influence-flow {
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .balance-mode .influence-flow {
            opacity: 0.6;
        }

        .influence-flow-line {
            fill: none;
            stroke-width: 2;
            stroke-dasharray: 6 3;
            animation: flowDash 1s linear infinite;
        }

        @keyframes flowDash {
            to {
                stroke-dashoffset: -9;
            }
        }

        /* Balance legend */
        .balance-legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 4px;
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .balance-mode .balance-legend {
            opacity: 1;
            pointer-events: auto;
        }

        .balance-legend-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.4rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .balance-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
            color: var(--text-secondary);
        }

        .balance-legend-swatch {
            width: 16px;
            height: 3px;
            border-radius: 1px;
        }

        .balance-legend-swatch.swatch-none {
            background: var(--accent-danger);
            background: repeating-linear-gradient(90deg, var(--accent-danger) 0, var(--accent-danger) 4px, transparent 4px, transparent 6px);
        }

        .balance-legend-swatch.swatch-low {
            background: var(--accent-warning);
        }

        .balance-legend-swatch.swatch-medium {
            background: var(--accent-success);
        }

        .balance-legend-swatch.swatch-high {
            background: var(--accent-primary);
        }

        .balance-legend-swatch.swatch-hub {
            background: var(--accent-gold);
            box-shadow: 0 0 4px var(--accent-gold);
        }

        /* Relationship type legend */
        .graph-bottom-right {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            align-items: flex-end;
            z-index: 100;
        }

        .rel-type-legend {
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 4px;
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
        }

        .rel-type-legend-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.4rem;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .rel-type-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.2rem;
            color: var(--text-secondary);
        }

        .rel-type-swatch {
            width: 16px;
            height: 3px;
            border-radius: 1px;
            flex-shrink: 0;
        }

        .rel-type-legend-item[data-rel-type] {
            cursor: pointer;
            user-select: none;
            padding: 1px 4px;
            border-radius: 2px;
            transition: opacity 0.15s;
        }

        .rel-type-legend-item[data-rel-type]:hover {
            background: rgba(255,255,255,0.05);
        }

        .rel-type-legend-item.rel-type-hidden {
            opacity: 0.3;
            text-decoration: line-through;
        }

        .rel-type-legend-item.rel-type-hidden .rel-type-swatch {
            opacity: 0.3;
        }

        /* Graph zoom controls */
        .graph-zoom-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 4px;
            padding: 0.4rem 0.75rem;
            z-index: 100;
        }

        .graph-zoom-controls .zoom-btn {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            width: 24px;
            height: 24px;
            font-size: 1rem;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .graph-zoom-controls .zoom-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .graph-zoom-controls .fit-btn {
            font-size: 0.9rem;
        }

        .graph-zoom-controls input[type="range"] {
            width: 80px;
            height: 4px;
            accent-color: var(--accent-primary);
            cursor: pointer;
        }

        #graphZoomDisplay {
            font-size: 0.75rem;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: center;
        }

        .graph-svg {
            display: block;
            overflow: visible;
        }

        /* Balance toggle button */
        .graph-action-btn {
            position: absolute;
            top: 10px;
            right: 100px;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 4px;
            padding: 0.4rem 0.75rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
        }

        .graph-action-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .balance-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 4px;
            padding: 0.4rem 0.75rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .balance-toggle:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .balance-toggle.active {
            background: rgba(167, 141, 182, 0.2);
            border-color: var(--accent-primary);
            color: var(--accent-highlight);
        }

        .balance-toggle-icon {
            font-size: 0.85rem;
        }

        /* Graph Connections Panel */
        .graph-connections-panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 4px;
            min-width: 200px;
            max-width: 320px;
            font-size: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            margin-bottom: 0.5rem;
        }

        .graph-connections-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0.75rem;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            border-radius: 4px 4px 0 0;
            cursor: pointer;
        }

        .graph-connections-title {
            font-weight: 500;
            color: var(--accent-secondary);
        }

        .graph-connections-toggle {
            font-size: 0.6rem;
            color: var(--text-muted);
            transition: transform 0.2s;
        }

        .graph-connections-body {
            max-height: 180px;
            overflow-y: auto;
            padding: 0.25rem 0;
        }

        .graph-connections-body.collapsed {
            display: none;
        }

        .graph-connection-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.25rem 0.75rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .graph-connection-item:hover {
            background: var(--bg-hover);
        }

        .graph-connection-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .graph-connection-label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .graph-connection-type {
            font-size: 0.6rem;
            white-space: nowrap;
        }

        .graph-connection-delete {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.15s;
            padding: 0 0.2rem;
        }

        .graph-connection-item:hover .graph-connection-delete {
            opacity: 0.5;
        }

        .graph-connection-delete:hover {
            opacity: 1 !important;
            color: var(--accent-danger);
        }

        /* Graph Context Window */
        .graph-context-window {
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 4px;
            min-width: 200px;
            max-width: 320px;
            font-size: 0.8rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .graph-context-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .graph-context-header:hover {
            background: var(--bg-hover);
        }

        .graph-context-title {
            font-weight: 600;
            color: var(--text-light);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .graph-context-toggle {
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .graph-context-body {
            padding: 0.75rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .graph-context-body.collapsed {
            display: none;
        }

        .graph-context-empty {
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            padding: 0.5rem;
        }

        .graph-context-node {
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .graph-context-node:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .graph-context-node-name {
            font-weight: 600;
            color: var(--text-light);
            margin-bottom: 0.25rem;
        }

        .graph-context-node-type {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .graph-context-rel {
            font-size: 0.75rem;
            padding: 0.25rem 0;
            color: var(--text-secondary);
        }

        .graph-context-rel-type {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
            font-size: 0.65rem;
            margin-right: 0.25rem;
        }

        .graph-context-rel-type.rate { background: rgba(201, 168, 108, 0.2); color: #c9a86c; }
        .graph-context-rel-type.weight { background: rgba(168, 123, 201, 0.2); color: #a87bc9; }
        .graph-context-rel-type.value { background: rgba(109, 179, 133, 0.2); color: #6db385; }
        .graph-context-rel-type.incompat { background: rgba(196, 92, 92, 0.2); color: #c45c5c; }
        .graph-context-rel-type.duration { background: rgba(58, 107, 139, 0.2); color: #3a6b8b; }

        .graph-context-incompat {
            border-left: 2px solid #c45c5c;
            padding-left: 0.4rem;
        }

        .graph-context-compound {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-input);
            border-radius: 3px;
        }

        .graph-context-compound-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .graph-context-compound-items {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }

        .graph-context-compound-item {
            font-size: 0.7rem;
            padding: 0.15rem 0.4rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-secondary);
        }

        /* Overview View (Tree/Graph toggle) */
        .overview-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .overview-view > .overview-content {
            flex: 1;
            overflow: auto;
        }

        .overview-toggle {
            display: flex;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-panel);
        }

        .overview-toggle-spacer {
            flex: 1;
        }

        .add-connection-btn {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-connection-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-secondary);
            background: rgba(167, 141, 182, 0.1);
        }

        .overview-mode-btn {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .overview-mode-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .overview-mode-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-secondary);
            color: var(--text-primary);
        }

        .overview-mode-btn .mode-icon {
            font-size: 0.9rem;
        }

        .overview-content {
            flex: 1;
            overflow: hidden;
        }

        /* Ticks View */
        .ticks-view {
            display: grid;
            grid-template-columns: 280px 1fr;
            height: 100%;
            overflow: hidden;
        }

        .ticks-sidebar {
            background: var(--bg-panel);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .ticks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .ticks-header h3 {
            margin: 0;
            font-size: 1rem;
            color: var(--text-primary);
            font-family: 'Raleway', sans-serif;
        }

        .ticks-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .tick-system-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 0.75rem;
            margin-bottom: 0.25rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tick-system-item:hover {
            background: var(--bg-hover);
            border-color: var(--node-ticksystem);
        }

        .tick-system-item.selected {
            background: rgba(58, 107, 139, 0.2);
            border-color: var(--node-ticksystem);
        }

        .tick-system-item .tick-icon {
            font-size: 1rem;
        }

        .tick-system-item .tick-name {
            flex: 1;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .tick-system-item .tick-unit {
            color: var(--text-muted);
            font-size: 0.75rem;
            background: var(--bg-dark);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
        }

        .ticks-detail {
            padding: 1.5rem;
            overflow-y: auto;
        }

        .tick-system-detail {
            max-width: 700px;
        }

        .tick-system-detail .detail-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .tick-system-detail .detail-section:last-child {
            border-bottom: none;
        }

        .tick-system-detail h4 {
            margin: 0 0 1rem 0;
            color: var(--node-ticksystem);
            font-family: 'Raleway', sans-serif;
            font-size: 0.95rem;
        }

        .tick-system-detail .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
        }

        .tick-system-detail .disabled-input {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .trigger-config {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
        }

        .condition-builder {
            margin-top: 0.75rem;
        }

        .condition-logic {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .condition-logic label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .condition-logic select {
            font-size: 0.85rem;
        }

        .conditions-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .condition-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-dark);
            padding: 0.5rem;
            border-radius: 4px;
            cursor: grab;
            transition: all 0.15s ease;
        }

        .condition-row:active {
            cursor: grabbing;
        }

        .condition-row.dragging {
            opacity: 0.5;
            background: var(--copper-dark);
        }

        .condition-row.drag-over {
            border: 2px dashed var(--copper);
            background: rgba(180, 130, 60, 0.15);
        }

        .condition-row select,
        .condition-row input {
            font-size: 0.85rem;
            padding: 0.3rem 0.5rem;
        }

        .condition-row select:first-child {
            flex: 1;
            min-width: 150px;
        }

        /* Hide number input spinners for cleaner look */
        .condition-row input[type="number"] {
            width: 50px;
            text-align: center;
            -moz-appearance: textfield;
        }

        .condition-row input[type="number"]::-webkit-outer-spin-button,
        .condition-row input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .condition-group {
            transition: all 0.15s ease;
        }

        .condition-group.drag-over {
            border-color: var(--copper);
            background: rgba(180, 130, 60, 0.2);
        }

        /* Connector select styling */
        .connector-select[data-value="AND"] {
            background: rgba(100, 180, 100, 0.25) !important;
            color: #90c090 !important;
            border-color: rgba(100, 180, 100, 0.5) !important;
        }

        .connector-select[data-value="OR"] {
            background: rgba(167, 141, 182, 0.25) !important;
            color: #a78db6 !important;
            border-color: rgba(167, 141, 182, 0.5) !important;
        }

        /* Toggle option styling for removal mode */
        .toggle-option {
            border: 1px solid transparent;
            transition: all 0.15s ease;
        }

        .toggle-option:hover {
            background: rgba(180, 130, 60, 0.15) !important;
        }

        .toggle-option:has(input:checked) {
            background: rgba(180, 130, 60, 0.2) !important;
            border-color: var(--copper) !important;
        }

        .toggle-option input[type="radio"] {
            accent-color: var(--copper);
        }

        .connected-modifiers-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .connected-modifier-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connected-modifier-item:hover {
            background: var(--bg-hover);
            border-color: var(--node-modifier);
        }

        .connected-modifier-item .mod-name {
            flex: 1;
            color: var(--text-primary);
        }

        .connected-modifier-item .mod-duration {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .empty-state-small {
            text-align: center;
            padding: 2rem 1rem;
            color: var(--text-muted);
        }

        .empty-state-small .empty-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            opacity: 0.5;
        }

        .empty-state-small .empty-text {
            font-size: 0.95rem;
            margin-bottom: 0.25rem;
        }

        .empty-state-small .empty-hint {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .empty-hint {
            color: var(--text-muted);
            font-size: 0.85rem;
            font-style: italic;
        }

        .tree-item .dot.ticksystem { background: var(--node-ticksystem); }

        /* Tick Bindings (Modifier Detail Panel) */
        .tick-bindings-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .tick-binding-item {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .tick-binding-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
        }

        .tick-binding-header .binding-system {
            flex: 1;
            color: var(--text-primary);
            font-weight: 500;
        }

        .tick-binding-config {
            padding: 0.75rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .tick-binding-config .form-group {
            margin: 0;
        }

        .tick-binding-config .unit-label {
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-left: 0.25rem;
        }

        .tick-binding-add {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .tick-binding-add select {
            flex: 1;
        }

        .tick-system-link {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }

        .tick-system-link a {
            color: var(--node-ticksystem);
            text-decoration: none;
            font-size: 0.85rem;
        }

        .tick-system-link a:hover {
            text-decoration: underline;
        }

        /* Duration Bindings Overview Table */
        .all-bindings-view {
            padding: 1.5rem;
        }

        .bindings-header h3 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
            font-family: 'Raleway', sans-serif;
            font-size: 1.1rem;
        }

        .bindings-hint {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 1.5rem;
        }

        .bindings-table {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            max-width: 800px;
        }

        .bindings-table-header {
            display: grid;
            grid-template-columns: 2fr 30px 2fr 1fr 1fr;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .bindings-table-row {
            display: grid;
            grid-template-columns: 2fr 30px 2fr 1fr 1fr;
            gap: 0.5rem;
            padding: 0.6rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            align-items: center;
        }

        .bindings-table-row:hover {
            background: var(--bg-hover);
            border-color: var(--node-modifier);
        }

        .bindings-table-row .col-modifier,
        .bindings-table-row .col-ticksystem {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .bindings-table-row .col-arrow {
            color: var(--text-muted);
            text-align: center;
        }

        .bindings-table-row .col-duration {
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-family: monospace;
        }

        .bindings-table-row .col-fallback {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            text-align: center;
            text-transform: capitalize;
        }

        .bindings-table-row .fallback-pause {
            background: rgba(58, 107, 139, 0.2);
            color: var(--node-ticksystem);
        }

        .bindings-table-row .fallback-expire {
            background: rgba(196, 92, 92, 0.2);
            color: #c45c5c;
        }

        .bindings-table-row .fallback-continue {
            background: rgba(111, 156, 93, 0.2);
            color: var(--accent-success);
        }

        /* Preview/Simulation View - Two Column Layout with Bottom Section */
        .preview-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr auto;
            height: 100%;
            padding: 1rem;
            gap: 1rem;
        }

        .preview-header {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .preview-header-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Left Column: Probabilities */
        .preview-probabilities {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .preview-probabilities::-webkit-scrollbar {
            width: 6px;
        }

        .preview-probabilities::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        /* Right Column: Spawn Simulator */
        .spawn-simulator {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 8px;
            overflow: hidden;
        }

        .spawn-sim-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
        }

        .spawn-sim-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .spawn-sim-controls {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .spawn-sim-body {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
        }

        .spawn-sim-warning {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.4rem 0.6rem;
            background: rgba(230, 162, 60, 0.15);
            border: 1px solid var(--accent-warning);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--accent-warning);
            margin-bottom: 0.75rem;
        }

        .spawn-sim-warning .refresh-btn {
            margin-left: auto;
            padding: 0.2rem 0.4rem;
            font-size: 0.7rem;
            background: var(--accent-warning);
            color: var(--bg-dark);
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        /* Spawn Sim Sections */
        .spawn-sim-section {
            margin-bottom: 1rem;
        }

        .spawn-sim-section:last-child {
            margin-bottom: 0;
        }

        .spawn-sim-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        /* Compact Attribute Sliders */
        .sim-attributes {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .sim-attr-row {
            display: grid;
            grid-template-columns: 90px 120px 32px;
            align-items: center;
            gap: 0.5rem;
        }

        .sim-attr-name {
            font-size: 0.75rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .sim-attr-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--bg-input);
            border-radius: 2px;
            cursor: pointer;
        }

        .sim-attr-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--node-attribute);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease;
        }

        .sim-attr-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .sim-attr-slider::-webkit-slider-thumb:active {
            transform: scale(1.3);
            box-shadow: 0 0 6px var(--node-attribute);
        }

        .sim-attr-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--node-attribute);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .sim-attr-slider::-moz-range-thumb:active {
            transform: scale(1.3);
            box-shadow: 0 0 6px var(--node-attribute);
        }

        .sim-attr-value {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--node-attribute);
            text-align: center;
            transition: color 0.15s ease;
        }

        .sim-attr-row:has(.sim-attr-slider:active) .sim-attr-value {
            color: var(--accent-gold);
        }

        .sim-attr-row.active-influence {
            background: rgba(168, 123, 201, 0.1);
            border-radius: 4px;
            margin: -0.15rem;
            padding: 0.15rem;
        }

        .sim-attr-row.active-influence .sim-attr-name {
            color: var(--node-weight-influence);
        }

        /* Sim Traits Display */
        .sim-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .sim-trait-tag {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--text-primary);
        }

        .sim-trait-tag.active {
            background: rgba(139, 107, 184, 0.2);
            border-color: var(--node-trait);
        }

        .sim-trait-tag .remove-btn {
            cursor: pointer;
            color: var(--text-muted);
            font-size: 0.65rem;
        }

        .sim-trait-tag .remove-btn:hover {
            color: var(--accent-danger);
        }

        .sim-add-btn {
            padding: 0.2rem 0.4rem;
            font-size: 0.7rem;
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            color: var(--text-muted);
            cursor: pointer;
        }

        .sim-add-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        /* Sim Dropdown Menu */
        .sim-dropdown-menu {
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            max-height: 250px;
            overflow-y: auto;
            min-width: 150px;
        }

        .sim-dropdown-group {
            padding: 0.4rem 0.6rem;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
        }

        .sim-dropdown-item {
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
            color: var(--text-primary);
            cursor: pointer;
        }

        .sim-dropdown-item:hover:not(.disabled) {
            background: var(--bg-hover);
        }

        .sim-dropdown-item.disabled {
            opacity: 0.5;
            cursor: default;
        }

        /* Sim Variables Display */
        .sim-variables {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .sim-var-row {
            display: grid;
            grid-template-columns: 90px 1fr 40px;
            align-items: center;
            gap: 0.5rem;
        }

        .sim-var-name {
            font-size: 0.75rem;
            color: var(--text-primary);
        }

        .sim-var-bar {
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            overflow: hidden;
        }

        .sim-var-fill {
            height: 100%;
            background: var(--node-variable);
            border-radius: 3px;
            transition: width 0.2s ease;
        }

        .sim-var-value {
            font-size: 0.7rem;
            color: var(--node-variable);
            text-align: right;
        }

        /* Sim Modifiers Display */
        .sim-modifiers {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .sim-modifier-tag {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.4rem;
            background: rgba(166, 93, 122, 0.2);
            border: 1px solid var(--node-modifier);
            border-radius: 4px;
            font-size: 0.7rem;
            color: var(--node-modifier);
        }

        /* Variable sliders in spawn sim */
        .sim-var-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            cursor: pointer;
        }

        .sim-var-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: var(--node-variable);
            border-radius: 50%;
            cursor: pointer;
        }

        .sim-var-slider::-moz-range-thumb {
            width: 10px;
            height: 10px;
            background: var(--node-variable);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .sim-var-row.locked .sim-var-slider {
            opacity: 0.6;
        }

        /* Spawned Entities Section (Spawn Logic Tab) */
        .spawn-logic-entities-section {
            grid-column: 1 / -1;
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 0.5rem;
        }

        .sle-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .spawn-logic-entities {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            padding: 0.75rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .spawn-empty-msg {
            font-size: 0.8rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 1rem;
            text-align: center;
            width: 100%;
        }

        /* v3.3 Session 4: .spawn-logic-entity and .sle-* CSS deleted */

        @keyframes spawn-flash {
            0% { background: rgba(212, 175, 55, 0.3); }
            100% { background: var(--bg-input); }
        }

        /* Spawn success button flash */
        .btn.spawn-success {
            animation: btn-success-flash 0.5s ease;
        }

        @keyframes btn-success-flash {
            0%, 100% { background: var(--accent-gold); }
            50% { background: var(--accent-success); box-shadow: 0 0 12px var(--accent-success); }
        }

        /* Toast notification */
        .spawn-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            padding: 0.6rem 1rem;
            background: var(--bg-dark);
            border: 1px solid var(--accent-success);
            border-radius: 6px;
            color: var(--accent-success);
            font-size: 0.85rem;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 10000;
        }

        .spawn-toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Spawn Tab Bar */
        .spawn-tab-bar {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border-ornate);
            background: var(--bg-dark);
            border-radius: 6px 6px 0 0;
        }

        .spawn-tab {
            flex: 1;
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            border-bottom: 2px solid transparent;
        }

        .spawn-tab:hover {
            color: var(--text-primary);
            background: rgba(212, 175, 55, 0.05);
        }

        .spawn-tab.active {
            color: var(--accent-gold);
            border-bottom-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.08);
        }

        .spawn-tab .tab-badge {
            display: inline-block;
            min-width: 16px;
            height: 16px;
            line-height: 16px;
            text-align: center;
            font-size: 0.65rem;
            font-weight: 700;
            background: rgba(212, 175, 55, 0.2);
            color: var(--accent-gold);
            border-radius: 8px;
            padding: 0 4px;
            margin-left: 4px;
        }

        .spawn-tab-content {
            flex: 1;
            overflow-y: auto;
        }

        .spawn-tab-content > .probabilities-panel {
            padding: 0.75rem;
        }

        /* Entity List in Entities Tab */
        .entity-list-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.15s ease;
        }

        .entity-list-item:hover {
            background: rgba(212, 175, 55, 0.06);
        }

        .entity-list-item.selected {
            background: rgba(212, 175, 55, 0.08);
        }

        .entity-list-item.newest {
            animation: spawn-flash 0.5s ease;
        }

        .entity-list-item .entity-list-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entity-list-item .entity-list-traits {
            display: flex;
            gap: 0.2rem;
            flex-wrap: wrap;
            max-width: 60%;
        }

        .entity-list-item .entity-list-trait {
            font-size: 0.6rem;
            padding: 0.1rem 0.3rem;
            background: rgba(140, 120, 180, 0.2);
            border-radius: 3px;
            color: var(--node-trait);
        }

        /* Entity Inline Expand (Entities sub-tab) */
        .entity-list-item-wrap {
            border-bottom: 1px solid var(--border-color);
        }

        .entity-list-item-wrap .entity-list-item {
            border-bottom: none;
        }

        .entity-list-item-wrap.expanded {
            background: rgba(212, 175, 55, 0.04);
            border-left: 3px solid var(--accent-gold);
        }

        .entity-expand-arrow {
            font-size: 0.6rem;
            color: var(--text-muted);
            width: 12px;
            flex-shrink: 0;
        }

        .entity-inline-detail {
            padding: 0.35rem 0.75rem 0.5rem 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .entity-inline-section {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .entity-inline-label {
            font-size: 0.6rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
            min-width: 55px;
            flex-shrink: 0;
            padding-top: 0.1rem;
        }

        .entity-inline-actions {
            display: flex;
            gap: 0.35rem;
            margin-top: 0.25rem;
            padding-top: 0.35rem;
            border-top: 1px solid var(--border-color);
        }

        /* Entity Detail View in Right Panel */
        .entity-detail-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
        }

        .entity-detail-back {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
        }

        .entity-detail-back:hover {
            color: var(--text-primary);
            background: rgba(255,255,255,0.05);
        }

        .entity-detail-name {
            flex: 1;
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--accent-gold);
        }

        .entity-detail-section {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .entity-detail-section-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.35rem;
        }

        .entity-detail-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .entity-detail-badge {
            font-size: 0.7rem;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-weight: 500;
        }

        .entity-detail-badge.trait-badge {
            background: rgba(140, 120, 180, 0.2);
            color: var(--node-trait);
            border: 1px solid rgba(140, 120, 180, 0.3);
        }

        .entity-detail-badge.mod-badge {
            background: rgba(166, 93, 122, 0.2);
            color: var(--node-modifier);
            border: 1px solid rgba(166, 93, 122, 0.3);
        }

        .entity-detail-badge.compound-badge {
            background: rgba(176, 60, 60, 0.2);
            color: var(--node-compound);
            border: 1px solid rgba(176, 60, 60, 0.3);
        }

        .entity-detail-layer-group {
            margin-bottom: 0.35rem;
        }

        .entity-detail-layer-name {
            font-size: 0.65rem;
            color: var(--node-layer);
            margin-bottom: 0.15rem;
        }

        /* Unified Entity State View */
        .entity-state-input,
        .entity-state-output {
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 8px;
            padding: 0.75rem;
        }

        .entity-state-input::-webkit-scrollbar,
        .entity-state-output::-webkit-scrollbar {
            width: 6px;
        }

        .entity-state-input::-webkit-scrollbar-thumb,
        .entity-state-output::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        .entity-state-section {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .entity-state-section:last-child {
            border-bottom: none;
        }

        .entity-state-section-title {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.35rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-state-section-title .edit-hint {
            font-weight: normal;
            font-size: 0.6rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .entity-state-empty {
            padding: 2rem;
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Entity attribute bars (read-only) */
        .entity-attr-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .entity-attr-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            width: 80px;
            text-align: right;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entity-attr-bar {
            flex: 1;
            height: 6px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
            overflow: hidden;
        }

        .entity-attr-fill {
            height: 100%;
            background: var(--node-attribute);
            border-radius: 3px;
            transition: width 0.2s ease;
        }

        .entity-attr-value {
            font-size: 0.7rem;
            color: var(--node-attribute);
            font-weight: 600;
            min-width: 24px;
            text-align: right;
        }

        /* Entity variable sliders */
        .entity-var-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .entity-var-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            width: 80px;
            text-align: right;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entity-var-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255,255,255,0.08);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .entity-var-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--node-variable);
            cursor: pointer;
        }

        .entity-var-value {
            font-size: 0.7rem;
            color: var(--node-variable);
            font-weight: 600;
            min-width: 28px;
            text-align: right;
        }

        /* Deprecated - keep for backwards compat */
        .preview-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        /* Tick Systems Panel in Preview */
        .tick-systems-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .tick-panel-header {
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
        }

        .tick-panel-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .tick-panel-systems {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.75rem;
        }

        .tick-panel-system {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            min-width: 200px;
        }

        .tick-panel-system.active {
            border-color: var(--node-ticksystem);
            background: rgba(58, 107, 139, 0.1);
        }

        .tick-system-info {
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .tick-system-name {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .tick-system-counter {
            font-size: 0.75rem;
            color: var(--node-ticksystem);
            font-family: monospace;
        }

        .tick-system-controls {
            display: flex;
            gap: 0.25rem;
            margin-left: auto;
        }

        .tick-system-controls .btn-success {
            background: var(--accent-success);
            border-color: var(--accent-success);
        }

        .tick-system-controls .btn-danger {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
        }

        .tick-system-controls .btn-icon.active {
            background: var(--node-ticksystem);
            border-color: var(--node-ticksystem);
        }

        .preview-stats {
            margin-left: auto;
            display: flex;
            gap: 1rem;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .preview-stats strong {
            color: var(--text-light);
        }

        /* Spawn Options Panel */
        .spawn-options-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .spawn-options-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .spawn-options-header:hover {
            background: var(--bg-hover);
        }

        .spawn-options-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .spawn-options-toggle {
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .spawn-options-content {
            padding: 0.75rem;
            display: none;
        }

        .spawn-options-panel.expanded .spawn-options-content {
            display: block;
        }

        .spawn-options-panel.expanded .spawn-options-toggle {
            transform: rotate(180deg);
        }

        /* Probability Breakdown */
        .probability-breakdown {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .probability-layer {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
        }

        .probability-layer-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--node-layer);
            margin-bottom: 0.35rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .probability-layer-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .probability-trait {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 0.75rem;
        }

        .probability-trait .trait-name {
            color: var(--text-primary);
        }

        .probability-trait .trait-pct {
            color: var(--accent-gold);
            font-weight: 600;
            font-size: 0.65rem;
        }

        .probability-trait.high-chance {
            border-color: var(--accent-success);
        }

        .probability-trait.low-chance {
            opacity: 0.6;
        }

        .probability-trait.has-influences {
            cursor: pointer;
        }

        .probability-trait .influence-indicator {
            font-size: 0.6rem;
            color: var(--node-weight-influence);
            margin-left: 0.15rem;
        }

        /* Probability Tooltip (expanded breakdown) */
        .probability-tooltip {
            position: fixed;
            z-index: 10000;
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            padding: 0.75rem;
            min-width: 220px;
            max-width: 320px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .probability-tooltip.visible {
            opacity: 1;
        }

        .probability-tooltip-header {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            padding-bottom: 0.35rem;
            border-bottom: 1px solid var(--border-color);
        }

        .probability-tooltip-math {
            font-family: monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: var(--bg-input);
            padding: 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .probability-tooltip-math .math-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .probability-tooltip-math .math-line:last-child {
            margin-bottom: 0;
            padding-top: 0.25rem;
            border-top: 1px solid var(--border-color);
            font-weight: 600;
            color: var(--accent-gold);
        }

        .probability-tooltip-math .math-label {
            color: var(--text-muted);
        }

        .probability-tooltip-math .math-value {
            color: var(--text-primary);
        }

        .probability-tooltip-math .math-value.positive {
            color: var(--accent-success);
        }

        .probability-tooltip-math .math-value.negative {
            color: var(--accent-danger);
        }

        .probability-tooltip-influences {
            margin-top: 0.5rem;
        }

        .probability-tooltip-influences-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.35rem;
        }

        .probability-tooltip-influence {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
            padding: 0.25rem 0.35rem;
            background: var(--bg-panel);
            border-radius: 3px;
        }

        .probability-tooltip-influence .influence-icon {
            font-size: 0.65rem;
        }

        .probability-tooltip-influence .influence-source {
            color: var(--text-primary);
            flex: 1;
        }

        .probability-tooltip-influence .influence-effect {
            font-weight: 600;
        }

        .probability-tooltip-influence .influence-effect.positive {
            color: var(--accent-success);
        }

        .probability-tooltip-influence .influence-effect.negative {
            color: var(--accent-danger);
        }

        .probability-tooltip-note {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 0.5rem;
        }

        /* Layer info icon */
        .probability-layer-info {
            font-size: 0.65rem;
            color: var(--text-muted);
            cursor: help;
            margin-left: 0.25rem;
        }

        .probability-layer-info:hover {
            color: var(--accent-primary);
        }

        /* Relationship Legend */
        .relationship-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-panel);
            border-radius: 4px;
            margin-bottom: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .relationship-legend-title {
            width: 100%;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .relationship-legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            padding: 0.2rem 0.4rem;
            background: var(--bg-input);
            border-radius: 3px;
            cursor: help;
        }

        .relationship-legend-item .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .relationship-legend-item .legend-label {
            color: var(--text-secondary);
        }

        /* Attribute Simulator Panel */
        .attribute-simulator-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .attribute-simulator-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .attribute-simulator-header:hover {
            background: var(--bg-hover);
        }

        .attribute-simulator-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .attribute-simulator-toggle {
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .attribute-simulator-content {
            padding: 0.75rem;
            display: none;
        }

        .attribute-simulator-panel.expanded .attribute-simulator-content {
            display: block;
        }

        .attribute-simulator-panel.expanded .attribute-simulator-toggle {
            transform: rotate(180deg);
        }

        .simulator-note {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
            margin-bottom: 0.75rem;
        }

        .simulator-attributes {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .simulator-attribute {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .simulator-attribute-name {
            font-size: 0.8rem;
            color: var(--text-primary);
            min-width: 100px;
        }

        .simulator-attribute-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            cursor: pointer;
        }

        .simulator-attribute-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--node-attribute);
            border-radius: 50%;
            cursor: pointer;
        }

        .simulator-attribute-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--node-attribute);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .simulator-attribute-value {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--node-attribute);
            min-width: 35px;
            text-align: right;
        }

        .simulator-reset-btn {
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }

        /* Simulator attribute highlighting when affecting traits */
        .simulator-attribute.affecting {
            background: rgba(168, 123, 201, 0.1);
            border-radius: 4px;
            margin: -0.25rem;
            padding: 0.25rem;
        }

        .simulator-attribute-name .affected-count {
            font-size: 0.65rem;
            color: var(--node-weight-influence);
            margin-left: 0.25rem;
        }

        /* ============================================
           PROBABILITY VISUALIZATION (Pre-Spawn Sim)
           ============================================ */

        .probability-viz {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Layer card with traits inside */
        .prob-layer-card {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .prob-layer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
        }

        .prob-layer-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--node-layer);
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .prob-layer-rolls {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-weight: normal;
        }

        .prob-layer-body {
            padding: 0.5rem;
        }

        /* Individual trait probability row - see Two-Column Spawn Preview Styles for main definition */

        /* Probability breakdown rows (renderProbabilityBreakdown) â€” uses flex, not grid */
        .prob-breakdown-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            cursor: default;
            flex-wrap: wrap;
        }

        .prob-breakdown-row:hover {
            background: rgba(212, 175, 55, 0.08);
        }

        .prob-breakdown-row.highlighted {
            background: rgba(212, 175, 55, 0.15);
        }

        .prob-breakdown-row.gated {
            opacity: 0.5;
            background: rgba(224, 82, 82, 0.1);
        }

        .prob-trait-row.gated {
            opacity: 0.5;
            background: rgba(224, 82, 82, 0.1);
            border-color: var(--node-eligibility-gate);
        }

        .prob-trait-name {
            font-size: 0.8rem;
            color: var(--text-primary);
            min-width: 100px;
            flex-shrink: 0;
        }

        .prob-trait-name .gate-icon {
            color: var(--node-eligibility-gate);
            font-size: 0.7rem;
            margin-left: 0.25rem;
        }

        /* Probability bar container */
        .prob-bar-container {
            flex: 1;
            height: 20px;
            background: var(--bg-input);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        /* The actual probability bar */
        .prob-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--node-trait) 0%, var(--node-layer) 100%);
            border-radius: 3px;
            transition: width 0.3s ease;
            position: relative;
        }

        .prob-bar.high {
            background: linear-gradient(90deg, var(--accent-success) 0%, #4a9c6d 100%);
        }

        .prob-bar.low {
            background: linear-gradient(90deg, var(--text-muted) 0%, #666 100%);
        }

        /* Stacked probability bar â€” shows all traits relative to each other */
        .prob-stacked-bar {
            display: flex;
            height: 16px;
            border-radius: 3px;
            overflow: hidden;
            background: var(--bg-input);
            margin-bottom: 0.5rem;
        }

        .prob-stacked-segment {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            min-width: 1px;
        }

        .prob-stacked-segment:first-child {
            border-radius: 3px 0 0 3px;
        }

        .prob-stacked-segment:last-child {
            border-radius: 0 3px 3px 0;
        }

        .prob-stacked-segment:only-child {
            border-radius: 3px;
        }

        .prob-stacked-label {
            font-size: 0.55rem;
            font-weight: 600;
            color: #111;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 4px;
            line-height: 16px;
            display: flex;
            align-items: center;
            height: 100%;
            pointer-events: none;
        }

        /* Probability color dot (legend in stacked bar) */
        .prob-color-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
            vertical-align: middle;
        }

        /* ===== Formula Blocks Editor (v3.5.0) ===== */

        .formula-section {
            position: relative;
        }

        /* Collapsed summary */
        .formula-summary {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
            padding: 0.5rem 0.6rem;
            background: rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            min-height: 2.2rem;
            transition: border-color 0.15s;
        }
        .formula-summary:hover {
            border-color: var(--accent-primary);
        }
        .formula-summary-top {
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        .formula-summary-text {
            font-size: 0.8rem;
            font-family: monospace;
            color: var(--text-muted);
            line-height: 1.6;
            padding-left: 1.6rem;
            text-indent: -1.6rem;
        }
        .formula-summary-text .formula-node-name { color: #c4a0e8; font-weight: 600; }
        .formula-summary-text .formula-operator { color: #c9a86c; font-weight: 500; font-size: 1.15em; }
        .formula-summary-text .formula-number { color: #7bc4a0; font-weight: 600; }
        .formula-summary-text .formula-preview-eq { color: var(--text-muted); opacity: 0.7; }
        .formula-summary-empty {
            color: var(--text-muted);
            font-style: italic;
            font-size: 0.8rem;
            opacity: 0.5;
            font-family: inherit;
        }
        .formula-summary-edit-btn {
            flex: 0 0 auto;
            font-size: 0.65rem;
            padding: 0.15rem 0.45rem;
            border: 1px solid var(--accent-primary);
            border-radius: 3px;
            color: var(--accent-primary);
            background: transparent;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .formula-summary-edit-btn:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        /* Expanded editor overlay â€” positioned via JS for reliable placement */
        .formula-editor-expanded {
            position: fixed;
            z-index: 250;
            width: 580px;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate, var(--border-color));
            border-radius: 8px;
            box-shadow: -4px 0 24px rgba(0, 0, 0, 0.5), 0 4px 16px rgba(0, 0, 0, 0.4);
            padding: 0.75rem;
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            outline: none;
            max-width: calc(100vw - 20px);
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }
        .formula-editor-expanded.active {
            display: flex;
        }

        .formula-editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 0.4rem;
            border-bottom: 1px solid var(--border-color);
        }
        .formula-editor-title {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--accent-secondary);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }
        .formula-editor-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.1rem;
            cursor: pointer;
            padding: 0 0.3rem;
            line-height: 1;
        }
        .formula-editor-close:hover { color: var(--text-primary); }

        /* Blocks area */
        .formula-blocks-area {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            min-height: 2.8rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.12);
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.03);
        }
        .formula-blocks-area:empty::before {
            content: 'Use the builder below to add blocks';
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
            opacity: 0.5;
        }

        /* Step chip */
        .formula-step-chip {
            display: inline-flex;
            align-items: center;
            gap: 0;
            border-radius: 5px;
            font-size: 0.85rem;
            user-select: none;
            border: 1px solid rgba(155, 123, 196, 0.35);
            background: rgba(155, 123, 196, 0.08);
            cursor: grab;
            transition: border-color 0.15s, box-shadow 0.15s;
            position: relative;
        }
        .formula-step-chip:hover {
            border-color: rgba(155, 123, 196, 0.55);
        }
        .formula-step-chip.selected {
            border-color: var(--accent-primary);
            box-shadow: 0 0 6px rgba(212, 175, 55, 0.3);
        }
        .formula-blocks-area.has-selection .formula-step-chip:not(.selected) {
            opacity: 0.55;
        }
        .formula-blocks-area.has-selection .formula-step-chip:not(.selected):hover {
            opacity: 0.85;
        }
        .formula-step-chip.dragging { opacity: 0.4; }

        /* Quick delete on hover */
        .formula-step-delete {
            display: none;
            position: absolute;
            top: -9px;
            right: -7px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid rgba(224, 82, 82, 0.4);
            background: var(--bg-surface);
            color: rgba(224, 82, 82, 0.8);
            font-size: 0.6rem;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            line-height: 1;
            z-index: 2;
        }
        .formula-step-chip:hover .formula-step-delete { display: flex; }
        .formula-step-delete:hover { color: #e05252; border-color: #e05252; background: rgba(224, 82, 82, 0.1); }

        /* Split icon on compound block hover */
        .formula-step-split {
            display: none;
            position: absolute;
            top: -9px;
            right: 14px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid rgba(201, 168, 108, 0.4);
            background: var(--bg-surface);
            color: rgba(201, 168, 108, 0.8);
            font-size: 0.65rem;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            line-height: 1;
            z-index: 2;
        }
        .formula-step-chip.compound:hover .formula-step-split { display: flex; }
        .formula-step-split:hover { color: #c9a86c; border-color: #c9a86c; background: rgba(201, 168, 108, 0.1); }

        /* Step value segments */
        .formula-step-value {
            padding: 0.25rem 0.45rem;
            border-radius: 3px;
        }
        .formula-step-value.is-id { color: #c4a0e8; font-weight: 500; }
        .formula-step-value.is-num { color: #7bc4a0; font-weight: 600; }
        .formula-step-value.seg-error { color: #e05252; text-decoration: underline wavy #e05252; }

        /* Internal operator in block */
        .formula-step-op {
            color: #c9a86c;
            font-weight: 500;
            font-size: 1.3rem;
            padding: 0.25rem 0.3rem;
            cursor: pointer;
            transition: opacity 0.15s;
            opacity: 0.85;
        }
        .formula-step-op:hover { opacity: 1; }

        /* Step label */
        .formula-step-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            position: absolute;
            top: -11px;
            left: 3px;
            white-space: nowrap;
            opacity: 0.7;
            font-style: italic;
        }

        /* Drag insertion indicator */
        .formula-drag-indicator {
            width: 2px;
            height: 24px;
            background: var(--accent-primary);
            border-radius: 1px;
            flex-shrink: 0;
            box-shadow: 0 0 6px rgba(212, 175, 55, 0.5);
        }
        .formula-blocks-area.drag-active {
            border: 2px dashed var(--accent-primary);
            background: rgba(212, 175, 55, 0.04);
        }
        .formula-step-chip.drop-target {
            box-shadow: 0 0 6px rgba(212, 175, 55, 0.3);
            border-color: rgba(212, 175, 55, 0.4);
        }
        .formula-step-chip.combine-target {
            box-shadow: 0 0 10px rgba(155, 123, 196, 0.5);
            border-color: rgba(155, 123, 196, 0.7);
            background: rgba(155, 123, 196, 0.15);
        }

        /* Block detail editor */
        .formula-detail-editor {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 0.6rem;
            display: none;
            flex-direction: column;
            gap: 0.4rem;
        }
        .formula-detail-editor.active {
            display: flex;
        }
        .formula-detail-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.1rem;
        }
        .formula-detail-title {
            font-size: 0.7rem;
            color: var(--accent-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .formula-detail-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .formula-detail-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
            min-width: 38px;
            flex: 0 0 auto;
        }
        .formula-detail-input {
            flex: 1;
            font-size: 0.8rem;
            padding: 0.25rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            outline: none;
        }
        .formula-detail-input:focus { border-color: var(--accent-primary); }
        .formula-detail-input::placeholder { color: var(--text-muted); opacity: 0.5; }

        /* Value selector (id dropdown + num input side by side) */
        .formula-value-selector {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            flex: 1;
        }
        .formula-detail-id-select {
            flex: 1;
            font-size: 0.75rem;
            max-width: 200px;
        }
        .formula-detail-num-input {
            width: 5em;
            font-size: 0.8rem;
            padding: 0.25rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: #7bc4a0;
            font-weight: 600;
            outline: none;
        }
        .formula-detail-num-input:focus { border-color: var(--accent-primary); }
        .formula-detail-id-switch {
            flex: 0 0 auto;
            font-size: 0.65rem;
            max-width: 80px;
            width: auto !important;
            cursor: pointer;
            opacity: 0.6;
        }
        .formula-detail-id-switch:hover { opacity: 1; }
        .formula-detail-num-switch {
            width: 3.5em;
            font-size: 0.75rem;
            padding: 0.2rem 0.3rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: #7bc4a0;
            font-weight: 600;
            outline: none;
            opacity: 0.6;
        }
        .formula-detail-num-switch:focus { opacity: 1; border-color: var(--accent-primary); }
        .formula-detail-num-switch::placeholder { color: var(--text-muted); font-weight: 400; opacity: 0.5; }

        /* Operator selector (4 buttons) */
        .formula-op-selector {
            display: flex;
            gap: 2px;
        }
        .formula-op-btn {
            width: 28px;
            height: 28px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
            color: var(--text-muted);
            font-weight: 700;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .formula-op-btn:hover { border-color: var(--text-muted); }
        .formula-op-btn.active {
            color: #c9a86c;
            border-color: #c9a86c;
            background: rgba(201, 168, 108, 0.12);
        }

        /* Detail action buttons */
        .formula-detail-actions {
            display: flex;
            gap: 0.4rem;
            padding-top: 0.3rem;
            border-top: 1px solid rgba(255, 255, 255, 0.04);
            margin-top: 0.2rem;
        }
        .formula-detail-btn {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
        }
        .formula-detail-btn:hover { color: var(--text-primary); border-color: var(--text-muted); }
        .formula-detail-btn.delete { color: rgba(224, 82, 82, 0.7); }
        .formula-detail-btn.delete:hover { color: #e05252; border-color: #e05252; }

        /* Block builder panel */
        .formula-editor-toolbar {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            padding: 0.5rem;
            margin-top: 0.3rem;
            background: rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        .formula-builder-header {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.6;
        }
        .formula-builder-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .formula-builder-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            min-width: 32px;
            flex-shrink: 0;
        }
        .formula-builder-value {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            flex: 1;
        }
        .formula-builder-type-toggle {
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.2);
            color: var(--text-muted);
            cursor: pointer;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .formula-builder-type-toggle:hover { border-color: var(--text-muted); }
        .formula-builder-select {
            flex: 1;
            font-size: 0.75rem;
            min-width: 0;
        }
        .formula-builder-num-input {
            flex: 1;
            font-size: 0.8rem;
            padding: 0.2rem 0.3rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: #7bc4a0;
            font-weight: 600;
            outline: none;
            min-width: 0;
        }
        .formula-builder-num-input:focus { border-color: var(--accent-primary); }
        .formula-builder-num-input::placeholder { color: var(--text-muted); font-weight: 400; opacity: 0.5; }
        .formula-builder-ops {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }
        .formula-builder-op-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background: rgba(0, 0, 0, 0.15);
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s;
        }
        .formula-builder-op-btn:hover { border-color: rgba(201, 168, 108, 0.4); color: #c9a86c; }
        .formula-builder-op-btn.active { border-color: #c9a86c; color: #c9a86c; background: rgba(201, 168, 108, 0.12); }
        .formula-builder-right.disabled { opacity: 0.35; pointer-events: none; }
        .formula-builder-actions {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding-top: 0.3rem;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        .formula-builder-btn-add {
            font-size: 0.75rem;
            padding: 0.25rem 0.6rem;
            border-radius: 3px;
            border: 1px solid var(--accent-primary);
            background: rgba(212, 175, 55, 0.1);
            color: var(--accent-primary);
            cursor: pointer;
            font-weight: 600;
            transition: background 0.15s;
        }
        .formula-builder-btn-add:hover { background: rgba(212, 175, 55, 0.2); }
        .formula-builder-btn-add:disabled { opacity: 0.3; cursor: default; }


        /* ===== End Formula Blocks Editor CSS ===== */

        /* --- Shared Formula Editor Utilities --- */

        /* Inter-block operator â€” clickable */
        .formula-inter-op {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0 0.5rem;
            color: #c9a86c;
            font-weight: 500;
            font-size: 1.5rem;
            cursor: pointer;
            user-select: none;
            transition: opacity 0.15s;
            opacity: 0.85;
        }
        .formula-inter-op:hover { opacity: 1; }

        /* Number quick-add input in toolbar */
        .formula-num-add {
            width: 4em;
            font-size: 0.8rem;
            padding: 0.2rem 0.3rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: #7bc4a0;
            font-weight: 600;
            outline: none;
        }
        .formula-num-add::placeholder { color: var(--text-muted); font-weight: 400; opacity: 0.5; }
        .formula-num-add:focus { border-color: var(--accent-primary); }

        /* ID insert dropdown in toolbar */
        .formula-id-insert {
            flex: 0 0 auto;
            min-width: 90px;
            max-width: 150px;
            font-size: 0.75rem;
            cursor: pointer;
            width: auto !important;
        }

        /* Undo/redo buttons */
        .formula-undo-btn {
            background: none;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-muted);
            font-size: 0.7rem;
            padding: 0.15rem 0.35rem;
            cursor: pointer;
            min-width: 42px;
            text-align: center;
        }
        .formula-undo-btn:hover { color: var(--text-primary); border-color: var(--text-muted); }
        .formula-undo-btn:disabled { opacity: 0.3; cursor: default; }

        /* Inline validation error box */
        .formula-errors-box {
            font-size: 0.7rem;
            color: #c9a86c;
            padding: 0.25rem 0.5rem;
            background: rgba(201, 168, 108, 0.08);
            border-left: 2px solid #c9a86c;
            border-radius: 0 3px 3px 0;
            margin-top: 0.2rem;
        }
        .formula-errors-box:empty { display: none; }

        /* Formula preview */
        .formula-preview {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.3rem;
            padding: 0.35rem 0.6rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
            font-family: monospace;
            line-height: 1.6;
            border-left: 2px solid var(--border-color);
        }
        .formula-preview .formula-node-name { color: #c4a0e8; font-weight: 600; }
        .formula-preview .formula-operator { color: #c9a86c; font-weight: 500; font-size: 1.15em; padding: 0 0.3rem; }
        .formula-preview .formula-number { color: #7bc4a0; font-weight: 600; }
        .formula-preview .formula-paren-implicit { color: #9b7bc4; opacity: 0.5; font-weight: 400; }
        .formula-preview .formula-bracket { color: #9b7bc4; font-weight: 600; opacity: 0.7; }
        .formula-preview .formula-error-id { color: #e05252; text-decoration: underline wavy #e05252; }
        .formula-preview .formula-errors { color: #e05252; font-size: 0.7rem; margin-top: 0.25rem; font-family: inherit; }

        /* Delta indicator (shows change from baseline) */
        .prob-delta {
            position: absolute;
            right: 100%;
            top: 0;
            height: 100%;
            background: var(--node-weight-influence);
            opacity: 0.5;
            transition: width 0.3s ease;
        }

        .prob-delta.negative {
            background: var(--accent-danger);
            right: auto;
            left: 100%;
        }

        /* Percentage label */
        .prob-pct {
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 45px;
            text-align: right;
            color: var(--text-primary);
        }

        .prob-pct .delta-text {
            font-size: 0.65rem;
            font-weight: normal;
            margin-left: 0.15rem;
        }

        .prob-pct .delta-text.positive {
            color: var(--accent-success);
        }

        .prob-pct .delta-text.negative {
            color: var(--accent-danger);
        }

        /* Influence chain indicator */
        .prob-influences {
            font-size: 0.65rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 0.25rem;
            min-width: 80px;
        }

        .prob-influences .influence-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.15rem;
            padding: 0.1rem 0.25rem;
            background: var(--bg-input);
            border-radius: 2px;
            font-size: 0.6rem;
        }

        .prob-influences .influence-chip.positive {
            color: var(--accent-success);
            background: rgba(109, 179, 133, 0.15);
        }

        .prob-influences .influence-chip.negative {
            color: var(--accent-danger);
            background: rgba(224, 82, 82, 0.15);
        }

        /* Connection line animation when slider moves */
        @keyframes pulse-influence {
            0% { opacity: 0.3; }
            50% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        .prob-trait-row.pulsing {
            animation: pulse-influence 0.5s ease;
        }

        /* ========================================
           SIMULATION VIEW + ENTITY TRAY
           ======================================== */

        .simulation-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 0;
            overflow: hidden;
        }

        .simulation-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            min-height: 48px;
        }

        .simulation-header-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'Raleway', sans-serif;
        }

        .sim-preset-selector {
            padding: 0.3rem 0.6rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
            cursor: pointer;
            max-width: 200px;
        }

        .sim-preset-selector:hover {
            border-color: var(--accent-copper);
        }

        .simulation-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            padding: 1rem;
        }

        /* Entity Tray */
        .entity-tray {
            flex-shrink: 0;
            border-top: 1px solid var(--border-ornate);
            background: var(--bg-secondary);
            padding: 0.5rem 1rem;
            min-height: 40px;
            max-height: 120px;
        }

        .entity-tray-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.4rem;
        }

        .entity-tray-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .entity-tray-cards {
            display: flex;
            gap: 0.5rem;
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 0.25rem;
            scrollbar-width: thin;
        }

        .entity-tray-cards::-webkit-scrollbar {
            height: 4px;
        }

        .entity-tray-cards::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 2px;
        }

        .entity-tray-card {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            padding: 0.4rem 0.6rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            min-width: 100px;
            max-width: 160px;
            transition: all 0.15s ease;
        }

        .entity-tray-card:hover {
            border-color: var(--accent-copper);
            background: rgba(167, 141, 182, 0.08);
        }

        .entity-tray-card.selected {
            border-color: var(--accent-copper);
            background: rgba(167, 141, 182, 0.15);
            box-shadow: 0 0 8px rgba(167, 141, 182, 0.3);
        }

        .entity-tray-card-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .entity-tray-card-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 0.15rem;
        }

        .entity-tray-trait {
            font-size: 0.6rem;
            color: var(--text-muted);
            background: rgba(167, 141, 182, 0.1);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            white-space: nowrap;
        }

        .entity-tray-more {
            font-size: 0.55rem;
            color: var(--text-muted);
            opacity: 0.7;
            padding: 0.1rem 0.2rem;
        }

        .entity-tray-empty {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            padding: 0.5rem;
            opacity: 0.7;
        }

        @keyframes tray-spawn-flash {
            0% { background: rgba(167, 141, 182, 0.4); transform: scale(1.05); }
            100% { background: var(--bg-card); transform: scale(1); }
        }

        .entity-tray-card.just-spawned {
            animation: tray-spawn-flash 0.5s ease-out;
        }

        /* ========================================
           TWO-COLUMN SPAWN PREVIEW STYLES
           ======================================== */

        .two-column-preview {
            grid-template-columns: 1fr !important;
            grid-template-rows: auto 1fr auto !important;
        }

        .preview-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            min-height: 0;
            overflow: hidden;
        }

        .preview-stats-column,
        .preview-probabilities-column {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 8px;
            padding: 0;
        }

        .preview-stats-column::-webkit-scrollbar,
        .preview-probabilities-column::-webkit-scrollbar,
        .spawn-tab-content::-webkit-scrollbar {
            width: 6px;
        }

        .preview-stats-column::-webkit-scrollbar-thumb,
        .preview-probabilities-column::-webkit-scrollbar-thumb,
        .spawn-tab-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        /* Stats Panel (Left Column) */
        .stats-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .stats-section {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .stats-section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .stats-section-hint {
            font-size: 0.7rem;
            font-weight: normal;
            color: var(--text-muted);
            font-style: italic;
            margin-left: auto;
        }

        .stats-sliders {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .stats-slider-row {
            display: grid;
            grid-template-columns: 90px 1fr;
            align-items: center;
            gap: 0.5rem;
        }

        .stats-slider-name {
            font-size: 0.8rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .stats-slider-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stats-slider {
            -webkit-appearance: none;
            appearance: none;
            flex: 1;
            height: 8px;
            background: linear-gradient(to right, var(--bg-input) 0%, var(--bg-input) 100%);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.1s ease;
        }

        .stats-slider::-webkit-slider-runnable-track {
            height: 8px;
            background: var(--bg-input);
            border-radius: 4px;
        }

        .stats-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--node-attribute);
            border-radius: 50%;
            cursor: grab;
            margin-top: -5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }

        .stats-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 0 10px var(--node-attribute);
        }

        .stats-slider::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.2);
        }

        .stats-slider::-moz-range-track {
            height: 8px;
            background: var(--bg-input);
            border-radius: 4px;
        }

        .stats-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--node-attribute);
            border-radius: 50%;
            cursor: grab;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .stats-slider-var::-webkit-slider-thumb {
            background: var(--node-variable);
        }

        .stats-slider-var::-webkit-slider-thumb:hover {
            box-shadow: 0 0 10px var(--node-variable);
        }

        .stats-slider-var::-moz-range-thumb {
            background: var(--node-variable);
        }

        .stats-slider-input {
            width: 50px;
            padding: 0.3rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--accent-gold);
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .stats-slider-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .stats-slider-input::-webkit-inner-spin-button,
        .stats-slider-input::-webkit-outer-spin-button {
            opacity: 1;
        }

        /* Threshold Modifiers List */
        .threshold-modifiers-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        /* Modifiers List */
        .modifiers-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .mod-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.3rem 0.4rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border-left: 2px solid var(--border-color);
            transition: all 0.2s ease;
            opacity: 0.6;
        }

        .mod-item.active {
            background: rgba(225, 112, 145, 0.15);
            border-left-color: var(--node-modifier);
            opacity: 1;
        }

        .mod-item.forced {
            border-left-color: var(--accent-gold);
        }

        .mod-toggle-btn {
            width: 18px;
            height: 18px;
            padding: 0;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--bg-card);
            color: var(--text-muted);
            font-size: 0.65rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        .mod-toggle-btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .mod-toggle-btn.on {
            background: var(--node-modifier);
            border-color: var(--node-modifier);
            color: white;
        }

        .mod-name {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mod-threshold-badge {
            font-size: 0.55rem;
            color: var(--node-modifier);
            opacity: 0.8;
        }

        .mod-auto-badge,
        .mod-forced-badge,
        .mod-removed-badge {
            font-size: 0.5rem;
            padding: 0.1rem 0.25rem;
            border-radius: 2px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .mod-auto-badge {
            background: rgba(92, 184, 92, 0.2);
            color: var(--accent-success);
        }

        .mod-forced-badge {
            background: rgba(212, 175, 55, 0.2);
            color: var(--accent-gold);
        }

        .mod-removed-badge {
            background: rgba(150, 150, 150, 0.2);
            color: var(--text-muted);
        }

        .mod-item.triggered {
            border-left-color: var(--accent-success);
        }

        .mod-item.force-removed {
            opacity: 0.5;
            border-left-color: var(--text-muted);
            border-left-style: dashed;
        }

        .mod-name-link {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
        }

        .mod-name-link:hover {
            color: var(--accent-gold);
            text-decoration-style: solid;
        }

        /* Modifier hover tooltip */
        .mod-hover-tooltip {
            position: absolute;
            z-index: 1000;
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            padding: 0.5rem 0.6rem;
            min-width: 180px;
            max-width: 260px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            font-size: 0.7rem;
            pointer-events: auto;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .mod-hover-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .mod-tooltip-name {
            font-weight: 600;
            color: var(--node-modifier);
            margin-bottom: 0.3rem;
        }

        .mod-tooltip-desc {
            color: var(--text-secondary);
            font-size: 0.65rem;
            margin-bottom: 0.3rem;
            line-height: 1.3;
        }

        .mod-tooltip-trigger {
            font-size: 0.6rem;
            color: var(--text-muted);
            padding: 0.25rem 0.35rem;
            background: var(--bg-tertiary);
            border-radius: 3px;
            margin-bottom: 0.3rem;
        }

        .mod-tooltip-trigger .trigger-label {
            color: var(--accent-success);
            font-weight: 600;
        }

        .mod-tooltip-actions {
            display: flex;
            gap: 0.5rem;
            padding-top: 0.3rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.6rem;
        }

        /* Legacy threshold-mod styles for backwards compat */
        .threshold-mod-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.6rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border-left: 3px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .threshold-mod-item.active {
            background: rgba(225, 112, 145, 0.15);
            border-left-color: var(--node-modifier);
        }

        .threshold-mod-item.inactive {
            opacity: 0.6;
        }

        .threshold-mod-icon {
            font-size: 0.9rem;
        }

        .threshold-mod-name {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .threshold-mod-condition {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-left: auto;
        }

        /* Probabilities Panel (Right Column) */
        .probabilities-panel {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .probabilities-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .probabilities-hint {
            font-size: 0.7rem;
            font-weight: normal;
            color: var(--text-muted);
            font-style: italic;
            margin-left: auto;
        }

        .probabilities-layers {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .prob-layer {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 0.6rem;
            border: 1px solid var(--border-color);
        }

        .prob-layer-header {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .prob-layer-rolls {
            font-size: 0.7rem;
            font-weight: normal;
            color: var(--text-muted);
        }

        .prob-layer-traits {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .prob-trait-row.highlighted {
            background: rgba(212, 175, 55, 0.15) !important;
            box-shadow: inset 0 0 0 1px var(--accent-gold);
        }

        .prob-trait-name {
            font-size: 0.8rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .prob-trait-bar-wrap {
            height: 10px;
            background: var(--bg-input);
            border-radius: 5px;
            overflow: hidden;
        }

        .prob-trait-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--node-trait), var(--accent-gold));
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .prob-trait-bar.high {
            background: linear-gradient(90deg, var(--accent-gold), var(--accent-success));
        }

        .prob-trait-bar.low {
            background: var(--text-muted);
        }

        .prob-trait-pct {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .prob-trait-influences {
            display: flex;
            gap: 0.25rem;
        }

        .influence-chip {
            font-size: 0.65rem;
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            font-weight: 600;
        }

        .influence-chip.positive {
            background: rgba(111, 156, 93, 0.2);
            color: var(--accent-success);
        }

        .influence-chip.negative {
            background: rgba(224, 82, 82, 0.2);
            color: var(--accent-danger);
        }

        .more-count {
            font-size: 0.6rem;
            color: var(--text-muted);
            padding: 0.1rem 0.25rem;
        }

        /* Expandable Trait Item Styles */
        .prob-trait-item {
            border-radius: 4px;
            overflow: hidden;
            transition: background 0.2s ease;
        }

        .prob-trait-item.expanded {
            background: var(--bg-secondary);
            border: 1px solid var(--border-ornate);
        }

        .prob-trait-row {
            display: grid;
            grid-template-columns: 16px 80px 1fr 40px auto;
            align-items: center;
            gap: 0.4rem;
            padding: 0.4rem 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }

        .prob-trait-item.expanded .prob-trait-row {
            border-radius: 4px 4px 0 0;
            background: var(--bg-tertiary);
        }

        .prob-trait-row:hover {
            background: rgba(212, 175, 55, 0.1);
        }

        .prob-trait-expand {
            font-size: 0.6rem;
            color: var(--text-muted);
            transition: transform 0.2s ease;
        }

        .prob-trait-details {
            padding: 0.35rem 0.5rem 0.35rem 1.8rem;
            background: var(--bg-card);
            border-top: 1px solid var(--border-color);
            font-size: 0.7rem;
            margin-left: 16px;
        }

        .trait-detail-columns {
            display: flex;
            gap: 0.6rem;
        }

        .trait-detail-left {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .trait-detail-right {
            flex: 1;
            min-width: 0;
        }

        .trait-weight-row {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .trait-weight-label {
            color: var(--text-secondary);
            font-size: 0.65rem;
        }

        .trait-weight-input {
            width: 52px;
            padding: 0.15rem 0.25rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--accent-gold);
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
        }

        .trait-weight-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .trait-weight-delta {
            font-size: 0.7rem;
            font-weight: 600;
            padding: 0 0.15rem;
        }
        .trait-weight-delta.positive { color: #6db385; }
        .trait-weight-delta.negative { color: #e05252; }

        .trait-weight-arrow {
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .trait-weight-final {
            color: var(--accent-gold);
            font-size: 0.8rem;
            font-weight: 700;
        }

        .trait-actions-stacked {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .btn-mini {
            padding: 0.1rem 0.3rem;
            font-size: 0.55rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .btn-mini:hover {
            background: var(--bg-hover);
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .trait-influences-compact {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }

        .no-influences-compact {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .trait-gates-compact {
            margin-top: 0.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.1rem;
        }

        .gate-detail-compact {
            display: flex;
            align-items: center;
            gap: 0.2rem;
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .gate-detail-compact .gate-icon {
            font-size: 0.55rem;
        }

        .trait-influences-detail,
        .trait-gates-detail {
            margin-bottom: 0.5rem;
        }

        .influences-title,
        .gates-title {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.3rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .influence-detail,
        .gate-detail {
            display: flex;
            align-items: flex-start;
            gap: 0.25rem;
            padding: 0.15rem 0.3rem;
            margin-bottom: 0.15rem;
            background: var(--bg-tertiary);
            border-radius: 3px;
            font-size: 0.6rem;
            line-height: 1.25;
        }

        .influence-detail.positive {
            border-left: 2px solid var(--accent-success);
        }

        .influence-detail.negative {
            border-left: 2px solid var(--accent-danger);
        }

        .influence-detail.conditional {
            border-left: 2px solid var(--node-modifier);
        }

        .influence-detail-icon {
            font-size: 0.65rem;
            flex-shrink: 0;
        }

        .influence-detail-text {
            color: var(--text-secondary);
            font-size: 0.6rem;
        }

        .influence-detail-text .positive {
            color: var(--accent-success);
            font-weight: 600;
        }

        .influence-detail-text .negative {
            color: var(--accent-danger);
            font-weight: 600;
        }

        .influence-current {
            color: var(--text-muted);
            font-size: 0.55rem;
        }

        .influence-potential {
            color: var(--text-muted);
            font-size: 0.55rem;
            font-style: italic;
        }

        .influence-detail.modifier-active {
            border-left-color: var(--node-modifier);
            background: rgba(225, 112, 145, 0.1);
        }

        .gate-icon {
            font-size: 0.65rem;
        }

        .node-link {
            color: var(--accent-gold);
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 2px;
        }

        .node-link:hover {
            color: var(--accent-primary);
            text-decoration-style: solid;
        }

        .no-influences {
            font-size: 0.6rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.25rem;
            text-align: center;
        }

        /* Trait Hover Tooltip */
        .trait-hover-tooltip {
            position: absolute;
            z-index: 1000;
            background: var(--bg-card);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            padding: 0.5rem 0.6rem;
            min-width: 200px;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            font-size: 0.7rem;
            pointer-events: auto;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }

        .trait-hover-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip-weight-line {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.4rem;
            padding-bottom: 0.35rem;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .tooltip-weight-value {
            color: var(--accent-gold);
            font-weight: 600;
        }

        .tooltip-influences {
            margin-bottom: 0.4rem;
        }

        .tooltip-influence-row {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.2rem 0;
            font-size: 0.65rem;
            line-height: 1.3;
        }

        .tooltip-influence-row .inf-icon {
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        .tooltip-influence-row.positive {
            color: var(--accent-success);
        }

        .tooltip-influence-row.negative {
            color: var(--accent-danger);
        }

        .tooltip-influence-row .node-link {
            font-size: 0.65rem;
        }

        .tooltip-actions {
            display: flex;
            gap: 0.5rem;
            padding-top: 0.35rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.6rem;
        }

        .tooltip-action-link {
            color: var(--accent-gold);
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .tooltip-action-link:hover {
            color: var(--accent-primary);
            text-decoration-style: solid;
        }

        .tooltip-no-influences {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Highlight flash animation for tree items */
        .tree-item.highlight-flash {
            animation: highlight-flash 1s ease;
        }

        @keyframes highlight-flash {
            0%, 100% { background: transparent; }
            50% { background: rgba(212, 175, 55, 0.3); }
        }

        /* Legacy styles kept for backwards compatibility */
        .preview-section {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .preview-section-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .preview-section-hint {
            font-size: 0.7rem;
            font-weight: normal;
            color: var(--text-muted);
            font-style: italic;
            margin-left: auto;
        }

        .preview-sliders {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .preview-slider-row {
            display: grid;
            grid-template-columns: 100px 1fr 40px;
            align-items: center;
            gap: 0.75rem;
        }

        .preview-slider-name {
            font-size: 0.8rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .preview-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            cursor: pointer;
        }

        .preview-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--node-attribute);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }

        .preview-slider-row[data-var-id] .preview-slider::-webkit-slider-thumb {
            background: var(--node-variable);
        }

        .preview-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 8px rgba(var(--node-attribute-rgb, 111, 156, 93), 0.5);
        }

        .preview-slider::-webkit-slider-thumb:active {
            transform: scale(1.3);
        }

        .preview-slider-value {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-gold);
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .preview-slider-row.active-influence {
            background: rgba(var(--accent-gold-rgb, 212, 175, 55), 0.1);
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            margin: -0.25rem -0.5rem;
        }

        /* Probability layers */
        .preview-probability-layers {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .preview-layer {
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 0.5rem;
        }

        .preview-layer-header {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .preview-layer-rolls {
            font-size: 0.7rem;
            font-weight: normal;
            color: var(--text-muted);
        }

        .preview-layer-traits {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .preview-trait-row {
            display: grid;
            grid-template-columns: 100px 1fr 45px auto;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-secondary);
            border-radius: 4px;
            transition: background 0.2s ease, box-shadow 0.2s ease;
        }

        .preview-trait-row.highlighted {
            background: rgba(var(--accent-gold-rgb, 212, 175, 55), 0.15);
            box-shadow: inset 0 0 0 1px var(--accent-gold);
        }

        .preview-trait-row.pulsing {
            animation: pulse-influence 0.5s ease;
        }

        .preview-trait-name {
            font-size: 0.8rem;
            color: var(--text-primary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .preview-trait-bar-container {
            height: 8px;
            background: var(--bg-input);
            border-radius: 4px;
            overflow: hidden;
        }

        .preview-trait-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--node-trait), var(--accent-gold));
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .preview-trait-bar.high {
            background: linear-gradient(90deg, var(--accent-gold), var(--accent-success));
        }

        .preview-trait-bar.low {
            background: var(--text-muted);
        }

        .preview-trait-pct {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .preview-trait-influence {
            font-size: 0.65rem;
            color: var(--text-muted);
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Threshold modifiers */
        .preview-triggered-mods {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .preview-mod-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.35rem 0.6rem;
            background: rgba(var(--node-modifier-rgb, 225, 112, 145), 0.2);
            border: 1px solid var(--node-modifier);
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--node-modifier);
        }

        .preview-mod-condition {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        /* Cascade chain visualization */
        .cascade-chain {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            padding: 0.5rem;
            background: var(--bg-input);
            border-radius: 4px;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .cascade-chain .chain-step {
            display: flex;
            align-items: center;
            gap: 0.2rem;
        }

        .cascade-chain .chain-arrow {
            color: var(--node-weight-influence);
        }

        .cascade-chain .chain-node {
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            font-weight: 500;
        }

        .cascade-chain .chain-node.attr {
            background: rgba(109, 179, 133, 0.2);
            color: var(--node-attribute);
        }

        .cascade-chain .chain-node.trait {
            background: rgba(139, 107, 184, 0.2);
            color: var(--node-trait);
        }

        .cascade-chain .chain-node.effect {
            background: rgba(168, 123, 201, 0.2);
            color: var(--node-weight-influence);
        }

        /* Active influence highlight in simulator */
        .simulator-attribute.active-influence .simulator-attribute-name {
            color: var(--node-weight-influence);
        }

        .simulator-attribute.active-influence .simulator-attribute-slider::-webkit-slider-thumb {
            background: var(--node-weight-influence);
            box-shadow: 0 0 8px var(--node-weight-influence);
        }

        /* Batch Spawn Controls */
        .batch-spawn-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid var(--border-color);
            margin-top: 0.5rem;
        }

        .batch-spawn-input {
            width: 60px;
            padding: 0.3rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.8rem;
            text-align: center;
        }

        .batch-spawn-label {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Spawn Constraints */
        .spawn-constraints-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .spawn-constraints-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
        }

        .spawn-constraints-header:hover {
            background: var(--bg-hover);
        }

        .spawn-constraints-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .spawn-constraints-count {
            font-size: 0.7rem;
            padding: 0.1rem 0.35rem;
            background: var(--accent-primary);
            color: white;
            border-radius: 3px;
        }

        .spawn-constraints-toggle {
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .spawn-constraints-content {
            padding: 0.75rem;
            display: none;
        }

        .spawn-constraints-panel.expanded .spawn-constraints-content {
            display: block;
        }

        .spawn-constraints-panel.expanded .spawn-constraints-toggle {
            transform: rotate(180deg);
        }

        .constraints-section {
            margin-bottom: 0.75rem;
        }

        .constraints-section:last-child {
            margin-bottom: 0;
        }

        .constraints-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.35rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .constraints-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            margin-bottom: 0.5rem;
        }

        .constraint-tag {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.75rem;
        }

        .constraint-tag.must-have {
            background: rgba(74, 124, 89, 0.2);
            border: 1px solid var(--accent-success);
            color: var(--accent-success);
        }

        .constraint-tag.exclude {
            background: rgba(167, 80, 84, 0.2);
            border: 1px solid var(--accent-danger);
            color: var(--accent-danger);
        }

        .constraint-tag .remove-constraint {
            cursor: pointer;
            opacity: 0.6;
            margin-left: 0.15rem;
        }

        .constraint-tag .remove-constraint:hover {
            opacity: 1;
        }

        .constraint-add-row {
            display: flex;
            gap: 0.35rem;
            align-items: center;
        }

        .constraint-select {
            flex: 1;
            padding: 0.3rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.75rem;
        }

        .constraint-add-btn {
            font-size: 0.7rem;
            padding: 0.3rem 0.5rem;
        }

        .preview-content {
            display: flex;
            gap: 1rem;
            flex: 1;
            overflow: hidden;
        }

        .preview-entities {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            overflow-y: auto;
            padding-right: 0.5rem;
        }

        .preview-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
        }

        .preview-entity {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.75rem;
            transition: all 0.2s ease;
        }

        .preview-entity.newest {
            border-color: var(--accent-secondary);
            box-shadow: 0 0 10px var(--glow-copper);
        }

        .preview-entity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .preview-entity-id {
            font-weight: 600;
            color: var(--accent-highlight);
            font-size: 0.85rem;
        }

        .preview-entity-name-input {
            font-weight: 600;
            color: var(--accent-highlight);
            font-size: 0.85rem;
            background: transparent;
            border: none;
            border-bottom: 1px solid transparent;
            padding: 0.15rem 0.25rem;
            margin: -0.15rem 0;
            flex: 1;
            min-width: 80px;
            max-width: 200px;
        }

        .preview-entity-name-input:hover {
            border-bottom-color: var(--border-color);
        }

        .preview-entity-name-input:focus {
            outline: none;
            border-bottom-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        .preview-entity-time {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .preview-section {
            margin-bottom: 0.5rem;
        }

        .preview-section:last-child {
            margin-bottom: 0;
        }

        .preview-section-title {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.35rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .preview-section-title .add-btn-inline {
            font-size: 0.6rem;
            padding: 0.1rem 0.25rem;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.15s ease;
        }

        .preview-section-title .add-btn-inline:hover {
            opacity: 1;
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .preview-section-title .add-btn-inline.modifier-btn:hover {
            border-color: var(--node-modifier);
            color: var(--node-modifier);
        }

        .preview-section-title .add-btn-inline.compound-btn:hover {
            border-color: var(--node-compound);
            color: var(--node-compound);
        }

        .preview-attributes {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .preview-attr {
            display: grid;
            grid-template-columns: auto auto 1fr;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
        }

        .attr-name {
            color: var(--node-attribute);
        }

        .attr-value {
            font-weight: 600;
            color: var(--text-light);
            min-width: 20px;
            text-align: right;
        }

        .attr-bar {
            height: 4px;
            background: var(--bg-input);
            border-radius: 2px;
            overflow: hidden;
        }

        .attr-bar-fill {
            height: 100%;
            background: var(--node-attribute);
            border-radius: 2px;
        }

        .preview-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .preview-trait {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.5rem;
            background: var(--bg-medium);
            border: 1px solid var(--node-layer);
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .trait-name {
            color: var(--text-light);
            font-weight: 500;
        }

        .trait-layer {
            color: var(--text-muted);
            font-size: 0.65rem;
        }

        .trait-chance {
            color: var(--node-variable);
            font-size: 0.65rem;
            font-weight: 600;
        }

        .preview-compounds {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .preview-compound {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.5rem;
            background: rgba(165, 67, 67, 0.2);
            border: 1px solid var(--node-compound);
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .compound-name {
            color: var(--node-compound);
            font-weight: 600;
        }

        .compound-requires {
            color: var(--text-muted);
            font-size: 0.65rem;
        }

        /* Compound editing UI */
        .compound-requires-list {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            max-height: 150px;
            overflow-y: auto;
            padding: 0.5rem;
            background: var(--bg-input);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
        }

        .compound-require-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-card);
            border-radius: 3px;
            font-size: 0.8rem;
        }

        .compound-require-item .delete-btn {
            margin-left: auto;
            opacity: 0.5;
            font-size: 0.7rem;
            padding: 0.15rem 0.35rem;
            background: transparent;
            color: var(--accent-danger);
            border: none;
            cursor: pointer;
        }

        .compound-require-item:hover .delete-btn {
            opacity: 1;
        }

        .compound-require-item .threshold-badge {
            color: var(--accent-warning);
            font-size: 0.75rem;
        }

        .compound-add-require {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .compound-add-require select {
            flex: 1;
        }

        .compound-requires-list .empty-hint {
            color: var(--text-muted);
            font-size: 0.75rem;
            font-style: italic;
            padding: 0.25rem;
        }

        /* Incompatibility UI */
        .incompatibility-list {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            max-height: 120px;
            overflow-y: auto;
            padding: 0.5rem;
            background: var(--bg-input);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
        }

        .incompat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-card);
            border-radius: 3px;
            font-size: 0.8rem;
            border-left: 2px solid var(--accent-danger);
        }

        .incompat-icon {
            color: var(--accent-danger);
            font-size: 0.9rem;
        }

        .incompat-layer {
            font-size: 0.65rem;
            color: var(--text-muted);
            background: rgba(200, 160, 100, 0.1);
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
        }

        .incompat-sync-badge {
            font-size: 0.7rem;
            color: var(--accent-secondary);
            background: rgba(200, 160, 100, 0.15);
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
            margin-left: auto;
        }

        .incompat-item .delete-btn {
            opacity: 0.5;
            font-size: 0.7rem;
            padding: 0.15rem 0.35rem;
            background: transparent;
            color: var(--accent-danger);
            border: none;
            cursor: pointer;
        }

        .incompat-item:hover .delete-btn {
            opacity: 1;
        }

        .incompat-add {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .incompat-add select {
            flex: 1;
        }

        .incompatibility-list .empty-hint {
            color: var(--text-muted);
            font-size: 0.75rem;
            font-style: italic;
            padding: 0.25rem;
        }

        /* Quick Weight Influence UI */
        .weight-influence-quick {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .weight-influence-quick select {
            flex: 1;
        }

        .influence-buttons {
            display: flex;
            gap: 0.25rem;
        }

        .btn-influence-pos {
            background: rgba(100, 180, 100, 0.2);
            color: #8fc98f;
            border: 1px solid rgba(100, 180, 100, 0.3);
        }

        .btn-influence-pos:hover {
            background: rgba(100, 180, 100, 0.35);
            border-color: rgba(100, 180, 100, 0.5);
        }

        .btn-influence-neg {
            background: rgba(180, 100, 100, 0.2);
            color: #c98f8f;
            border: 1px solid rgba(180, 100, 100, 0.3);
        }

        .btn-influence-neg:hover {
            background: rgba(180, 100, 100, 0.35);
            border-color: rgba(180, 100, 100, 0.5);
        }

        .influence-note {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Action Node UI */
        .action-costs-list,
        .action-requirements-list,
        .action-blockedby-list {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
            max-height: 120px;
            overflow-y: auto;
            padding: 0.5rem;
            background: var(--bg-input);
            border-radius: 4px;
            border: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
        }

        .action-cost-item,
        .action-requirement-item,
        .action-blockedby-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0.5rem;
            background: var(--bg-card);
            border-radius: 3px;
            font-size: 0.8rem;
        }

        .action-cost-item {
            border-left: 2px solid var(--node-action);
        }

        .action-requirement-item {
            border-left: 2px solid var(--accent-success);
        }

        .action-blockedby-item {
            border-left: 2px solid var(--accent-danger);
        }

        .cost-var-name {
            flex: 1;
        }

        .cost-value-input {
            width: 60px;
            padding: 0.2rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.75rem;
            text-align: center;
        }

        .cost-value-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .action-cost-item .delete-btn,
        .action-requirement-item .delete-btn,
        .action-blockedby-item .delete-btn {
            margin-left: auto;
            opacity: 0.5;
            font-size: 0.7rem;
            padding: 0.15rem 0.35rem;
            background: transparent;
            color: var(--accent-danger);
            border: none;
            cursor: pointer;
        }

        .action-cost-item:hover .delete-btn,
        .action-requirement-item:hover .delete-btn,
        .action-blockedby-item:hover .delete-btn {
            opacity: 1;
        }

        .action-cost-add,
        .action-requirement-add,
        .action-blockedby-add {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .action-cost-add select,
        .action-requirement-add select,
        .action-blockedby-add select {
            flex: 1;
        }

        .action-costs-list .empty-hint,
        .action-requirements-list .empty-hint,
        .action-blockedby-list .empty-hint {
            color: var(--text-muted);
            font-size: 0.75rem;
            font-style: italic;
            padding: 0.25rem;
        }

        .effects-json-input {
            width: 100%;
            min-height: 80px;
            padding: 0.5rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.75rem;
            resize: vertical;
        }

        .effects-json-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .effects-note {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
            margin-top: 0.25rem;
        }

        /* Interactive preview styles */
        .attr-value-input, .var-value-input {
            width: 50px;
            padding: 0.2rem 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.75rem;
            text-align: center;
        }

        .attr-value-input:focus, .var-value-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .attr-value-input:hover, .var-value-input:hover {
            border-color: var(--accent-secondary);
        }

        .preview-trait {
            cursor: pointer;
            transition: opacity 0.2s ease, background 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .preview-trait.inactive {
            opacity: 0.4;
        }

        .preview-trait.inactive .trait-name {
            text-decoration: line-through;
        }

        .preview-trait:hover {
            background: var(--bg-hover);
        }

        .trait-toggle {
            font-size: 0.6rem;
            color: var(--accent-success);
            width: 0.8rem;
            text-align: center;
        }

        .preview-trait.inactive .trait-toggle {
            color: var(--text-muted);
        }

        .preview-trait.threshold-trait {
            border-left: 2px solid var(--accent-warning);
            padding-left: 0.25rem;
        }

        .trait-type {
            font-size: 0.6rem;
            color: var(--accent-warning);
        }

        .add-trait-btn {
            font-size: 0.75rem !important;
            padding: 0.1rem 0.4rem !important;
            margin-left: auto;
            background: var(--bg-card) !important;
            border: 1px solid var(--border-color) !important;
        }

        .add-trait-btn:hover {
            background: var(--accent-primary) !important;
            color: white !important;
        }

        /* Add Trait Dropdown Menu */
        .add-trait-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            z-index: 1000;
            min-width: 220px;
            max-height: 350px;
            overflow-y: auto;
        }

        .add-trait-menu-header {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--accent-secondary);
            font-weight: 600;
            position: sticky;
            top: 0;
            background: var(--bg-panel);
        }

        .add-trait-layer-group {
            padding: 0.25rem 0;
        }

        .add-trait-layer-title {
            padding: 0.35rem 0.75rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: var(--bg-card);
        }

        .add-trait-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.15s ease;
        }

        .add-trait-item:hover:not(.disabled) {
            background: var(--bg-hover);
        }

        .add-trait-item.disabled {
            opacity: 0.35;
            cursor: not-allowed;
        }

        .add-trait-item.already-active {
            color: var(--accent-success);
        }

        .add-trait-item .trait-status {
            font-size: 0.6rem;
            margin-left: auto;
            color: var(--text-muted);
        }

        .add-trait-item.disabled .trait-status {
            color: var(--accent-danger);
        }

        /* Add Modifier Dropdown Menu (reuses trait menu pattern) */
        .add-modifier-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            z-index: 1000;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
        }

        .add-modifier-menu-header {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--node-modifier);
            font-weight: 600;
            position: sticky;
            top: 0;
            background: var(--bg-panel);
        }

        .add-modifier-category {
            padding: 0.25rem 0;
        }

        .add-modifier-category-title {
            padding: 0.35rem 0.75rem;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .add-modifier-category-title .cat-icon {
            font-size: 0.7rem;
        }

        .add-modifier-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.15s ease;
        }

        .add-modifier-item:hover:not(.disabled):not(.already-active) {
            background: var(--bg-hover);
        }

        .add-modifier-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .add-modifier-item.already-active {
            color: var(--node-modifier);
            cursor: default;
        }

        .add-modifier-item.threshold {
            border-left: 2px solid var(--accent-gold);
        }

        .add-modifier-item .mod-icon {
            font-size: 0.75rem;
            width: 1rem;
            text-align: center;
        }

        .add-modifier-item .mod-name {
            flex: 1;
        }

        .add-modifier-item .mod-status {
            font-size: 0.6rem;
            margin-left: auto;
            color: var(--text-muted);
        }

        .add-modifier-item.disabled .mod-status {
            color: var(--accent-danger);
        }

        .add-modifier-item.threshold .mod-status {
            color: var(--accent-gold);
        }

        .add-modifier-item .mod-trigger {
            font-size: 0.6rem;
            color: var(--accent-gold);
            display: block;
        }

        .add-modifier-item .force-btn {
            font-size: 0.6rem;
            padding: 0.15rem 0.35rem;
            background: rgba(218, 165, 32, 0.2);
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            border-radius: 3px;
            cursor: pointer;
            margin-left: 0.25rem;
        }

        .add-modifier-item .force-btn:hover {
            background: var(--accent-gold);
            color: var(--bg-dark);
        }

        .add-modifier-empty {
            padding: 1rem 0.75rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
        }

        /* Add Trait Dropdown Menu */
        .add-trait-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            z-index: 1000;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
        }

        .add-trait-menu-header {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--node-trait);
            font-weight: 600;
            position: sticky;
            top: 0;
            background: var(--bg-panel);
        }

        .add-trait-category {
            padding: 0.25rem 0;
        }

        .add-trait-category-title {
            padding: 0.35rem 0.75rem;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .add-trait-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: background 0.15s ease;
        }

        .add-trait-item:hover:not(.already-active) {
            background: var(--bg-hover);
        }

        .add-trait-item.already-active {
            color: var(--node-trait);
            cursor: default;
        }

        .add-trait-item.threshold {
            border-left: 2px solid var(--accent-gold);
        }

        .add-trait-item .trait-icon {
            font-size: 0.75rem;
            width: 1rem;
            text-align: center;
            color: var(--node-trait);
        }

        .add-trait-item .trait-name {
            flex: 1;
        }

        .add-trait-item .trait-status {
            font-size: 0.6rem;
            margin-left: auto;
            color: var(--text-muted);
        }

        .add-trait-item .trait-trigger {
            font-size: 0.6rem;
            color: var(--accent-gold);
        }

        /* Trait button styling */
        .add-btn-inline.trait-btn {
            background: rgba(140, 120, 180, 0.2);
            border-color: var(--node-trait);
            color: var(--node-trait);
        }

        .add-btn-inline.trait-btn:hover {
            background: var(--node-trait);
            color: var(--bg-dark);
        }

        /* No items message */
        .no-items-msg {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem 0;
        }

        /* Add Compound Dropdown Menu */
        .add-compound-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-ornate);
            border-radius: 6px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            z-index: 1000;
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        .add-compound-menu-header {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--node-compound);
            font-weight: 600;
            position: sticky;
            top: 0;
            background: var(--bg-panel);
        }

        .add-compound-category {
            padding: 0.25rem 0;
        }

        .add-compound-category-title {
            padding: 0.35rem 0.75rem;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: var(--bg-card);
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .add-compound-item {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.15s ease;
        }

        .add-compound-item:hover:not(.disabled):not(.already-active) {
            background: var(--bg-hover);
        }

        .add-compound-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .add-compound-item.already-active {
            color: var(--node-compound);
            cursor: default;
        }

        .add-compound-item.ready {
            border-left: 2px solid var(--accent-success);
        }

        .add-compound-item-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .add-compound-item .cmp-icon {
            font-size: 0.75rem;
            width: 1rem;
            text-align: center;
        }

        .add-compound-item .cmp-name {
            flex: 1;
        }

        .add-compound-item .cmp-status {
            font-size: 0.6rem;
            margin-left: auto;
            color: var(--text-muted);
        }

        .add-compound-item.ready .cmp-status {
            color: var(--accent-success);
        }

        .add-compound-item .cmp-reqs {
            display: flex;
            flex-wrap: wrap;
            gap: 0.2rem;
            margin-top: 0.3rem;
            padding-left: 1.5rem;
        }

        .add-compound-item .cmp-req {
            font-size: 0.6rem;
            padding: 0.1rem 0.25rem;
            border-radius: 2px;
            background: var(--bg-input);
        }

        .add-compound-item .cmp-req.met {
            color: var(--accent-success);
            background: rgba(74, 124, 89, 0.2);
        }

        .add-compound-item .cmp-req.unmet {
            color: var(--text-muted);
        }

        .add-compound-item .force-btn {
            font-size: 0.6rem;
            padding: 0.15rem 0.35rem;
            background: rgba(165, 67, 67, 0.2);
            border: 1px solid var(--node-compound);
            color: var(--node-compound);
            border-radius: 3px;
            cursor: pointer;
            margin-left: 0.25rem;
        }

        .add-compound-item .force-btn:hover {
            background: var(--node-compound);
            color: white;
        }

        .add-compound-empty {
            padding: 1rem 0.75rem;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
        }

        .edit-hint {
            font-size: 0.65rem;
            font-weight: normal;
            color: var(--text-muted);
            font-style: italic;
        }

        .derived-breakdown {
            display: block;
            font-size: 0.6rem;
            color: var(--text-muted);
            font-family: monospace;
            margin-top: 0.1rem;
        }

        .preview-var.derived {
            flex-direction: column;
            align-items: flex-start;
        }

        .preview-variables, .preview-derived {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .preview-var {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.75rem;
        }

        .preview-var .var-name {
            color: var(--node-variable);
        }

        .preview-var .var-value {
            color: var(--text-light);
            font-weight: 600;
        }

        .preview-var.derived .var-name {
            color: var(--node-derived);
        }

        /* Analysis Panel */
        .preview-analysis {
            width: 280px;
            flex-shrink: 0;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
            overflow-y: auto;
        }

        .analysis-hint {
            color: var(--text-muted);
            font-style: italic;
            font-size: 0.8rem;
            text-align: center;
            padding: 1rem;
        }

        .analysis-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .analysis-title {
            font-weight: 600;
            color: var(--text-light);
            font-size: 0.85rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .analysis-group {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .analysis-group-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .analysis-row {
            display: grid;
            grid-template-columns: 1fr auto 50px;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .analysis-label {
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .analysis-value {
            color: var(--text-light);
            font-weight: 600;
            text-align: right;
        }

        .analysis-bar {
            height: 4px;
            background: var(--bg-input);
            border-radius: 2px;
            overflow: hidden;
        }

        .analysis-bar-fill {
            height: 100%;
            background: var(--accent-primary);
            border-radius: 2px;
        }

        /* ========================================
           PERSISTENCE VIEW (v3.3 â€” replaces Entities)
           ======================================== */

        .persistence-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .persistence-sections {
            display: flex;
            gap: 0;
            border-bottom: 2px solid var(--border-color);
            flex-shrink: 0;
            background: var(--bg-secondary);
        }

        .persistence-section-tab {
            padding: 0.6rem 1.2rem;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
            position: relative;
            transition: color 0.15s;
            font-family: 'Raleway', sans-serif;
        }

        .persistence-section-tab:hover {
            color: var(--text-primary);
        }

        .persistence-section-tab.active {
            color: var(--accent-copper);
        }

        .persistence-section-tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-copper);
        }

        .tab-badge-sm {
            font-size: 0.65rem;
            background: rgba(167, 141, 182, 0.15);
            color: var(--accent-copper);
            padding: 0.1rem 0.35rem;
            border-radius: 8px;
            margin-left: 0.3rem;
        }

        .persistence-section-hint {
            font-size: 0.7rem;
            color: var(--text-muted);
            padding: 0.35rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            font-style: italic;
        }

        .persistence-content {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        /* Persistence: Pools Section */
        .persistence-pools-content {
            padding: 1rem;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .pools-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
        }

        .pools-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            font-family: 'Raleway', sans-serif;
        }

        .pools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1rem;
        }

        .pools-explainer {
            font-size: 0.75rem;
            color: var(--text-muted);
            padding: 0.6rem 0.75rem;
            background: var(--bg-card);
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .pools-explainer strong {
            color: var(--text-primary);
        }

        /* Persistence: Saved Entities Section */
        .persistence-saved-content {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .saved-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.6rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .saved-entity-detail {
            display: flex;
            flex-direction: column;
            gap: 0;
            overflow-y: auto;
        }

        .saved-entity-detail .entity-detail-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .saved-entity-detail .entity-state-input,
        .saved-entity-detail .entity-state-output {
            border: none;
            border-radius: 0;
            padding: 0.5rem;
        }

        /* Preset Group Tree â€” matches node tree design */
        .pg-tree-folder {
            margin-bottom: 0.1rem;
        }

        .pg-tree-folder-header {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.35rem 0.5rem;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.8rem;
            transition: all 0.15s ease;
            background: var(--bg-card);
        }

        .pg-tree-folder-header:hover {
            background: var(--bg-hover);
            color: var(--accent-highlight);
        }

        .pg-tree-folder-header.selected {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border: 1px solid var(--accent-secondary);
        }

        .pg-tree-children {
            padding-left: 0.75rem;
            margin-left: 0.35rem;
            border-left: 1px solid var(--border-color);
        }

        .pg-tree-item {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.35rem 0.5rem;
            cursor: pointer;
            border-radius: 3px;
            font-size: 0.8rem;
            transition: all 0.15s ease;
        }

        .pg-tree-item:hover {
            background: var(--bg-hover);
            color: var(--accent-highlight);
        }

        .pg-tree-item.selected {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            border: 1px solid var(--accent-secondary);
        }

        .pg-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .pg-tree-toggle {
            font-size: 0.6rem;
            color: var(--text-muted);
            width: 10px;
            text-align: center;
            flex-shrink: 0;
            cursor: pointer;
            transition: color 0.15s;
        }

        .pg-tree-toggle:hover {
            color: var(--accent-highlight);
        }

        .pg-tree-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .pg-tree-count {
            font-size: 0.65rem;
            color: var(--text-muted);
            background: var(--bg-input);
            padding: 0.1rem 0.35rem;
            border-radius: 6px;
            flex-shrink: 0;
        }

        .pg-tree-add {
            font-size: 0.7rem;
            color: var(--text-muted);
            background: transparent;
            border: 1px solid transparent;
            padding: 0.1rem 0.25rem;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.45;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        .pg-tree-remove {
            font-size: 0.65rem;
            color: var(--text-muted);
            background: transparent;
            border: 1px solid transparent;
            padding: 0.1rem 0.2rem;
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.45;
            transition: all 0.15s ease;
            flex-shrink: 0;
            line-height: 1;
        }

        /* Hover on row â€” brighten both buttons */
        .pg-tree-item:hover .pg-tree-add,
        .pg-tree-item:hover .pg-tree-remove,
        .pg-tree-folder-header:hover .pg-tree-add,
        .pg-tree-folder-header:hover .pg-tree-remove {
            opacity: 0.75;
        }

        /* Selected row â€” use lighter color that works on the lavender highlight */
        .pg-tree-item.selected .pg-tree-add,
        .pg-tree-item.selected .pg-tree-remove,
        .pg-tree-folder-header.selected .pg-tree-add,
        .pg-tree-folder-header.selected .pg-tree-remove {
            opacity: 0.8;
            color: var(--bg-panel, #1a1a2e);
        }

        .pg-tree-add:hover {
            opacity: 1 !important;
            color: var(--accent-highlight);
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }

        /* Selected row + hover: keep dark text on light bg */
        .pg-tree-item.selected .pg-tree-add:hover,
        .pg-tree-folder-header.selected .pg-tree-add:hover {
            color: var(--bg-dark, #111);
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.3);
        }

        .pg-tree-remove:hover {
            opacity: 1 !important;
            color: var(--accent-danger, #c75050);
            background: rgba(199, 80, 80, 0.1);
            border-color: var(--accent-danger, #c75050);
        }

        .pg-tree-item.selected .pg-tree-remove:hover,
        .pg-tree-folder-header.selected .pg-tree-remove:hover {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.15);
            border-color: rgba(255, 107, 107, 0.3);
        }

        /* Drag & drop states for preset groups */
        .pg-tree-item.dragging,
        .pg-tree-folder-header.dragging {
            opacity: 0.4;
        }

        .pg-tree-item.drag-over,
        .pg-tree-folder-header.drag-over {
            background: rgba(167, 141, 182, 0.2);
            outline: 1px dashed var(--copper);
            outline-offset: -1px;
        }

        .preset-card-compact.dragging {
            opacity: 0.4;
        }

        .preset-card-compact.drag-over {
            outline: 1px dashed var(--copper);
        }

        .pg-tree-item.drag-over-root {
            border-bottom: 2px solid var(--copper);
        }

        /* Root drop zone â€” hidden by default, visible during drag */
        .pg-root-drop-zone {
            display: none;
            margin: 0.25rem 0.15rem;
            padding: 0.4rem;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-align: center;
            transition: all 0.15s ease;
        }

        .pg-root-drop-zone.visible {
            display: block;
        }

        .pg-root-drop-zone.drag-over {
            background: rgba(167, 141, 182, 0.15);
            border-color: var(--copper);
            color: var(--copper);
        }

        /* Preset Override Rows */
        .preset-overrides-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .preset-override-row {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.25rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-secondary);
            opacity: 0.6;
            transition: opacity 0.15s;
        }

        .preset-override-row.active {
            opacity: 1;
            background: rgba(167, 141, 182, 0.08);
        }

        .preset-override-check {
            flex-shrink: 0;
        }

        .preset-override-check input[type="checkbox"] {
            margin: 0;
        }

        .preset-override-name {
            font-size: 0.75rem;
            color: var(--text-primary);
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .preset-override-value {
            width: 60px;
            padding: 0.15rem 0.3rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            font-size: 0.75rem;
            text-align: center;
        }

        .preset-override-value:disabled {
            opacity: 0.4;
        }

        .preset-override-hint {
            font-size: 0.6rem;
            color: var(--text-muted);
            opacity: 0.7;
            white-space: nowrap;
            min-width: 0;
        }

        .preset-override-row.active .preset-override-hint {
            display: none;
        }

        /* Test in Sim Button */
        .btn-test-sim {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .entity-status.preview {
            background: var(--accent-copper);
            opacity: 0.5;
        }

        /* ========================================
           ENTITIES VIEW (Entity Manager) â€” LEGACY
           ======================================== */
        .entities-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 1rem;
            gap: 1rem;
        }

        .entities-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: wrap;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        /* v3.3 Session 4: .entities-quick-preview and .quick-preview-* CSS deleted */

        .btn-xs {
            padding: 0.15rem 0.35rem;
            font-size: 0.65rem;
        }

        /* v3.3 Session 4: remaining .quick-preview-* CSS deleted */

        /* v3.3 Session 4: .entities-subtab* and .subtab-* CSS deleted */

        /* Entities Presets Sub-tab Content */
        .entities-presets-content {
            display: flex;
            gap: 0.75rem;
            flex: 1;
            min-height: 0;
        }

        .presets-sidebar {
            width: 180px;
            flex-shrink: 0;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .presets-sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .presets-sidebar-header .folder-add-btn {
            opacity: 0.6;
        }

        .preset-groups-list {
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            padding: 0.25rem;
        }

        /* v3.3 Session 4: duplicate .preset-group-item CSS deleted */

        .presets-main {
            flex: 1;
            min-width: 0;
            min-height: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .presets-main-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--copper);
        }

        .presets-grid-compact {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 0.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .presets-empty {
            grid-column: 1 / -1;
            text-align: center;
            padding: 2rem;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .preset-card-compact {
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .preset-card-compact:hover {
            border-color: var(--border-ornate);
        }

        .preset-card-compact.selected {
            border-color: var(--copper);
            background: var(--bg-card);
        }

        .preset-card-name {
            font-weight: 600;
            font-size: 0.8rem;
            color: var(--text-light);
            margin-bottom: 0.25rem;
        }

        .preset-card-traits {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .preset-card-actions {
            display: flex;
            gap: 0.25rem;
        }

        .presets-detail {
            width: 250px;
            flex-shrink: 0;
            min-height: 0;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow-y: auto;
        }

        .presets-detail-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            font-size: 0.8rem;
            gap: 0.5rem;
        }

        .presets-detail-empty .empty-icon {
            font-size: 1.5rem;
            opacity: 0.5;
        }

        .group-editor-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .group-editor-icon {
            font-size: 1.1rem;
        }

        .group-editor-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--copper);
        }

        .group-editor-stats {
            margin-top: 0.75rem;
            padding: 0.5rem;
            background: var(--bg-darker, rgba(0,0,0,0.15));
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .group-stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.2rem 0;
            color: var(--text-muted);
        }

        .group-stat-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .group-editor-actions {
            margin-top: 0.75rem;
            display: flex;
            justify-content: flex-end;
        }

        .preset-detail-select,
        .preset-detail-field select {
            width: 100%;
            padding: 0.4rem 0.6rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .quick-group-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .quick-group-popup {
            background: var(--bg-panel);
            border: 1px solid var(--copper);
            border-radius: 8px;
            padding: 1rem;
            width: 280px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
        }

        .quick-group-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--copper);
            margin-bottom: 0.75rem;
            font-family: 'Raleway', sans-serif;
        }

        .quick-group-popup .preset-detail-field {
            margin-bottom: 0.6rem;
        }

        .quick-group-popup select {
            width: 100%;
            padding: 0.4rem 0.6rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .quick-group-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.4rem;
            margin-top: 0.75rem;
        }

        .preset-detail-textarea {
            width: 100%;
            padding: 0.4rem 0.6rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.8rem;
            resize: vertical;
            font-family: inherit;
        }

        .preset-detail-compact {
            padding: 0.75rem;
        }

        .preset-detail-header {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .preset-name-input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-weight: 600;
        }

        .preset-detail-field {
            margin-bottom: 0.75rem;
        }

        .preset-detail-field label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
            text-transform: uppercase;
        }

        .preset-detail-field textarea {
            width: 100%;
            min-height: 60px;
            padding: 0.4rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75rem;
            resize: vertical;
        }

        .preset-forced-traits {
            max-height: 150px;
            overflow-y: auto;
            background: var(--bg-input);
            border-radius: 4px;
            padding: 0.5rem;
        }

        .preset-trait-checkbox {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.75rem;
            padding: 0.2rem 0;
            cursor: pointer;
        }

        .preset-trait-checkbox input {
            cursor: pointer;
        }

        .preset-detail-actions {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }

        .preset-detail-actions .btn {
            width: 100%;
        }

        .entities-stats {
            margin-left: auto;
            display: flex;
            gap: 1rem;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .entities-stats strong {
            color: var(--text-primary);
        }

        .entities-content {
            display: flex;
            gap: 1rem;
            flex: 1;
            overflow: hidden;
        }

        .entities-list-panel {
            width: 280px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .entities-list-header {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .entities-list-section {
            border-bottom: 1px solid var(--border-color);
        }

        .entities-list-section:last-child {
            border-bottom: none;
        }

        .entities-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            background: var(--bg-card);
            cursor: pointer;
        }

        .entities-section-header:hover {
            background: var(--bg-hover);
        }

        .entities-section-header .section-icon {
            font-size: 0.8rem;
        }

        .entities-section-header .section-count {
            margin-left: auto;
            background: var(--bg-input);
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            font-size: 0.65rem;
        }

        .entities-section-items {
            max-height: 200px;
            overflow-y: auto;
        }

        .entities-section-items.collapsed {
            display: none;
        }

        .entity-list-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.15s ease;
            border-left: 3px solid transparent;
        }

        .entity-list-item:hover {
            background: var(--bg-hover);
        }

        .entity-list-item.selected {
            background: var(--bg-hover);
            border-left-color: var(--accent-primary);
        }

        .entity-list-item .entity-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .entity-list-item .entity-status.active {
            background: var(--accent-success);
            box-shadow: 0 0 6px var(--accent-success);
        }

        .entity-list-item .entity-status.stored {
            background: var(--text-muted);
        }

        .entity-list-item .entity-status.starred {
            background: var(--accent-gold);
            box-shadow: 0 0 6px var(--accent-gold);
        }

        .entity-list-item .entity-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entity-list-item .entity-actions {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .entity-list-item:hover .entity-actions {
            opacity: 1;
        }

        .entity-list-item .entity-action-btn {
            padding: 0.15rem 0.3rem;
            font-size: 0.65rem;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-muted);
            cursor: pointer;
        }

        .entity-list-item .entity-action-btn:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .entity-list-item .entity-action-btn.star-btn:hover {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
        }

        .entity-list-item .entity-action-btn.delete-btn:hover {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
        }

        .entities-detail-panel {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem;
            overflow-y: auto;
        }

        .entity-detail-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .entity-detail-name {
            font-family: 'Raleway', sans-serif;
            font-size: 1.1rem;
            color: var(--accent-highlight);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-detail-name input {
            background: transparent;
            border: none;
            border-bottom: 1px dashed var(--border-color);
            color: var(--accent-highlight);
            font-family: 'Raleway', sans-serif;
            font-size: 1.1rem;
            padding: 0.2rem;
            width: 200px;
        }

        .entity-detail-name input:focus {
            outline: none;
            border-bottom-color: var(--accent-primary);
        }

        .entity-detail-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-status-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .entity-status-badge.active {
            background: rgba(74, 124, 89, 0.2);
            color: var(--accent-success);
            border: 1px solid var(--accent-success);
        }

        .entity-status-badge.stored {
            background: rgba(107, 95, 82, 0.2);
            color: var(--text-muted);
            border: 1px solid var(--text-muted);
        }

        .entity-status-badge.starred {
            background: rgba(212, 168, 75, 0.2);
            color: var(--accent-gold);
            border: 1px solid var(--accent-gold);
        }

        .entity-detail-section {
            margin-bottom: 1rem;
        }

        .entity-detail-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .entity-detail-section-title .add-btn-inline {
            font-size: 0.6rem;
            padding: 0.1rem 0.25rem;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            border-radius: 3px;
            cursor: pointer;
            opacity: 0.6;
            transition: all 0.15s ease;
        }

        .entity-detail-section-title .add-btn-inline:hover {
            opacity: 1;
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .entity-detail-section-title .add-btn-inline.modifier-btn:hover {
            border-color: var(--node-modifier);
            color: var(--node-modifier);
        }

        .entity-detail-section-title .add-btn-inline.compound-btn:hover {
            border-color: var(--node-compound);
            color: var(--node-compound);
        }

        .entity-detail-section-title .add-btn-inline.trait-btn:hover {
            border-color: var(--node-trait);
            color: var(--node-trait);
        }

        .entity-tick-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .tick-status {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.8rem;
        }

        .tick-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .tick-indicator.running {
            background: var(--accent-success);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .entities-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
        }

        .entities-empty-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            opacity: 0.4;
        }

        .entities-empty-text {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .entities-empty-hint {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Preview promote button */
        .preview-entity-actions {
            display: flex;
            gap: 0.35rem;
            margin-left: auto;
        }

        .preview-promote-btn {
            font-size: 0.7rem !important;
            padding: 0.2rem 0.5rem !important;
            background: rgba(74, 124, 89, 0.2) !important;
            border: 1px solid var(--accent-success) !important;
            color: var(--accent-success) !important;
        }

        .preview-promote-btn:hover {
            background: var(--accent-success) !important;
            color: white !important;
        }

        .preview-discard-btn {
            font-size: 0.7rem !important;
            padding: 0.2rem 0.5rem !important;
        }

        /* ========================================
           MODIFIER MANAGEMENT (Entity Detail)
           ======================================== */
        .modifiers-section {
            margin-bottom: 1rem;
        }

        .modifier-category {
            margin-bottom: 0.75rem;
        }

        .modifier-category-title,
        .modifier-category-label {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.35rem;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .modifier-category-title .category-icon {
            font-size: 0.7rem;
        }

        .modifier-action {
            margin-left: auto;
            font-size: 0.7rem;
            color: var(--accent-success);
            opacity: 0.7;
        }

        .modifier-item.available:hover .modifier-action {
            opacity: 1;
        }

        .modifier-type {
            font-size: 0.7rem;
            color: var(--accent-gold);
            margin-left: auto;
        }

        .modifiers-list {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .modifier-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.6rem;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 0.8rem;
            transition: all 0.15s ease;
        }

        .modifier-item:hover {
            border-color: var(--node-modifier);
        }

        .modifier-item.active {
            background: rgba(184, 115, 169, 0.15);
            border-color: var(--node-modifier);
        }

        .modifier-item.available {
            cursor: pointer;
        }

        .modifier-item.available:hover {
            background: rgba(184, 115, 169, 0.1);
        }

        .modifier-item.threshold {
            background: rgba(218, 165, 32, 0.1);
            border-color: rgba(218, 165, 32, 0.3);
        }

        .modifier-item.ineligible {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .modifier-icon {
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .modifier-icon.active { color: var(--node-modifier); }
        .modifier-icon.available { color: var(--accent-success); }
        .modifier-icon.threshold { color: var(--accent-gold); }
        .modifier-icon.ineligible { color: var(--text-muted); }

        .modifier-info {
            flex: 1;
            min-width: 0;
        }

        .modifier-name {
            color: var(--text-primary);
            font-weight: 500;
        }

        .modifier-trigger {
            font-size: 0.65rem;
            color: var(--accent-gold);
            margin-top: 0.15rem;
        }

        .modifier-blocked {
            font-size: 0.65rem;
            color: var(--accent-danger);
            margin-top: 0.15rem;
        }

        .modifier-duration {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.15rem;
        }

        .modifier-action {
            flex-shrink: 0;
        }

        .modifier-action button {
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
        }

        .apply-modifier-btn {
            background: rgba(74, 124, 89, 0.2) !important;
            border: 1px solid var(--accent-success) !important;
            color: var(--accent-success) !important;
        }

        .apply-modifier-btn:hover {
            background: var(--accent-success) !important;
            color: white !important;
        }

        .force-apply-btn {
            background: rgba(218, 165, 32, 0.2) !important;
            border: 1px solid var(--accent-gold) !important;
            color: var(--accent-gold) !important;
        }

        .force-apply-btn:hover {
            background: var(--accent-gold) !important;
            color: var(--bg-dark) !important;
        }

        .remove-modifier-btn {
            background: rgba(167, 80, 84, 0.2) !important;
            border: 1px solid var(--accent-danger) !important;
            color: var(--accent-danger) !important;
        }

        .remove-modifier-btn:hover {
            background: var(--accent-danger) !important;
            color: white !important;
        }

        .modifiers-empty {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem;
            text-align: center;
        }

        /* ========================================
           COMPOUND MANAGEMENT (Entity Detail)
           ======================================== */
        .compounds-section {
            margin-bottom: 1rem;
        }

        .compounds-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .compound-item {
            padding: 0.5rem 0.6rem;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            transition: all 0.15s ease;
        }

        .compound-item:hover {
            border-color: var(--node-compound);
        }

        .compound-item.active {
            background: rgba(165, 67, 67, 0.15);
            border-color: var(--node-compound);
        }

        .compound-item.inactive {
            opacity: 0.7;
        }

        .compound-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.35rem;
        }

        .compound-status-icon {
            font-size: 0.85rem;
        }

        .compound-status-icon.active { color: var(--node-compound); }
        .compound-status-icon.inactive { color: var(--text-muted); }

        .compound-icon {
            font-size: 0.85rem;
            color: var(--node-compound);
        }

        .compound-item:not(.active) .compound-icon {
            color: var(--text-muted);
        }

        .compound-name {
            flex: 1;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .compound-item.active .compound-name {
            color: var(--node-compound);
        }

        .compound-item-name {
            flex: 1;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .compound-item.active .compound-item-name {
            color: var(--node-compound);
        }

        .compound-action button {
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
        }

        .force-activate-btn {
            background: rgba(165, 67, 67, 0.2) !important;
            border: 1px solid var(--node-compound) !important;
            color: var(--node-compound) !important;
        }

        .force-activate-btn:hover {
            background: var(--node-compound) !important;
            color: white !important;
        }

        .force-deactivate-btn {
            background: rgba(167, 80, 84, 0.2) !important;
            border: 1px solid var(--accent-danger) !important;
            color: var(--accent-danger) !important;
        }

        .force-deactivate-btn:hover {
            background: var(--accent-danger) !important;
            color: white !important;
        }

        .compound-requirements {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
            margin-top: 0.25rem;
            align-items: center;
        }

        .req-label {
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-right: 0.15rem;
        }

        .req-item {
            font-size: 0.65rem;
            padding: 0.15rem 0.35rem;
            border-radius: 3px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
        }

        .req-item.met {
            background: rgba(74, 124, 89, 0.2);
            border-color: var(--accent-success);
            color: var(--accent-success);
        }

        .req-item.unmet {
            background: rgba(167, 80, 84, 0.1);
            border-color: rgba(167, 80, 84, 0.3);
            color: var(--text-muted);
        }

        .compound-ready {
            font-size: 0.6rem;
            color: var(--accent-success);
            background: rgba(74, 124, 89, 0.2);
            border: 1px solid var(--accent-success);
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            margin-left: auto;
        }

        .compound-ready.all-met {
            color: var(--accent-success);
            font-style: normal;
        }

        .compounds-empty,
        .compound-empty,
        .modifier-empty,
        .modifiers-empty {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem;
            text-align: center;
        }

        /* Cross-reference footer */
        .view-footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 1rem;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .view-footer a {
            color: var(--accent-secondary);
            text-decoration: none;
            cursor: pointer;
        }

        .view-footer a:hover {
            color: var(--accent-highlight);
            text-decoration: underline;
        }

        /* ========================================
           POOL MANAGEMENT
           ======================================== */
        .pool-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
        }

        .pool-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .pool-selector label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .pool-selector select {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 0.35rem 0.5rem;
            font-size: 0.8rem;
            min-width: 140px;
        }

        .pool-selector select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .pool-stats-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .pool-stat {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .pool-stat-value {
            color: var(--accent-highlight);
            font-weight: 600;
        }

        .pool-stat-max {
            color: var(--text-muted);
        }

        .pool-manage-btn {
            margin-left: auto;
            font-size: 0.75rem !important;
            padding: 0.3rem 0.6rem !important;
        }

        /* Pool Management Modal */
        .pool-modal-content {
            max-height: 60vh;
            overflow-y: auto;
        }

        .pool-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .pool-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .pool-card.default {
            border-color: var(--accent-tertiary);
        }

        .pool-card-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
        }

        .pool-card-header .pool-icon {
            font-size: 1rem;
            color: var(--accent-secondary);
        }

        .pool-name-input {
            background: transparent;
            border: none;
            border-bottom: 1px dashed var(--border-color);
            color: var(--accent-highlight);
            font-family: 'Raleway', sans-serif;
            font-size: 0.95rem;
            padding: 0.2rem;
            flex: 1;
        }

        .pool-name-input:focus {
            outline: none;
            border-bottom-color: var(--accent-primary);
        }

        .pool-id-badge {
            font-size: 0.65rem;
            color: var(--text-muted);
            font-family: monospace;
            background: var(--bg-input);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
        }

        .pool-card-body {
            padding: 0.75rem;
        }

        .pool-config-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .pool-config-field {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .pool-config-field label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .pool-config-field input,
        .pool-config-field select {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            padding: 0.4rem 0.5rem;
            font-size: 0.8rem;
        }

        .pool-config-field input:focus,
        .pool-config-field select:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .pool-card-stats {
            display: flex;
            gap: 1rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-input);
            border-top: 1px solid var(--border-color);
            font-size: 0.75rem;
        }

        .pool-card-stats .stat {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .pool-card-stats .stat-label {
            color: var(--text-muted);
        }

        .pool-card-stats .stat-value {
            color: var(--accent-highlight);
            font-weight: 600;
        }

        .pool-card-actions {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
        }

        .pool-rules-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }

        .pool-rules-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .pool-rules-header span {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .pool-rules-toggle {
            display: flex;
            gap: 0.25rem;
        }

        .pool-rules-toggle button {
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
        }

        .pool-rules-toggle button.active {
            background: var(--accent-primary);
            color: white;
        }

        .pool-rule-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-input);
            border-radius: 4px;
        }

        .pool-rule-row select,
        .pool-rule-row input {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            padding: 0.3rem 0.4rem;
            font-size: 0.75rem;
        }

        .pool-rule-row input {
            flex: 1;
        }

        .pool-rule-delete {
            background: transparent !important;
            border: none !important;
            color: var(--accent-danger) !important;
            cursor: pointer;
            padding: 0.2rem !important;
        }

        .add-pool-card {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background: var(--bg-card);
            border: 2px dashed var(--border-color);
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .add-pool-card:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        /* Entity detail pool section */
        .entity-pool-select {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .entity-pool-select select {
            flex: 1;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 0.4rem 0.5rem;
            font-size: 0.8rem;
        }

        .entity-pool-hint {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
            text-align: center;
            padding: 2rem;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.4;
            color: var(--accent-primary);
        }

        .empty-state-text {
            font-family: 'Raleway', sans-serif;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            letter-spacing: 0.05em;
        }

        .empty-state-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* Jump In Message (shown after blank config + Jump In) */
        .jump-in-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            text-align: center;
            padding: 2rem;
        }

        .jump-in-message .jump-in-icon {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            opacity: 0.6;
        }

        .jump-in-message .jump-in-text {
            font-family: 'Raleway', sans-serif;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            letter-spacing: 0.03em;
        }

        .jump-in-message .jump-in-hint {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* ========================================
           DETAIL PANEL (Right Panel)
           ======================================== */
        .detail-panel {
            background: linear-gradient(180deg, var(--bg-panel) 0%, var(--bg-dark) 100%);
            border-left: 1px solid var(--border-ornate);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .detail-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-panel);
        }

        .detail-header .detail-title {
            flex: 1;
        }

        .detail-close-btn {
            font-size: 0.9rem;
            color: var(--text-muted);
            opacity: 0.6;
            margin-left: 0.25rem;
        }

        .detail-close-btn:hover {
            opacity: 1;
            color: var(--text-primary);
        }

        .detail-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--accent-highlight);
            letter-spacing: 0.05em;
        }

        .detail-actions {
            display: flex;
            gap: 0.25rem;
        }

        .detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .detail-section {
            margin-bottom: 1.25rem;
        }

        .detail-section-title {
            font-family: 'Raleway', sans-serif;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-secondary);
            margin-bottom: 0.5rem;
        }

        /* Modifier threshold config in detail panel */
        .threshold-config-section {
            margin-top: 0.5rem;
            padding: 0.6rem;
            background: rgba(0,0,0,0.15);
            border-radius: 6px;
            border-left: 3px solid var(--node-modifier);
        }

        .static-mode-row {
            margin-bottom: 0.5rem !important;
        }

        .static-checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .static-checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .reactive-note {
            margin-top: 0.5rem;
            padding: 0.4rem 0.6rem;
            background: rgba(92, 184, 92, 0.15);
            border-radius: 4px;
            font-size: 0.7rem;
            color: var(--accent-success);
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .reactive-icon {
            font-size: 0.9rem;
        }

        .detail-conditions-list {
            margin-top: 0.4rem;
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .detail-condition-row {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.35rem 0.4rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .detail-condition-row select {
            padding: 0.2rem 0.3rem;
            font-size: 0.7rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
        }

        .detail-condition-row .cond-target {
            flex: 1;
            min-width: 80px;
        }

        .detail-condition-row .cond-op {
            width: 50px;
        }

        .detail-condition-row .cond-value {
            width: 50px;
            padding: 0.2rem 0.3rem;
            font-size: 0.7rem;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            color: var(--text-primary);
            text-align: center;
        }

        .detail-condition-row .cond-remove {
            padding: 0.15rem 0.3rem;
            font-size: 0.65rem;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
        }

        .detail-condition-row .cond-remove:hover {
            color: var(--accent-danger);
        }

        .detail-condition-connector {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--copper);
            padding: 0.15rem 0.4rem;
            background: rgba(167,141,182,0.15);
            border-radius: 3px;
            cursor: pointer;
        }

        .detail-condition-connector:hover {
            background: rgba(167,141,182,0.25);
        }

        .detail-empty-conditions {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            padding: 0.5rem;
            text-align: center;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .form-group {
            margin-bottom: 0.75rem;
        }

        .form-group label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 0.5rem 0.75rem;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: 'Raleway', sans-serif;
            transition: all 0.2s ease;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 10px var(--glow-copper);
        }

        .form-group select {
            cursor: pointer;
        }

        .form-group select option {
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .form-row-3 {
            grid-template-columns: 1fr 1fr 1fr;
        }

        .form-row-4 {
            grid-template-columns: 1fr 1fr 1fr 1fr;
        }

        /* Relationship List */
        .relationship-list {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .relationship-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border-radius: 3px;
            font-size: 0.8rem;
            border: 1px solid var(--border-color);
            transition: all 0.15s ease;
        }

        .relationship-item:hover {
            border-color: var(--border-ornate);
            background: var(--bg-hover);
        }

        .relationship-item .arrow {
            color: var(--accent-secondary);
        }

        .relationship-item .value {
            color: var(--accent-gold);
            margin-left: auto;
            font-weight: 500;
        }

        .relationship-item .edit-btn,
        .relationship-item .delete-btn {
            opacity: 0;
            transition: opacity 0.2s;
        }

        .relationship-item:hover .edit-btn,
        .relationship-item:hover .delete-btn {
            opacity: 1;
        }

        .relationship-item .edit-btn {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .relationship-item .edit-btn:hover {
            color: var(--accent-highlight);
        }

        .relationship-item.upstream {
            border-color: var(--accent-warning);
            background: rgba(230, 162, 60, 0.1);
        }

        .relationship-item .upstream-warning {
            color: var(--accent-warning);
            font-size: 0.75rem;
            margin-left: 0.5rem;
            cursor: help;
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: 1px solid transparent;
            border-radius: 3px;
            font-size: 0.8rem;
            font-family: 'Raleway', sans-serif;
            font-weight: 500;
            letter-spacing: 0.03em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            color: var(--text-primary);
            border-color: var(--accent-secondary);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
            box-shadow: 0 0 15px var(--glow-copper);
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-secondary);
            border: 1px solid var(--border-ornate);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
            color: var(--accent-highlight);
            border-color: var(--accent-primary);
        }

        .btn-danger {
            background: transparent;
            color: var(--accent-danger);
            border-color: var(--accent-danger);
        }

        .btn-danger:hover {
            background: var(--accent-danger);
            color: var(--text-primary);
        }

        .btn-success {
            background: var(--accent-success);
            color: var(--text-primary);
            border-color: var(--accent-success);
        }

        .btn-success:hover {
            background: #5a9c69;
            box-shadow: 0 0 10px rgba(74, 124, 89, 0.4);
        }

        .btn-sm {
            padding: 0.3rem 0.6rem;
            font-size: 0.75rem;
        }

        .btn-icon {
            padding: 0.4rem;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.15s ease;
        }

        .btn-icon:hover {
            background: var(--bg-hover);
            color: var(--accent-highlight);
        }

        /* ========================================
           MODAL
           ======================================== */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-panel);
            border-radius: 4px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid var(--border-ornate);
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5), 0 0 20px var(--glow-copper);
        }

        .modal-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--border-ornate);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(180deg, var(--bg-card) 0%, var(--bg-panel) 100%);
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 500;
            color: var(--accent-highlight);
            letter-spacing: 0.05em;
        }

        .modal-body {
            padding: 1.25rem;
        }

        .modal-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
            background: var(--bg-card);
        }

        /* Sidebar modal mode - modal replaces sidebar content */
        .modal-overlay.sidebar-mode {
            position: fixed !important;
            top: 50px !important; /* Below header */
            left: 0 !important;
            right: auto !important;
            bottom: auto !important;
            width: 340px !important;
            height: calc(100vh - 50px) !important;
            background: transparent !important;
            backdrop-filter: none !important;
            pointer-events: none;
            z-index: 200;
            align-items: stretch !important;
            justify-content: flex-start !important;
            overflow: hidden;
        }

        /* Reduce sidebar height when wizard panel is active */
        body.wizard-active .modal-overlay.sidebar-mode {
            height: calc(100vh - 50px - 220px) !important; /* Subtract wizard panel height */
        }

        /* Reduce main layout height when wizard is active so content doesn't go behind wizard */
        body.wizard-active .main-layout {
            height: calc(100% - 220px); /* Subtract wizard panel height */
        }

        /* Shift main view content when sidebar modal is open */
        body.sidebar-modal-active .main-view {
            margin-left: 100px; /* 340px modal - 240px sidebar = 100px overlap */
        }

        body.sidebar-modal-active .view-tabs {
            padding-left: calc(1rem + 100px); /* Extra padding to clear modal */
        }

        /* Combined: sidebar modal + wizard active */
        body.sidebar-modal-active.wizard-active .modal-overlay.sidebar-mode {
            height: calc(100vh - 50px - 220px) !important;
        }

        .modal-overlay.sidebar-mode.active {
            display: flex !important;
        }

        .modal-overlay.sidebar-mode .modal {
            pointer-events: all;
            position: relative;
            width: 100% !important;
            max-width: none !important;
            max-height: none !important;
            height: 100% !important;
            border-radius: 0 !important;
            border: none !important;
            border-right: 1px solid var(--border-ornate) !important;
            margin: 0 !important;
            display: flex;
            flex-direction: column;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.5) !important;
        }

        .modal-overlay.sidebar-mode .modal-header {
            flex-shrink: 0;
            padding: 0.75rem;
        }

        .modal-overlay.sidebar-mode .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
        }

        .modal-overlay.sidebar-mode .modal-footer {
            flex-shrink: 0;
            padding: 0.75rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-card);
        }

        /* Legacy side-panel mode - keeps for backward compatibility */
        .modal-overlay.side-panel-mode {
            position: absolute;
            background: transparent;
            backdrop-filter: none;
            pointer-events: none;
            z-index: 100;
        }

        .modal-overlay.side-panel-mode .modal {
            pointer-events: all;
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            max-width: 380px;
            width: 380px;
            max-height: none;
            height: 100%;
            border-radius: 0;
            border-left: none;
            border-top: none;
            border-bottom: none;
            overflow-y: auto;
        }

        .modal-overlay.side-panel-mode .modal-body {
            max-height: calc(100vh - 140px);
            overflow-y: auto;
        }

        /* Node Type Selector */
        .node-type-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .node-type-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .node-type-option:hover {
            border-color: var(--accent-primary);
            background: var(--bg-hover);
        }

        .node-type-option.selected {
            border-color: var(--accent-secondary);
            background: linear-gradient(135deg, rgba(167, 141, 182, 0.2), rgba(138, 115, 150, 0.2));
            box-shadow: 0 0 10px var(--glow-copper);
        }

        .node-type-option .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            box-shadow: 0 0 6px currentColor;
        }

        .node-type-option .label {
            font-size: 0.85rem;
            font-family: 'Raleway', sans-serif;
        }

        /* Searchable Dropdown */
        .searchable-dropdown {
            position: relative;
        }

        .searchable-dropdown-input {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem 0.6rem;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .searchable-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
        }

        .searchable-dropdown.open .searchable-dropdown-menu {
            display: block;
        }

        .searchable-dropdown-group {
            padding: 0.4rem 0.6rem;
            font-size: 0.7rem;
            text-transform: uppercase;
            color: var(--text-muted);
            background: var(--bg-card);
        }

        .searchable-dropdown-item {
            padding: 0.5rem 0.6rem;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .searchable-dropdown-item:hover {
            background: var(--bg-card);
        }

        /* Status Bar */
        .status-bar {
            padding: 0.4rem 1rem;
            background: var(--bg-input);
            border-top: 1px solid var(--border-color);
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            gap: 1.5rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        /* ========================================
           TUTORIAL SYSTEM
           ======================================== */
        .tutorial-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .tutorial-overlay.active {
            display: flex;
        }

        .tutorial-card {
            background: var(--bg-panel);
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid var(--accent-primary);
        }

        .tutorial-header {
            padding: 1.25rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .tutorial-step-indicator {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .tutorial-step-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-color);
        }

        .tutorial-step-dot.active {
            background: var(--accent-primary);
        }

        .tutorial-step-dot.completed {
            background: var(--accent-success);
        }

        .tutorial-body {
            padding: 1.5rem;
        }

        .tutorial-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tutorial-title .icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .tutorial-description {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .tutorial-examples {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .tutorial-examples-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .tutorial-example {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
        }

        .tutorial-example:last-child {
            border-bottom: none;
        }

        .tutorial-example-icon {
            font-size: 1rem;
            min-width: 1.5rem;
            flex-shrink: 0;
        }

        .tutorial-example > div {
            flex: 1;
            min-width: 0; /* Allow text to wrap */
        }

        .tutorial-example-game {
            color: var(--accent-secondary);
            font-weight: 500;
            white-space: nowrap;
        }

        .tutorial-example-desc {
            color: var(--text-secondary);
            word-wrap: break-word;
        }

        .tutorial-tip {
            background: rgba(124, 58, 237, 0.15);
            border-left: 3px solid var(--accent-primary);
            padding: 0.75rem 1rem;
            border-radius: 0 6px 6px 0;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        .tutorial-tip-label {
            font-weight: 600;
            color: var(--accent-secondary);
            margin-right: 0.5rem;
        }

        /* Collapsible help section in Add Node modal */
        .node-help-container {
            margin-bottom: 0.75rem;
        }

        .node-help-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            padding: 0.5rem 0;
            color: var(--text-secondary);
            font-size: 0.8rem;
            user-select: none;
        }

        .node-help-header:hover {
            color: var(--text-primary);
        }

        .node-help-toggle {
            transition: transform 0.2s ease;
            font-size: 0.7rem;
        }

        .node-help-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .node-help-content {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
            max-height: 500px;
            opacity: 1;
        }

        .node-help-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
        }

        .tutorial-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-skip {
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
        }

        .tutorial-skip:hover {
            color: var(--text-secondary);
        }

        .tutorial-nav {
            display: flex;
            gap: 0.5rem;
        }

        /* ========================================
           WIZARD PANEL (Config Builder - Bottom Bar)
           ======================================== */
        .wizard-overlay {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .wizard-overlay.active {
            display: block;
        }

        .wizard-panel {
            background: var(--bg-panel);
            border-top: 2px solid var(--accent-primary);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: row;
            align-items: stretch;
            max-height: 220px;
        }

        .wizard-header {
            padding: 0.75rem 1rem;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-start;
            gap: 0.25rem;
            background: linear-gradient(180deg, var(--bg-card) 0%, var(--bg-panel) 100%);
            min-width: 140px;
        }

        .wizard-title {
            font-family: 'Raleway', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent-highlight);
        }

        .wizard-progress {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .wizard-body {
            padding: 1rem 1.25rem;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            min-height: 0; /* Allow shrinking for scroll */
        }

        .wizard-description {
            color: var(--text-secondary);
            font-size: 0.75rem;
            line-height: 1.5;
        }

        .wizard-description p {
            margin-bottom: 0.35rem;
        }

        .wizard-description ul,
        .wizard-description ol {
            margin: 0.35rem 0;
            padding-left: 1.25rem;
        }

        .wizard-description li {
            margin-bottom: 0.25rem;
        }

        .wizard-tip {
            background: rgba(74, 124, 89, 0.15);
            border-left: 3px solid var(--accent-success);
            padding: 0.5rem 0.75rem;
            border-radius: 0 6px 6px 0;
            font-size: 0.75rem;
            margin-top: 0.5rem;
            display: flex;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .wizard-tip-icon {
            flex-shrink: 0;
        }

        .wizard-complete-notice {
            background: rgba(74, 124, 89, 0.2);
            border: 1px solid var(--accent-success);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            margin-top: 0.5rem;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .wizard-footer {
            padding: 0.75rem 1rem;
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-card);
            min-width: 180px;
        }

        .wizard-nav {
            display: flex;
            gap: 0.5rem;
        }

        /* Wizard success popup (above wizard panel) */
        .wizard-success-popup {
            position: fixed;
            bottom: 240px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--bg-panel);
            border: 1px solid var(--accent-success);
            border-radius: 8px;
            padding: 1rem 1.25rem;
            max-width: 500px;
            min-width: 320px;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.4);
            z-index: 101;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .wizard-success-popup.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }

        .wizard-success-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .wizard-success-popup-content {
            flex: 1;
            font-size: 0.85rem;
            line-height: 1.5;
        }

        .wizard-success-popup-content p {
            margin-bottom: 0.35rem;
        }

        .wizard-success-popup-content ul {
            margin: 0.35rem 0;
            padding-left: 1.25rem;
        }

        .wizard-success-popup-content li {
            margin-bottom: 0.25rem;
        }

        .wizard-success-popup-close {
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            flex-shrink: 0;
        }

        .wizard-success-popup-close:hover {
            color: var(--text-primary);
        }

        /* Wizard term tooltips */
        .wizard-term {
            border-bottom: 1px dotted var(--accent-primary);
            cursor: help;
        }

        .wizard-term:hover {
            color: var(--accent-highlight);
        }

        .wizard-tooltip {
            position: fixed;
            background: var(--bg-card);
            border: 1px solid var(--accent-primary);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            max-width: 280px;
            font-size: 0.8rem;
            line-height: 1.4;
            color: var(--text-secondary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .wizard-tooltip.visible {
            opacity: 1;
        }

        .wizard-tooltip-title {
            font-weight: 600;
            color: var(--accent-highlight);
            margin-bottom: 0.25rem;
            text-transform: capitalize;
        }

        /* Help tooltips */
        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            font-size: 0.65rem;
            color: var(--text-muted);
            cursor: help;
            margin-left: 0.25rem;
        }

        .help-icon:hover {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .optional-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-weight: normal;
        }

        /* Welcome banner */
        .welcome-banner {
            background: linear-gradient(135deg, rgba(167, 141, 182, 0.15) 0%, rgba(138, 115, 150, 0.1) 100%);
            border: 1px solid var(--accent-primary);
            border-radius: 4px;
            padding: 1.25rem;
            margin-bottom: 1rem;
        }

        .welcome-title {
            font-family: 'Raleway', sans-serif;
            font-size: 1.1rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--accent-highlight);
            letter-spacing: 0.05em;
        }

        .welcome-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .welcome-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-ornate);
            border-radius: 4px;
            border: 1px solid var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-primary);
        }

        /* Selection styling */
        ::selection {
            background: rgba(167, 141, 182, 0.4);
            color: var(--text-primary);
        }

        /* Focus outlines */
        :focus-visible {
            outline: 2px solid var(--accent-primary);
            outline-offset: 2px;
        }

        /* ========================================
           TUTORIAL SYSTEM (Modular/Linked)
           ======================================== */

        .tutorial-system-container {
            display: none;
            position: fixed;
            z-index: 1001;
        }

        .tutorial-system-container.active {
            display: block;
        }

        /* Overlay Style */
        .tutorial-system-overlay {
            inset: 0;
        }

        .tutorial-system-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 12, 0.85);
        }

        .tutorial-system-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            background: var(--bg-secondary);
            border: 1px solid var(--border-ornate);
            border-radius: 8px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Panel Style (bottom) */
        .tutorial-system-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 2px solid var(--border-ornate);
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: row;
            min-height: 140px;
            max-height: 220px;
        }

        .tutorial-system-panel .tutorial-system-panel-header {
            display: flex;
            flex-direction: column;
            padding: 1rem;
            background: var(--bg-card);
            border-right: 1px solid var(--border-color);
            min-width: 200px;
        }

        .tutorial-system-panel .tutorial-system-title {
            font-family: 'Raleway', sans-serif;
            font-size: 0.9rem;
            color: var(--accent-highlight);
        }

        .tutorial-system-panel .tutorial-system-progress {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .tutorial-system-panel .tutorial-system-body {
            flex: 1;
            padding: 1rem 1.5rem;
            overflow-y: auto;
        }

        .tutorial-system-panel .tutorial-system-footer {
            padding: 1rem;
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            background: var(--bg-card);
            min-width: 180px;
        }

        /* Header */
        .tutorial-system-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-card);
        }

        .tutorial-system-steps {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
        }

        .tutorial-system-step-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .tutorial-system-step-dot.active {
            background: var(--accent-primary);
            border-color: var(--accent-highlight);
            transform: scale(1.2);
        }

        .tutorial-system-step-dot.completed {
            background: var(--accent-success);
            border-color: var(--accent-success);
        }

        /* Breadcrumb */
        .tutorial-system-breadcrumb {
            display: none;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
            color: var(--text-muted);
        }

        .breadcrumb-item {
            color: var(--text-secondary);
        }

        .breadcrumb-sep {
            color: var(--border-ornate);
        }

        .breadcrumb-current {
            color: var(--accent-secondary);
            font-weight: 500;
        }

        /* Body */
        .tutorial-system-body {
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .tutorial-system-step-title {
            font-family: 'Raleway', sans-serif;
            font-size: 1.25rem;
            color: var(--accent-highlight);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .tutorial-system-step-title .tutorial-icon {
            width: 24px;
            height: 24px;
            border-radius: 4px;
        }

        .tutorial-system-description {
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .tutorial-system-description p {
            margin-bottom: 0.75rem;
        }

        .tutorial-system-description ul,
        .tutorial-system-description ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .tutorial-system-description li {
            margin-bottom: 0.35rem;
        }

        /* Tip Box */
        .tutorial-system-tip {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background: rgba(167, 141, 182, 0.1);
            border: 1px solid rgba(167, 141, 182, 0.3);
            border-radius: 6px;
        }

        .tutorial-system-tip .tip-icon {
            font-size: 1rem;
        }

        .tutorial-system-tip .tip-text {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Examples */
        .tutorial-system-examples {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .examples-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            letter-spacing: 0.05em;
        }

        .tutorial-example-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.5rem 0;
            align-items: flex-start;
        }

        .tutorial-example-item .example-icon {
            font-size: 1rem;
        }

        .tutorial-example-item .example-game {
            color: var(--accent-secondary);
            font-weight: 500;
        }

        .tutorial-example-item .example-desc {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Linked Tutorials */
        .tutorial-system-links {
            margin-top: 1.25rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .links-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            letter-spacing: 0.05em;
        }

        .tutorial-link-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tutorial-link-item:hover {
            background: var(--bg-hover);
            border-color: var(--accent-primary);
        }

        .tutorial-link-item .link-icon {
            font-size: 1rem;
        }

        .tutorial-link-item .link-text {
            flex: 1;
            color: var(--text-primary);
            font-weight: 500;
        }

        .tutorial-link-item .link-arrow {
            color: var(--accent-secondary);
            font-size: 1.1rem;
        }

        /* Footer */
        .tutorial-system-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            background: var(--bg-card);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tutorial-system-skip {
            color: var(--text-muted);
            font-size: 0.85rem;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .tutorial-system-skip:hover {
            color: var(--text-secondary);
        }

        .tutorial-system-nav {
            display: flex;
            gap: 0.5rem;
        }

        /* Return button special styling */
        .tutorial-system-nav button[id$="-return"] {
            background: rgba(167, 141, 182, 0.2);
            border-color: var(--accent-primary);
            color: var(--accent-highlight);
        }

        .tutorial-system-nav button[id$="-return"]:hover {
            background: rgba(167, 141, 182, 0.3);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-title">
                <span id="headerTitle">Spawn Engine Editor</span>
                <span class="version">v3.1.9</span>
            </div>
            <div class="header-actions">
                <select id="presetSelector" onchange="loadPresetOrNew(this.value)" style="background: var(--bg-input); border: 1px solid var(--border-ornate); border-radius: 3px; padding: 0.5rem 0.75rem; color: var(--text-primary); font-size: 0.8rem; font-family: 'Raleway', sans-serif; cursor: pointer;">
                    <option value="">Load Config...</option>
                    <option value="__blank__">Blank Config</option>
                    <option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>
                    <!-- Populated dynamically from PRESETS object -->
                </select>
                <button class="btn btn-icon" onclick="showTutorial()" title="Tutorial" style="font-size: 1rem;">?</button>
                <button class="btn btn-secondary" onclick="startWizard()" title="Step-by-step config builder">Wizard</button>
                <button class="btn btn-secondary" onclick="importConfig()">Import</button>
                <button class="btn btn-secondary" onclick="showCSVImportModal()">CSV</button>
                <button class="btn btn-secondary" onclick="exportConfig()">Export</button>
                <button class="btn btn-primary" onclick="testSpawn()">Test Spawn</button>
            </div>
        </header>

        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Config</div>
                    <div class="config-meta">
                        <input type="text" id="configName" placeholder="Config Name" oninput="updateConfigMeta()">
                        <input type="text" id="configId" placeholder="config-id" oninput="updateConfigMeta()">
                    </div>
                </div>

                <!-- System Overview -->
                <div class="sidebar-overview" id="sidebarOverview">
                    <!-- Rendered by JS -->
                </div>

                <div class="tree-container" id="treeContainer">
                    <!-- Tree sections rendered by JS -->
                </div>

                <button class="add-node-btn" onclick="showAddNodeModal()">
                    + Add Node
                </button>
            </aside>

            <!-- Main View -->
            <main class="main-view">
                <div class="view-tabs">
                    <button class="view-tab active" data-view="overview" onclick="switchView('overview')">Overview</button>
                    <button class="view-tab" data-view="simulation" onclick="switchView('simulation')">Simulation</button>
                    <button class="view-tab" data-view="persistence" onclick="switchView('persistence')">Persistence</button>
                    <button class="view-tab" data-view="ticks" onclick="switchView('ticks')">Ticks</button>
                    <button class="view-tab" data-view="code" onclick="switchView('code')">Code</button>
                    <button class="view-tab" data-view="validate" onclick="switchView('validate')">Validate</button>
                </div>
                <div class="view-content" id="viewContent">
                    <!-- View content rendered by JS -->
                </div>
            </main>

            <!-- Detail Panel -->
            <aside class="detail-panel">
                <div class="detail-header">
                    <span class="detail-title" id="detailTitle">No Selection</span>
                    <div class="detail-actions" id="detailActions" style="display: none;"></div>
                    <button class="btn btn-icon detail-close-btn" onclick="closeDetailPanel()" title="Close panel">âœ•</button>
                </div>
                <div class="detail-content" id="detailContent">
                    <div class="empty-state">
                        <div class="empty-state-icon">â—‡</div>
                        <div class="empty-state-text">No node selected</div>
                        <div class="empty-state-hint">Click a node to view and edit its properties</div>
                    </div>
                </div>
            </aside>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <span class="status-item"><span id="nodeCount">0</span> nodes</span>
            <span class="status-item"><span id="relationshipCount">0</span> relationships</span>
            <span class="status-item">Tier: <span id="tierDisplay">free</span></span>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-card">
            <div class="tutorial-header">
                <div class="tutorial-step-indicator" id="tutorialSteps">
                    <!-- Steps rendered by JS -->
                </div>
                <button class="btn btn-icon" onclick="closeTutorial()">âœ•</button>
            </div>
            <div class="tutorial-body" id="tutorialBody">
                <!-- Content rendered by JS -->
            </div>
            <div class="tutorial-footer">
                <span class="tutorial-skip" onclick="closeTutorial()">Skip tutorial</span>
                <div class="tutorial-nav">
                    <button class="btn btn-secondary" id="tutorialPrev" onclick="prevTutorialStep()">Back</button>
                    <button class="btn btn-primary" id="tutorialNext" onclick="nextTutorialStep()">Next</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Relationship Modal -->
    <div class="modal-overlay" id="addRelationshipModal">
        <div class="modal">
            <div class="modal-header" style="position: relative;">
                <span class="modal-title" id="relModalTitle">Add Connection</span>
                <button class="btn btn-icon" onclick="closeModal('addRelationshipModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group" style="margin-bottom: 1rem;">
                    <label>Source Node</label>
                    <div id="relSourceDisplay" style="padding: 0.5rem 0.75rem; background: var(--bg-card); border-radius: 4px; border-left: 3px solid var(--accent-primary); display: none;">
                        <span id="relSourceName" style="font-weight: 600;">--</span>
                        <span id="relSourceType" style="font-size: 0.8rem; color: var(--text-secondary); margin-left: 0.5rem;">--</span>
                    </div>
                    <select id="relSourceSelect" style="display: none;" onchange="onRelSourceSelected(this.value)">
                        <option value="">-- Select source node --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Connection Type <span class="help-icon" title="How the source affects the target">?</span></label>
                    <select id="newRelType" onchange="updateRelTypeHelp()">
                        <option value="weight_influence">Weight Influence (affects selection probability)</option>
                        <option value="rate_modifier">Rate Modifier (affects variable change speed)</option>
                        <option value="value_modifier">Value Modifier (instant value change)</option>
                        <option value="eligibility_gate">Eligibility Gate (blocks/allows selection)</option>
                        <option value="requires">Requires (for compounds)</option>
                        <option value="replaces">Replaces (deactivates when source is active)</option>
                        <option value="duration_binding">Duration Binding (modifier to tick system)</option>
                    </select>
                </div>
                <div id="relTypeHelp" class="tutorial-tip" style="margin-bottom: 1rem;">
                    <span class="tutorial-tip-label">Weight Influence:</span>
                    Changes how likely an item is to be selected. Positive values increase chance, negative decrease.
                </div>
                <div class="form-group">
                    <label id="relTargetLabel">Target Node <span class="help-icon" title="The node being affected">?</span></label>
                    <select id="newRelTarget" onchange="updateRelPreview()">
                        <!-- Options populated by JS -->
                    </select>
                </div>
                <div class="form-row" id="relValueRow">
                    <div class="form-group">
                        <label id="relOperationLabel">Operation</label>
                        <select id="newRelOperation" onchange="updateRelPreview()">
                            <option value="add">Add (+/-)</option>
                            <option value="multiply">Multiply (Ã—)</option>
                            <option value="set">Set (=)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label id="relValueLabel">Value</label>
                        <input type="number" id="newRelValue" value="" step="1" placeholder="0" oninput="updateRelPreview()">
                    </div>
                </div>
                <!-- Advanced settings section (for weight_influence) -->
                <div id="relAdvancedSection" style="display: none; margin-top: 0.5rem;">
                    <div class="form-group" style="border-top: 1px solid var(--border-color); padding-top: 0.75rem;">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; cursor: pointer;" onclick="toggleRelAdvanced()">
                            <span id="relAdvancedToggle" style="font-size: 0.7rem;">â–¶</span>
                            <span style="font-size: 0.85rem; color: var(--text-secondary);">Advanced Settings</span>
                        </div>
                        <div id="relAdvancedContents" style="display: none; padding-left: 1rem;">
                            <div class="form-group" style="margin-bottom: 0.5rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.85rem;">
                                    <input type="checkbox" id="newRelInvert" style="width: auto;" onchange="updateRelPreview()">
                                    Invert effect <span class="help-icon" title="Invert: Higher source values decrease weight instead of increasing it">?</span>
                                </label>
                            </div>
                            <div class="form-group" style="margin-bottom: 0.5rem;">
                                <label style="font-size: 0.85rem;">Scaling Mode</label>
                                <select id="newRelScaling" onchange="toggleRelScalingSource(); updateRelPreview();">
                                    <option value="perPoint">Per Point (scales with source value)</option>
                                    <option value="flat">Flat (fixed amount)</option>
                                </select>
                            </div>
                            <div class="form-group" id="relScalingSourceRow" style="display: none; margin-bottom: 0.5rem;">
                                <label style="font-size: 0.85rem;">Scale By</label>
                                <select id="newRelScalingSource" onchange="updateRelPreview()">
                                    <!-- Populated by JS with attributes/variables -->
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="relPreview" style="margin: 1rem 0; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 6px; border-left: 3px solid var(--accent-primary);">
                    <!-- Live preview of relationship effect -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('addRelationshipModal')">Cancel</button>
                <button class="btn btn-primary" id="relSubmitBtn" onclick="addRelationship()">Add Connection</button>
            </div>
        </div>
    </div>

    <!-- Add Node Modal -->
    <div class="modal-overlay" id="addNodeModal">
        <div class="modal">
            <div class="modal-header" style="position: relative;">
                <span class="modal-title">Add Node</span>
                <button class="btn btn-icon" onclick="closeModal('addNodeModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Node Type</label>
                    <div class="node-type-grid" id="nodeTypeGrid">
                        <div class="node-type-option" data-type="attribute" onclick="selectNodeType('attribute')">
                            <span class="dot" style="background: var(--node-attribute)"></span>
                            <span class="label">Attribute</span>
                        </div>
                        <div class="node-type-option" data-type="variable" onclick="selectNodeType('variable')">
                            <span class="dot" style="background: var(--node-variable)"></span>
                            <span class="label">Variable</span>
                        </div>
                        <div class="node-type-option" data-type="context" onclick="selectNodeType('context')">
                            <span class="dot" style="background: var(--node-context)"></span>
                            <span class="label">Context</span>
                        </div>
                        <div class="node-type-option" data-type="layer" onclick="selectNodeType('layer')">
                            <span class="dot" style="background: var(--node-layer)"></span>
                            <span class="label">Layer</span>
                        </div>
                        <div class="node-type-option" data-type="trait" onclick="selectNodeType('trait')">
                            <span class="dot" style="background: var(--node-trait)"></span>
                            <span class="label">Trait</span>
                        </div>
                        <div class="node-type-option" data-type="modifier" onclick="selectNodeType('modifier')">
                            <span class="dot" style="background: var(--node-modifier)"></span>
                            <span class="label">Modifier</span>
                        </div>
                        <div class="node-type-option" data-type="compound" onclick="selectNodeType('compound')">
                            <span class="dot" style="background: var(--node-compound)"></span>
                            <span class="label">Compound</span>
                        </div>
                        <div class="node-type-option" data-type="action" onclick="selectNodeType('action')">
                            <span class="dot" style="background: var(--node-action)"></span>
                            <span class="label">Action</span>
                        </div>
                        <div class="node-type-option" data-type="derived" onclick="selectNodeType('derived')">
                            <span class="dot" style="background: var(--node-derived)"></span>
                            <span class="label">Derived</span>
                        </div>
                        <div class="node-type-option" data-type="ticksystem" onclick="selectNodeType('ticksystem')">
                            <span class="dot" style="background: var(--node-ticksystem)"></span>
                            <span class="label">Tick System</span>
                        </div>
                    </div>
                </div>
                <div id="newNodeTypeConfig">
                    <!-- Type-specific fields rendered by JS -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('addNodeModal')">Cancel</button>
                <button class="btn btn-primary" onclick="addNode()">Add Node</button>
            </div>
        </div>
    </div>

    <!-- CSV Import Modal -->
    <div class="modal-overlay" id="csvImportModal">
        <div class="modal" style="max-width: 600px;">
            <div class="modal-header">
                <span class="modal-title">Import from CSV</span>
                <button class="btn btn-icon" onclick="closeModal('csvImportModal')">âœ•</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Import Type</label>
                    <select id="csvImportType" onchange="updateCSVHelp()">
                        <option value="attributes">Attributes</option>
                        <option value="variables">Variables</option>
                        <option value="layers">Layers</option>
                        <option value="traits">Traits</option>
                        <option value="relationships">Relationships</option>
                        <option value="presetGroups">Preset Groups</option>
                        <option value="presets">Presets (Entity Templates)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>CSV Data</label>
                    <textarea id="csvImportData" rows="10" placeholder="Paste CSV data here..." style="width: 100%; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 3px; padding: 0.75rem; color: var(--text-primary); font-family: monospace; font-size: 0.85rem; resize: vertical;"></textarea>
                </div>
                <div id="csvHelpText" style="background: var(--bg-card); padding: 0.75rem; border-radius: 3px; font-size: 0.8rem; color: var(--text-secondary);">
                    <strong>Expected columns:</strong> id, name, description, min, max, default_min, default_max, precision
                </div>
                <div style="margin-top: 0.75rem;">
                    <button class="btn btn-secondary" onclick="downloadCSVTemplate()" style="font-size: 0.8rem;">Download Template</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('csvImportModal')">Cancel</button>
                <button class="btn btn-primary" onclick="importCSVData()">Import</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script>
// ============================================================================
// SPAWN ENGINE v3 - BUNDLED
// ============================================================================

/**
 * Spawn Engine v3 - Browser Bundle
 *
 * A configurable hierarchical state engine for generating entities with
 * layered traits, dynamic variables, and emergent compound states.
 *
 * Two-part architecture:
 * - SpawnManager: Pure generation logic (the brain)
 * - EntityManager: Storage & runtime state (the filing cabinet + clock)
 * - SpawnEngine: Convenience wrapper combining both
 *
 * @module SpawnEngine
 * @version 3.0
 * @author Shane Ostrom
 * @license MIT
 * @see {@link https://shaneostrom.com} for documentation
 */

// ============================================================================
// SPAWN MANAGER - Pure Generation Logic
// ============================================================================

/**
 * Pure generation logic for creating entity snapshots.
 * Handles config loading, attribute rolling, trait selection, and relationship calculations.
 * Does not manage runtime state - use EntityManager for that.
 *
 * @class SpawnManager
 * @example
 * const manager = new SpawnManager(config);
 * const entity = manager.generate();
 * console.log(entity.attributes);
 */
class SpawnManager {
    /**
     * Create a new SpawnManager instance.
     *
     * @param {Object|null} [config=null] - Configuration object to load immediately
     * @example
     * // Create without config
     * const manager = new SpawnManager();
     * manager.loadConfig(myConfig);
     *
     * // Create with config
     * const manager = new SpawnManager(myConfig);
     */
    constructor(config = null) {
        /** @type {Object|null} Current configuration */
        this.config = null;
        /** @type {Map<string, Object>} Node lookup index */
        this.nodeIndex = new Map();
        /** @type {Object} Relationship indexes by source, target, and type */
        this.relationshipIndex = {
            bySource: new Map(),
            byTarget: new Map(),
            byType: new Map()
        };
        /** @type {Map<string, Array<Object>>} Cached nodes grouped by type */
        this._nodesByType = new Map();
        /** @type {Map<string, {fn: Function, keys: string[]}>} Compiled formula cache */
        this._formulaCache = new Map();
        /** @type {Array<Object>} Pre-filtered threshold modifier nodes */
        this._thresholdModifiers = [];
        /** @type {Map<string, Array<Object>>} Threshold traits indexed by target variable ID */
        this._thresholdTraitsByVar = new Map();
        /** @type {Map<string, Set<string>>} Pre-computed exclusive modifier groups */
        this._exclusiveGroups = new Map();
        /** @type {EntityManager|null} Linked EntityManager for preset access */
        this.entityManager = null;

        if (config) {
            this.loadConfig(config);
        }
    }

    /**
     * Link an EntityManager for preset and runtime integration.
     *
     * @param {EntityManager} entityManager - The EntityManager to link
     * @returns {SpawnManager} This instance for chaining
     * @example
     * const spawnManager = new SpawnManager(config);
     * const entityManager = new EntityManager();
     * spawnManager.linkEntityManager(entityManager);
     */
    linkEntityManager(entityManager) {
        this.entityManager = entityManager;
        return this;
    }

    // ========================================
    // CONFIG MANAGEMENT
    // ========================================

    /**
     * Load and process a configuration object.
     * Validates, normalizes, and builds lookup indexes.
     *
     * @param {Object} config - Configuration object
     * @param {string} config.id - Unique configuration ID
     * @param {string} config.name - Display name
     * @param {Array<Object>} config.nodes - Node definitions
     * @param {Array<Object>} [config.relationships] - Relationship definitions
     * @returns {SpawnManager} This instance for chaining
     * @example
     * manager.loadConfig({
     *   id: 'my-config',
     *   name: 'My Config',
     *   nodes: [...],
     *   relationships: [...]
     * });
     */
    loadConfig(config) {
        this.config = this.validateAndNormalize(config);
        this.buildIndexes();
        this._formulaCache.clear();
        return this;
    }

    validateAndNormalize(config) {
        const normalized = {
            id: config.id || 'unnamed-config',
            name: config.name || 'Unnamed Config',
            version: config.version || '3.0',
            tier: config.tier || 'free',
            description: config.description || '',
            nodes: config.nodes || [],
            relationships: config.relationships || [],
            presetGroups: config.presetGroups || [],
            presets: config.presets || [],
            engineConfig: {
                tickRate: config.engineConfig?.tickRate ?? 1000,
                maxEntities: config.engineConfig?.maxEntities ?? config.engineConfig?.maxSpawns ?? null
            }
        };

        normalized.nodes = normalized.nodes.map(node => {
            const normalizedNode = {
                id: node.id,
                name: node.name || node.id,
                description: node.description || '',
                type: node.type,
                tags: node.tags || [],
                taxonomy: node.taxonomy || null,  // Hierarchical categorization
                position: node.position || null,
                config: node.config || {}
            };

            // Modifier-specific normalization for backwards compatibility
            if (node.type === 'modifier' && normalizedNode.config) {
                const cfg = normalizedNode.config;

                // Convert 'manual' durationType to 'permanent'
                if (cfg.durationType === 'manual') {
                    cfg.durationType = 'permanent';
                }

                // Normalize trigger configuration
                if (cfg.trigger) {
                    // Convert single-condition trigger to conditions array
                    if (cfg.trigger.type === 'threshold' && cfg.trigger.target && !cfg.trigger.conditions) {
                        cfg.trigger.conditions = [{
                            target: cfg.trigger.target,
                            operator: cfg.trigger.operator || '<=',
                            value: cfg.trigger.value ?? 0
                        }];
                        cfg.trigger.logic = cfg.trigger.logic || 'all';
                    }

                    // Convert old autoRemove to static mode with removeConditions
                    if (cfg.trigger.autoRemove && !cfg.trigger.removeConditions) {
                        cfg.trigger.static = true;
                        cfg.trigger.removeConditions = [{
                            target: cfg.trigger.autoRemove.target || cfg.trigger.target,
                            operator: cfg.trigger.autoRemove.operator || '>=',
                            value: cfg.trigger.autoRemove.value ?? 0
                        }];
                        cfg.trigger.removeLogic = cfg.trigger.removeLogic || 'all';
                    }
                }

                // Normalize exclusiveWith to always be an array
                if (cfg.exclusiveWith) {
                    if (!Array.isArray(cfg.exclusiveWith)) {
                        cfg.exclusiveWith = [cfg.exclusiveWith];
                    }
                } else {
                    cfg.exclusiveWith = [];
                }
            }

            return normalizedNode;
        });

        normalized.relationships = normalized.relationships.map(rel => ({
            id: rel.id || `rel_${rel.sourceId}_${rel.targetId}`,
            sourceId: rel.sourceId,
            targetId: rel.targetId,
            type: rel.type,
            config: {
                operation: rel.config?.operation || 'add',
                value: rel.config?.value ?? 0,
                scaling: rel.config?.scaling || 'flat',
                perPointSource: rel.config?.perPointSource || null
            },
            conditions: rel.conditions || []
        }));

        // Normalize preset groups
        normalized.presetGroups = normalized.presetGroups.map(group => ({
            id: group.id,
            name: group.name || group.id,
            description: group.description || '',
            parentId: group.parentId || null
        }));

        // Normalize presets
        normalized.presets = normalized.presets.map(preset => ({
            id: preset.id,
            name: preset.name || preset.id,
            description: preset.description || '',
            group: preset.group || null,
            tags: preset.tags || [],
            attributes: preset.attributes || {},
            contexts: preset.contexts || {},
            forceTraits: preset.forceTraits || [],
            traits: preset.traits || null,  // New structured trait selection
            taxonomy: preset.taxonomy || null,  // Hierarchical categorization
            actions: preset.actions || null,  // Action weight overrides
            attributeOverrides: preset.attributeOverrides || null,
            variableOverrides: preset.variableOverrides || null
        }));

        return normalized;
    }

    buildIndexes() {
        this.nodeIndex.clear();
        this.relationshipIndex.bySource.clear();
        this.relationshipIndex.byTarget.clear();
        this.relationshipIndex.byType.clear();
        this._nodesByType.clear();

        for (const node of this.config.nodes) {
            this.nodeIndex.set(node.id, node);
            // Group by type for O(1) lookups
            if (!this._nodesByType.has(node.type)) {
                this._nodesByType.set(node.type, []);
            }
            this._nodesByType.get(node.type).push(node);
        }

        // Combined trait cache (trait + item types)
        this._nodesByType.set('_traits', [
            ...(this._nodesByType.get('trait') || []),
            ...(this._nodesByType.get('item') || [])
        ]);

        for (const rel of this.config.relationships) {
            if (!this.relationshipIndex.bySource.has(rel.sourceId)) {
                this.relationshipIndex.bySource.set(rel.sourceId, []);
            }
            this.relationshipIndex.bySource.get(rel.sourceId).push(rel);

            if (!this.relationshipIndex.byTarget.has(rel.targetId)) {
                this.relationshipIndex.byTarget.set(rel.targetId, []);
            }
            this.relationshipIndex.byTarget.get(rel.targetId).push(rel);

            if (!this.relationshipIndex.byType.has(rel.type)) {
                this.relationshipIndex.byType.set(rel.type, []);
            }
            this.relationshipIndex.byType.get(rel.type).push(rel);
        }

        // Pre-compute threshold modifiers (config-static)
        this._thresholdModifiers = (this._nodesByType.get('modifier') || []).filter(n =>
            n.config.trigger?.type === 'threshold'
        );

        // Pre-compute threshold traits grouped by target variable
        this._thresholdTraitsByVar.clear();
        const allTraits = this._nodesByType.get('_traits') || [];
        for (const trait of allTraits) {
            if (trait.config.selection?.mode === 'threshold') {
                const targetVar = trait.config.selection?.trigger?.target;
                if (targetVar) {
                    if (!this._thresholdTraitsByVar.has(targetVar)) {
                        this._thresholdTraitsByVar.set(targetVar, []);
                    }
                    this._thresholdTraitsByVar.get(targetVar).push(trait);
                }
            }
        }

        // Pre-compute exclusive modifier groups
        this._exclusiveGroups.clear();
        for (const mod of this._thresholdModifiers) {
            const exclusive = mod.config.exclusiveWith;
            if (exclusive && exclusive.length > 0) {
                if (!this._exclusiveGroups.has(mod.id)) this._exclusiveGroups.set(mod.id, new Set());
                for (const partnerId of exclusive) {
                    this._exclusiveGroups.get(mod.id).add(partnerId);
                    if (!this._exclusiveGroups.has(partnerId)) this._exclusiveGroups.set(partnerId, new Set());
                    this._exclusiveGroups.get(partnerId).add(mod.id);
                }
            }
        }
    }

    // ========================================
    // NODE QUERIES
    // ========================================

    /**
     * Get a node by its ID.
     *
     * @param {string} nodeId - The node ID to look up
     * @returns {Object|null} The node object or null if not found
     * @example
     * const strengthNode = manager.getNode('attr_strength');
     * console.log(strengthNode.name); // "Strength"
     */
    getNode(nodeId) {
        return this.nodeIndex.get(nodeId) || null;
    }

    /**
     * Get all nodes of a specific type.
     *
     * @param {string} type - Node type: 'attribute', 'variable', 'layer', 'trait', 'modifier', 'compound', 'derived'
     * @returns {Array<Object>} Array of matching nodes
     * @example
     * const attributes = manager.getNodesByType('attribute');
     * const traits = manager.getNodesByType('trait');
     */
    getNodesByType(type) {
        return this._nodesByType.get(type) || [];
    }

    /** @returns {Array<Object>} All attribute nodes */
    getAttributes() { return this.getNodesByType('attribute'); }
    /** @returns {Array<Object>} All variable nodes */
    getVariables() { return this.getNodesByType('variable'); }
    /** @returns {Array<Object>} All context nodes */
    getContexts() { return this.getNodesByType('context'); }
    /** @returns {Array<Object>} All modifier nodes */
    getModifiers() { return this.getNodesByType('modifier'); }
    /** @returns {Array<Object>} All compound nodes */
    getCompounds() { return this.getNodesByType('compound'); }
    /** @returns {Array<Object>} All derived value nodes */
    getDerived() { return this.getNodesByType('derived'); }

    /**
     * Get nodes matching a taxonomy filter.
     * Taxonomy provides hierarchical categorization (type/subtype/variant).
     *
     * @param {Object} filter - Taxonomy criteria to match
     * @returns {Array<Object>} Nodes matching all filter criteria
     * @example
     * // Get all humanoid items
     * manager.getNodesByTaxonomy({ type: 'humanoid' });
     *
     * // Get goblin variants specifically
     * manager.getNodesByTaxonomy({ type: 'humanoid', subtype: 'goblinoid' });
     */
    getNodesByTaxonomy(filter) {
        if (!filter || Object.keys(filter).length === 0) return [];
        return this.config.nodes.filter(n => {
            if (!n.taxonomy) return false;
            return Object.entries(filter).every(([key, value]) => n.taxonomy[key] === value);
        });
    }

    /**
     * Get all unique taxonomy values for a given level.
     *
     * @param {string} level - Taxonomy level ('type', 'subtype', 'variant')
     * @returns {string[]} Unique values at that level
     * @example
     * manager.getTaxonomyValues('type'); // ['humanoid', 'beast', 'undead']
     */
    getTaxonomyValues(level) {
        const values = new Set();
        for (const node of this.config.nodes) {
            if (node.taxonomy && node.taxonomy[level]) {
                values.add(node.taxonomy[level]);
            }
        }
        return Array.from(values).sort();
    }

    /**
     * Get all layer nodes, sorted by order.
     *
     * @returns {Array<Object>} Layer nodes sorted by config.order
     */
    getLayers() {
        return [...this.getNodesByType('layer')].sort((a, b) =>
            (a.config.order || 0) - (b.config.order || 0)
        );
    }

    /**
     * Get all spawnable nodes (attributes and layers) sorted by spawn order.
     * Used during entity generation to process nodes in the correct order,
     * allowing earlier-spawning traits to influence later-spawning attributes.
     *
     * @returns {Array<Object>} Nodes with type and order info, sorted by spawn order
     * @example
     * // Returns: [{ node: layerNode, type: 'layer', order: 0 }, { node: attrNode, type: 'attribute', order: 1 }, ...]
     */
    getSpawnOrder() {
        const items = [];

        // Add attributes with their spawn order
        for (const attr of this.getAttributes()) {
            items.push({
                node: attr,
                type: 'attribute',
                order: attr.config.spawnOrder ?? 0
            });
        }

        // Add layers that spawn at create/spawn time
        for (const layer of this.getNodesByType('layer')) {
            const timing = layer.config.timing || {};
            if (timing.rollAt === 'create' || timing.rollAt === 'spawn') {
                items.push({
                    node: layer,
                    type: 'layer',
                    order: layer.config.order ?? 0
                });
            }
        }

        // Sort by order (lower = earlier)
        return items.sort((a, b) => a.order - b.order);
    }

    /**
     * Calculate attribute range modifiers from active traits.
     * Used during spawn to allow traits to modify attribute rolls.
     *
     * @param {Object} entity - The entity being generated (may have partial state)
     * @param {Object} attr - The attribute node
     * @returns {Object} Modified range { min, max }
     */
    getModifiedAttributeRange(entity, attr) {
        const cfg = attr.config;
        let min = cfg.defaultRange?.[0] ?? cfg.min ?? 1;
        let max = cfg.defaultRange?.[1] ?? cfg.max ?? 10;

        // Find value_modifier relationships targeting this attribute
        const modifiers = this.getRelationshipsTo(attr.id)
            .filter(r => r.type === 'value_modifier');

        for (const rel of modifiers) {
            // Check if source is active (trait, modifier, etc.)
            if (!this.isNodeActive(entity, rel.sourceId)) continue;

            // Check conditions if any
            if (!this.evaluateConditions(entity, rel.conditions)) continue;

            const value = this.calculateRelationshipValue(entity, rel);
            const op = rel.config.operation || 'add';

            if (op === 'add') {
                min += value;
                max += value;
            } else if (op === 'multiply') {
                min *= value;
                max *= value;
            }
        }

        return { min, max };
    }

    /** @returns {Array<Object>} All action nodes */
    getActions() { return this.getNodesByType('action'); }

    /**
     * Get all traits belonging to a layer.
     *
     * @param {string} layerId - The layer ID
     * @returns {Array<Object>} Trait nodes in the layer
     * @example
     * const personalityTraits = manager.getLayerTraits('layer_personality');
     */
    getLayerTraits(layerId) {
        const layer = this.getNode(layerId);
        if (!layer || layer.type !== 'layer') return [];
        const ids = layer.config.traitIds || layer.config.itemIds || [];
        return ids.map(id => this.getNode(id)).filter(Boolean);
    }

    /**
     * Get all traits in a layer.
     * @deprecated Use getLayerTraits instead
     * @param {string} layerId - The layer ID
     * @returns {Array<Object>} Trait nodes
     */
    getLayerItems(layerId) { return this.getLayerTraits(layerId); }

    /**
     * Get all trait/item nodes in the configuration.
     *
     * @returns {Array<Object>} All trait and item nodes
     */
    getTraits() {
        return this._nodesByType.get('_traits') || [];
    }

    /**
     * Check if a node is a trait or item.
     *
     * @param {Object} node - Node to check
     * @returns {boolean} True if node is a trait or item
     */
    isTrait(node) {
        return node && (node.type === 'trait' || node.type === 'item');
    }

    // ========================================
    // RELATIONSHIP QUERIES
    // ========================================

    /**
     * Get all relationships where the given node is the source.
     *
     * @param {string} nodeId - Source node ID
     * @returns {Array<Object>} Relationships originating from this node
     * @example
     * const effects = manager.getRelationshipsFrom('attr_strength');
     * // Returns relationships where strength affects other nodes
     */
    getRelationshipsFrom(nodeId) {
        return this.relationshipIndex.bySource.get(nodeId) || [];
    }

    /**
     * Get all relationships where the given node is the target.
     *
     * @param {string} nodeId - Target node ID
     * @returns {Array<Object>} Relationships affecting this node
     * @example
     * const influences = manager.getRelationshipsTo('trait_warrior');
     * // Returns relationships that affect warrior selection weight
     */
    getRelationshipsTo(nodeId) {
        return this.relationshipIndex.byTarget.get(nodeId) || [];
    }

    /**
     * Get all relationships of a specific type.
     *
     * @param {string} type - Relationship type: 'weight_influence', 'rate_modifier', 'value_modifier'
     * @returns {Array<Object>} Relationships of the given type
     */
    getRelationshipsByType(type) {
        return this.relationshipIndex.byType.get(type) || [];
    }

    // ========================================
    // MAIN SPAWN METHODS
    // ========================================

    /**
     * Generate a new entity with random attributes and trait selection.
     *
     * This is the core generation method that:
     * 1. Rolls attributes within configured ranges
     * 2. Initializes variables with default values
     * 3. Selects traits from layers based on weights and eligibility
     * 4. Checks compound conditions
     * 5. Calculates derived values
     *
     * @param {Object} [overrides={}] - Optional overrides for generation
     * @param {string} [overrides.id] - Custom entity ID (default: auto-generated)
     * @param {Object} [overrides.attributes] - Attribute value overrides
     * @param {Object} [overrides.contexts] - Context value overrides
     * @param {string[]} [overrides.forceTraits] - Trait IDs to force-activate
     * @returns {Object} The generated entity object
     * @example
     * // Basic random generation
     * const entity = manager.generate();
     *
     * @example
     * // Generation with attribute overrides
     * const strong = manager.generate({
     *   attributes: { attr_strength: 10 }
     * });
     *
     * @example
     * // Force specific traits
     * const warrior = manager.generate({
     *   forceTraits: ['trait_warrior', 'trait_brave']
     * });
     */
    generate(overrides = {}) {
        const entityId = overrides.id || `entity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        const entity = {
            id: entityId,
            configId: this.config.id,
            createdAt: Date.now(),
            attributes: {},
            variables: {},
            contexts: {},
            layers: {},
            modifiers: [],
            compounds: [],
            derived: {},
            actions: {},  // Action cooldown state
            _internal: {
                log: [],
                lastTick: Date.now()
            }
        };

        // Initialize variables first (they don't depend on spawn order)
        for (const varNode of this.getVariables()) {
            const cfg = varNode.config;
            entity.variables[varNode.id] = {
                value: cfg.initial ?? 100,
                baseRate: cfg.baseRate ?? 0,
                currentRate: cfg.baseRate ?? 0,
                min: cfg.min ?? 0,
                max: cfg.max ?? 100,
                changeMode: cfg.changeMode || 'manual',
                direction: cfg.direction || 'none'
            };
        }

        // Initialize contexts (they don't depend on spawn order)
        for (const ctx of this.getContexts()) {
            entity.contexts[ctx.id] = overrides.contexts?.[ctx.id] ?? ctx.config.default;
        }

        // Initialize all layer containers (needed before any rolls)
        for (const layer of this.getLayers()) {
            entity.layers[layer.id] = { active: [], lastRoll: null };
        }

        // Process spawnable nodes in spawn order
        // This allows traits that spawn early to influence attributes that spawn later
        const spawnOrder = this.getSpawnOrder();

        for (const item of spawnOrder) {
            if (item.type === 'attribute') {
                const attr = item.node;
                // Check if this attribute has an override
                if (overrides.attributes?.[attr.id] !== undefined) {
                    entity.attributes[attr.id] = overrides.attributes[attr.id];
                } else {
                    // Get range modified by any active traits
                    const range = this.getModifiedAttributeRange(entity, attr);
                    entity.attributes[attr.id] = this.rollRange(range.min, range.max, attr.config.precision);
                }
            } else if (item.type === 'layer') {
                const layer = item.node;
                const initialRolls = layer.config.selection?.initialRolls || 1;
                for (let i = 0; i < initialRolls; i++) {
                    this.rollLayer(entity, layer.id);
                }
            }
        }

        // Apply any remaining attribute overrides that weren't in spawn order
        // (for attributes that might not exist in config but are passed as overrides)
        if (overrides.attributes) {
            for (const [attrId, value] of Object.entries(overrides.attributes)) {
                if (entity.attributes[attrId] === undefined) {
                    entity.attributes[attrId] = value;
                }
            }
        }

        this.checkCompounds(entity);
        this.calculateDerived(entity);
        this.recalculateRates(entity);

        // Initialize action cooldowns
        for (const action of this.getActions()) {
            entity.actions[action.id] = { cooldownRemaining: 0 };
        }

        this.log(entity, 'generated', { overrides });
        return entity;
    }

    spawn(presetId, overrides = {}) {
        if (!this.entityManager) {
            console.warn('SpawnManager: No EntityManager linked, cannot spawn presets');
            return null;
        }

        const preset = this.entityManager.getPreset(presetId);
        if (!preset) {
            console.warn(`SpawnManager: Preset '${presetId}' not found`);
            return null;
        }

        const merged = {
            ...overrides,
            attributes: {
                ...this.resolvePresetAttributes(preset.attributes),
                ...this.resolvePresetAttributes(overrides.attributes)
            },
            contexts: { ...preset.contexts, ...overrides.contexts },
            forceTraits: [
                ...(preset.forceTraits || []),           // Legacy flat array
                ...this.resolvePresetTraits(preset.traits),  // New structured traits
                ...(overrides.forceTraits || []),
                ...this.resolvePresetTraits(overrides.traits)
            ]
        };

        const entity = this.generate(merged);

        for (const traitId of merged.forceTraits) {
            this.forceActivateTrait(entity, traitId);
        }

        entity.presetId = presetId;
        entity.name = overrides.name || preset.name;

        this.log(entity, 'spawned', { presetId, overrides });
        return entity;
    }

    spawnWhere(query, overrides = {}) {
        if (query.conditions && !this.evaluateSpawnConditions(query.conditions)) {
            return null;
        }

        if (query.preset) {
            return this.spawn(query.preset, overrides);
        }

        if (query.fromGroup && this.entityManager) {
            const group = this.entityManager.getGroup(query.fromGroup);
            if (!group || group.length === 0) return null;

            let candidates = group;
            if (query.where) {
                candidates = group.filter(e => this.matchesWhere(e, query.where));
            }
            if (candidates.length === 0) return null;

            const pick = query.pick || 'random';
            let selected;

            if (pick === 'random') {
                selected = candidates[Math.floor(Math.random() * candidates.length)];
            } else if (pick === 'first') {
                selected = candidates[0];
            } else if (pick === 'weighted' && query.weightBy) {
                selected = this.weightedPick(candidates, query.weightBy);
            }

            return this.cloneEntity(selected, overrides);
        }

        if (query.withTraits || query.withAttributes) {
            const entity = this.generate(overrides);
            if (query.withTraits) {
                for (const traitId of query.withTraits) {
                    this.forceActivateTrait(entity, traitId);
                }
            }
            return entity;
        }

        return this.generate(overrides);
    }

    evaluateSpawnConditions(conditions) {
        const context = this.entityManager?.getSpawnContext() || {};
        return this.evaluateConditionSet(conditions, context);
    }

    evaluateConditionSet(conditions, context) {
        if (!conditions) return true;
        if (conditions.all) {
            return conditions.all.every(c => this.evaluateConditionSet(c, context));
        }
        if (conditions.any) {
            return conditions.any.some(c => this.evaluateConditionSet(c, context));
        }
        if (conditions.not) {
            return !this.evaluateConditionSet(conditions.not, context);
        }

        const { target, operator, value } = conditions;
        const actual = this.getNestedValue(context, target);
        return this.compareValues(actual, operator, value);
    }

    matchesWhere(entity, where) {
        for (const [path, condition] of Object.entries(where)) {
            const actual = this.getNestedValue(entity, path);
            if (typeof condition === 'object') {
                for (const [op, value] of Object.entries(condition)) {
                    if (!this.compareValues(actual, op, value)) return false;
                }
            } else {
                if (actual !== condition) return false;
            }
        }
        return true;
    }

    getNestedValue(obj, path) {
        return path.split('.').reduce((curr, key) => curr?.[key], obj);
    }

    weightedPick(candidates, weightBy) {
        const weights = candidates.map(c => this.getNestedValue(c, weightBy) || 1);
        const total = weights.reduce((a, b) => a + b, 0);
        let roll = Math.random() * total;
        for (let i = 0; i < candidates.length; i++) {
            roll -= weights[i];
            if (roll <= 0) return candidates[i];
        }
        return candidates[0];
    }

    cloneEntity(entity, overrides = {}) {
        const clone = JSON.parse(JSON.stringify(entity));
        clone.id = `entity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        clone.createdAt = Date.now();
        clone.clonedFrom = entity.id;
        if (overrides.attributes) Object.assign(clone.attributes, overrides.attributes);
        if (overrides.contexts) Object.assign(clone.contexts, overrides.contexts);
        return clone;
    }

    // ========================================
    // LAYER SELECTION
    // ========================================

    rollLayer(entity, layerId) {
        const layer = this.getNode(layerId);
        if (!layer || layer.type !== 'layer') {
            return { success: false, error: 'Invalid layer' };
        }

        const selection = layer.config.selection || {};
        const mode = selection.mode || 'weighted';
        const maxItems = selection.maxItems ?? 10;

        const currentActive = entity.layers[layerId]?.active || [];
        if (currentActive.length >= maxItems) {
            return { success: false, error: 'Layer at capacity', maxItems };
        }

        let result;
        switch (mode) {
            case 'weighted': result = this.selectWeighted(entity, layerId); break;
            case 'allMatching': result = this.selectAllMatching(entity, layerId); break;
            case 'pickN': result = this.selectPickN(entity, layerId, selection.pickCount || 1); break;
            case 'firstMatch': result = this.selectFirstMatch(entity, layerId); break;
            default: result = this.selectWeighted(entity, layerId);
        }

        if (result.selected && result.selected.length > 0) {
            for (const traitId of result.selected) {
                this.activateTrait(entity, traitId);
            }
            entity.layers[layerId].lastRoll = Date.now();
        }

        return result;
    }

    /**
     * Roll an outcome layer - clears previous results and rolls fresh.
     * Use for layers with timing.rollAt = 'manual', like attack/defense outcomes.
     * @param {Object} entity - The entity to roll for
     * @param {string} layerId - The layer to roll
     * @param {number} [rolls=1] - Number of times to roll
     * @returns {Object} Result with selected items
     */
    rollOutcome(entity, layerId, rolls = 1) {
        const layer = this.getNode(layerId);
        if (!layer || layer.type !== 'layer') {
            return { success: false, error: 'Invalid layer' };
        }

        // Ensure the entity has this layer initialized
        if (!entity.layers[layerId]) {
            entity.layers[layerId] = { active: [], lastRoll: null };
        }

        // Clear previous active items from this layer
        const previousActive = [...(entity.layers[layerId].active || [])];
        for (const traitId of previousActive) {
            this.deactivateTrait(entity, traitId);
        }
        entity.layers[layerId].active = [];

        // Roll fresh
        const allSelected = [];
        for (let i = 0; i < rolls; i++) {
            const result = this.rollLayer(entity, layerId);
            if (result.success && result.selected) {
                allSelected.push(...result.selected);
            }
        }

        this.checkCompounds(entity);
        this.calculateDerived(entity);

        return {
            success: allSelected.length > 0,
            selected: allSelected,
            previousActive,
            layerId
        };
    }

    selectWeighted(entity, layerId) {
        const traits = this.getLayerTraits(layerId);
        const currentActive = new Set(entity.layers[layerId]?.active || []);

        const pool = [];
        for (const trait of traits) {
            if (currentActive.has(trait.id)) continue;
            if (trait.config.selection?.mode === 'threshold') continue;
            if (!this.checkEligibility(entity, trait)) continue;
            if (this.hasIncompatibility(entity, trait)) continue;

            const weight = this.calculateWeight(entity, trait);
            if (weight > 0) pool.push({ trait, weight });
        }

        if (pool.length === 0) {
            return { success: false, error: 'No eligible traits', pool: [] };
        }

        const totalWeight = pool.reduce((sum, p) => sum + p.weight, 0);
        let roll = Math.random() * totalWeight;

        for (const { trait, weight } of pool) {
            roll -= weight;
            if (roll <= 0) {
                return {
                    success: true,
                    selected: [trait.id],
                    pool: pool.map(p => ({ id: p.trait.id, weight: p.weight }))
                };
            }
        }

        return { success: true, selected: [pool[0].trait.id], pool };
    }

    selectAllMatching(entity, layerId) {
        const traits = this.getLayerTraits(layerId);
        const currentActive = new Set(entity.layers[layerId]?.active || []);
        const selected = [];

        for (const trait of traits) {
            if (currentActive.has(trait.id)) continue;
            if (!this.checkEligibility(entity, trait)) continue;
            if (this.hasIncompatibility(entity, trait)) continue;
            selected.push(trait.id);
        }

        return { success: true, selected };
    }

    selectPickN(entity, layerId, n) {
        const result = this.selectWeighted(entity, layerId);
        if (!result.pool || result.pool.length === 0) {
            return { success: false, error: 'No eligible traits' };
        }

        const selected = [];
        const remainingPool = [...result.pool];

        for (let i = 0; i < n && remainingPool.length > 0; i++) {
            const totalWeight = remainingPool.reduce((sum, p) => sum + p.weight, 0);
            let roll = Math.random() * totalWeight;

            for (let j = 0; j < remainingPool.length; j++) {
                roll -= remainingPool[j].weight;
                if (roll <= 0) {
                    selected.push(remainingPool[j].id);
                    remainingPool.splice(j, 1);
                    break;
                }
            }
        }

        return { success: true, selected };
    }

    selectFirstMatch(entity, layerId) {
        const traits = this.getLayerTraits(layerId);
        const currentActive = new Set(entity.layers[layerId]?.active || []);

        for (const trait of traits) {
            if (currentActive.has(trait.id)) continue;
            if (!this.checkEligibility(entity, trait)) continue;
            if (this.hasIncompatibility(entity, trait)) continue;
            return { success: true, selected: [trait.id] };
        }

        return { success: false, error: 'No matching traits' };
    }

    // ========================================
    // WEIGHT & ELIGIBILITY
    // ========================================

    calculateWeight(entity, trait) {
        const selection = trait.config.selection || {};
        let weight = selection.baseWeight ?? 20;
        const baseWeight = weight;

        // Get layer config for diminishing returns / weight floor
        const layerNode = trait.config.layerId ? this.getNode(trait.config.layerId) : null;
        const layerSelection = layerNode?.config?.selection || {};
        const useDR = layerSelection.diminishingReturns === true;

        for (const mod of selection.weightModifiers || []) {
            if (this.evaluateCondition(entity, mod.condition)) {
                if (mod.operation === 'add') {
                    let effect = mod.value;
                    if (useDR && effect !== 0) {
                        effect = Math.sign(effect) * Math.sqrt(Math.abs(effect)) * Math.sqrt(baseWeight);
                    }
                    weight += effect;
                } else if (mod.operation === 'multiply') {
                    weight *= mod.value;
                }
            }
        }

        const influences = this.getRelationshipsTo(trait.id)
            .filter(r => r.type === 'weight_influence');

        for (const rel of influences) {
            if (!this.isNodeActive(entity, rel.sourceId)) continue;
            if (!this.evaluateConditions(entity, rel.conditions)) continue;

            let value = this.calculateRelationshipValue(entity, rel);
            if (rel.config.operation === 'add') {
                if (useDR && value !== 0) {
                    value = Math.sign(value) * Math.sqrt(Math.abs(value)) * Math.sqrt(baseWeight);
                }
                weight += value;
            } else if (rel.config.operation === 'multiply') {
                weight *= value;
            }
        }

        const weightFloor = layerSelection.weightFloor ?? 0;
        return Math.max(weightFloor, weight);
    }

    calculateRelationshipValue(entity, rel) {
        let value = rel.config.value;
        if (rel.config.scaling === 'perPoint' && rel.config.perPointSource) {
            let sourceValue = this.getNodeValue(entity, rel.config.perPointSource);

            // Invert: use (max - value) instead of value directly
            // Useful for "low sociability = high introvert chance" type relationships
            if (rel.config.invert) {
                const sourceNode = this.getNode(rel.config.perPointSource);
                const max = sourceNode?.config?.max ?? 10;
                sourceValue = max - sourceValue;
            }

            value = value * sourceValue;
        }
        return value;
    }

    checkEligibility(entity, trait) {
        const eligibility = trait.config.eligibility || [];
        return this.evaluateConditions(entity, eligibility);
    }

    hasIncompatibility(entity, trait) {
        const incompatible = trait.config.incompatibleWith || [];
        for (const incompId of incompatible) {
            if (this.isNodeActive(entity, incompId)) return true;
        }
        return false;
    }

    // ========================================
    // TRAIT ACTIVATION
    // ========================================

    activateTrait(entity, traitId) {
        const trait = this.getNode(traitId);
        if (!trait || !this.isTrait(trait)) return false;

        const layerId = trait.config.layerId;
        if (!entity.layers[layerId]) {
            entity.layers[layerId] = { active: [], lastRoll: null };
        }

        if (entity.layers[layerId].active.includes(traitId)) return false;

        const replaces = trait.config.selection?.replaces || [];
        for (const replaceId of replaces) {
            this.deactivateTrait(entity, replaceId);
        }

        entity.layers[layerId].active.push(traitId);
        this.log(entity, 'traitActivated', { traitId, layerId });
        return true;
    }

    // Backward compatibility
    activateItem(entity, itemId) { return this.activateTrait(entity, itemId); }

    forceActivateTrait(entity, traitId) {
        const trait = this.getNode(traitId);
        if (!trait || !this.isTrait(trait)) return false;

        const layerId = trait.config.layerId;
        if (!entity.layers[layerId]) {
            entity.layers[layerId] = { active: [], lastRoll: null };
        }

        if (!entity.layers[layerId].active.includes(traitId)) {
            entity.layers[layerId].active.push(traitId);
        }
        return true;
    }

    deactivateTrait(entity, traitId) {
        const trait = this.getNode(traitId);
        if (!trait || !this.isTrait(trait)) return false;

        const layerId = trait.config.layerId;
        if (!entity.layers[layerId]) return false;

        const index = entity.layers[layerId].active.indexOf(traitId);
        if (index === -1) return false;

        entity.layers[layerId].active.splice(index, 1);
        return true;
    }

    // Backward compatibility
    deactivateItem(entity, itemId) { return this.deactivateTrait(entity, itemId); }

    // ========================================
    // COMPOUNDS & DERIVED
    // ========================================

    checkCompounds(entity) {
        for (const compound of this.getCompounds()) {
            const isActive = entity.compounds.includes(compound.id);
            const requirementsMet = this.checkCompoundRequirements(entity, compound);

            if (requirementsMet && !isActive) {
                entity.compounds.push(compound.id);
            } else if (!requirementsMet && isActive) {
                const index = entity.compounds.indexOf(compound.id);
                if (index > -1) entity.compounds.splice(index, 1);
            }
        }
    }

    checkCompoundRequirements(entity, compound) {
        const requires = compound.config.requires || [];
        const logic = compound.config.requirementLogic || 'all';

        if (requires.length === 0) return false;

        const results = requires.map(req => {
            // Handle string format (just node ID)
            if (typeof req === 'string') {
                return this.isNodeActive(entity, req);
            }

            // Handle threshold condition (object with id + operator + value)
            if (req.id && req.operator && req.value !== undefined) {
                const nodeValue = this.getNodeValue(entity, req.id);
                if (nodeValue === null || nodeValue === undefined) return false;
                return this.compareValues(nodeValue, req.operator, req.value);
            }

            // Handle legacy object formats
            if (req.item || req.trait) {
                return this.isNodeActive(entity, req.item || req.trait);
            } else if (req.modifier) {
                return entity.modifiers.includes(req.modifier);
            } else if (req.condition) {
                return this.evaluateCondition(entity, req.condition);
            } else if (req.id) {
                // Simple object with just id (no threshold)
                return this.isNodeActive(entity, req.id);
            }
            return false;
        });

        return logic === 'all' ? results.every(r => r) : results.some(r => r);
    }

    /**
     * Get the current numeric value of a node (attribute or variable).
     * @param {Object} entity - The entity to check
     * @param {string} nodeId - The node ID to get value from
     * @returns {number|null} The current value, or null if not found
     */
    getNodeValue(entity, nodeId) {
        // Check attributes
        if (entity.attributes && entity.attributes[nodeId] !== undefined) {
            return entity.attributes[nodeId];
        }
        // Check variables
        if (entity.variables && entity.variables[nodeId]) {
            return entity.variables[nodeId].value;
        }
        // Check derived
        if (entity.derived && entity.derived[nodeId] !== undefined) {
            return entity.derived[nodeId];
        }
        return null;
    }

    /**
     * Compare two values using a comparison operator.
     * @param {number} a - Left operand
     * @param {string} operator - Comparison operator (<, <=, >, >=, =)
     * @param {number} b - Right operand
     * @returns {boolean} Result of comparison
     */
    compareValues(a, operator, b) {
        switch (operator) {
            case '<': return a < b;
            case '<=': return a <= b;
            case '>': return a > b;
            case '>=': return a >= b;
            case '=':
            case '==':
            case '===': return a === b;
            default: return false;
        }
    }

    calculateDerived(entity) {
        for (const derived of this.getDerived()) {
            const cfg = derived.config;
            const formula = cfg.formula;

            try {
                const context = {
                    ...entity.attributes,
                    ...Object.fromEntries(
                        Object.entries(entity.variables).map(([k, v]) => [k, v.value])
                    ),
                    ...entity.contexts
                };

                const value = this.evaluateFormula(formula, context);
                entity.derived[derived.id] = Math.max(
                    cfg.min ?? -Infinity,
                    Math.min(cfg.max ?? Infinity, value)
                );
            } catch (e) {
                entity.derived[derived.id] = 0;
            }
        }
    }

    recalculateRates(entity) {
        for (const varNode of this.getVariables()) {
            const varState = entity.variables[varNode.id];
            if (!varState) continue;

            let rate = varState.baseRate;

            const rateRels = this.getRelationshipsTo(varNode.id)
                .filter(r => r.type === 'rate_modifier');

            for (const rel of rateRels) {
                if (!this.isNodeActive(entity, rel.sourceId)) continue;
                if (!this.evaluateConditions(entity, rel.conditions)) continue;

                const value = this.calculateRelationshipValue(entity, rel);
                if (rel.config.operation === 'add') rate += value;
                else if (rel.config.operation === 'multiply') rate *= value;
            }

            varState.currentRate = rate;
        }
    }

    // ========================================
    // CONDITION EVALUATION
    // ========================================

    evaluateConditions(entity, conditions) {
        if (!conditions || conditions.length === 0) return true;
        return conditions.every(cond => this.evaluateCondition(entity, cond));
    }

    evaluateCondition(entity, condition) {
        if (!condition) return true;

        if (condition.all) {
            return condition.all.every(c => this.evaluateCondition(entity, c));
        }
        if (condition.any) {
            return condition.any.some(c => this.evaluateCondition(entity, c));
        }
        if (condition.not) {
            return !this.evaluateCondition(entity, condition.not);
        }

        const { type, target, operator, value } = condition;
        let actualValue;

        switch (type) {
            case 'attribute': actualValue = entity.attributes[target]; break;
            case 'variable': actualValue = entity.variables[target]?.value; break;
            case 'context': actualValue = entity.contexts[target]; break;
            case 'trait':
            case 'item':
                return this.isNodeActive(entity, target);
            case 'modifier': return entity.modifiers.includes(target);
            case 'compound': return entity.compounds.includes(target);
            default: return false;
        }

        return this.compareValues(actualValue, operator, value);
    }

    compareValues(actual, operator, expected) {
        switch (operator) {
            case '<': case 'lt': return actual < expected;
            case '<=': case 'lte': return actual <= expected;
            case '>': case 'gt': return actual > expected;
            case '>=': case 'gte': return actual >= expected;
            case '==': case 'eq': return actual == expected;
            case '===': return actual === expected;
            case '!=': case 'ne': return actual != expected;
            case '!==': return actual !== expected;
            case 'in': return Array.isArray(expected) && expected.includes(actual);
            case 'includes': return Array.isArray(actual) && actual.includes(expected);
            default: return false;
        }
    }

    // ========================================
    // NODE STATE HELPERS
    // ========================================

    getNodeValue(entity, nodeId) {
        const node = this.getNode(nodeId);
        if (!node) return 0;

        switch (node.type) {
            case 'attribute': return entity.attributes[nodeId] ?? 0;
            case 'variable': return entity.variables[nodeId]?.value ?? 0;
            case 'context': return entity.contexts[nodeId] ?? 0;
            default: return 0;
        }
    }

    isNodeActive(entity, nodeId) {
        const node = this.getNode(nodeId);
        if (!node) return false;

        if (this.isTrait(node)) {
            const layerId = node.config.layerId;
            return entity.layers[layerId]?.active?.includes(nodeId) || false;
        }

        switch (node.type) {
            case 'modifier': return entity.modifiers.includes(nodeId);
            case 'compound': return entity.compounds.includes(nodeId);
            case 'attribute':
            case 'variable':
            case 'context':
                return true;
            default: return false;
        }
    }

    // ========================================
    // UTILITIES
    // ========================================

    rollRange(min, max, precision = 0) {
        const value = min + Math.random() * (max - min);
        if (precision === 0) return Math.round(value);
        const factor = Math.pow(10, precision);
        return Math.round(value * factor) / factor;
    }

    /**
     * Resolve a preset attribute value to a concrete number.
     * Supports fixed values, min/max ranges, and base +/- variance.
     *
     * @param {number|Object} attrValue - The attribute specification
     * @param {number} [precision=0] - Decimal precision
     * @returns {number} Resolved value
     * @example
     * // Fixed value
     * resolvePresetAttributeValue(6) // => 6
     *
     * // Min/max range (uniform random)
     * resolvePresetAttributeValue({ min: 5, max: 10 }) // => 5-10
     *
     * // Base with variance
     * resolvePresetAttributeValue({ base: 50, variance: 10 }) // => 40-60
     */
    resolvePresetAttributeValue(attrValue, precision = 0) {
        if (typeof attrValue === 'number') {
            return attrValue;  // Fixed value
        }
        if (typeof attrValue === 'object' && attrValue !== null) {
            // Min/max range
            if (attrValue.min !== undefined && attrValue.max !== undefined) {
                return this.rollRange(attrValue.min, attrValue.max, precision);
            }
            // Base with variance
            if (attrValue.base !== undefined) {
                const variance = attrValue.variance || 0;
                return this.rollRange(attrValue.base - variance, attrValue.base + variance, precision);
            }
            // Object with just 'value' property (explicit fixed)
            if (attrValue.value !== undefined) {
                return attrValue.value;
            }
        }
        return 0;  // Fallback
    }

    /**
     * Resolve all preset attribute values to concrete numbers.
     *
     * @param {Object} attributes - Map of attributeId to value specification
     * @returns {Object} Map of attributeId to resolved numeric values
     */
    resolvePresetAttributes(attributes) {
        if (!attributes) return {};
        const resolved = {};
        for (const [attrId, value] of Object.entries(attributes)) {
            const attrNode = this.getNode(attrId);
            const precision = attrNode?.config?.precision ?? 0;
            resolved[attrId] = this.resolvePresetAttributeValue(value, precision);
        }
        return resolved;
    }

    /**
     * Resolve preset trait selections to concrete trait IDs.
     * Supports multiple selection modes per layer.
     *
     * @param {Object} traits - Map of layerId to trait selection specification
     * @returns {string[]} Array of trait IDs to force-activate
     * @example
     * // String: always force
     * resolvePresetTraits({ layer_race: 'item_humanoid' })
     *
     * // Weighted pool
     * resolvePresetTraits({
     *   layer_behavior: {
     *     mode: 'weighted',
     *     pool: [{ id: 'item_aggressive', weight: 70 }, { id: 'item_tactical', weight: 30 }]
     *   }
     * })
     *
     * // Chance-based
     * resolvePresetTraits({
     *   layer_resistance: { mode: 'chance', chance: 0.3, pool: ['item_fire_resist'] }
     * })
     *
     * // Pick N
     * resolvePresetTraits({
     *   layer_skills: { mode: 'pickN', count: 2, pool: ['skill_a', 'skill_b', 'skill_c'] }
     * })
     */
    resolvePresetTraits(traits) {
        if (!traits) return [];
        const resolved = [];

        for (const [layerId, spec] of Object.entries(traits)) {
            // String: always force this trait
            if (typeof spec === 'string') {
                resolved.push(spec);
                continue;
            }

            // Array: force all traits in array
            if (Array.isArray(spec)) {
                resolved.push(...spec);
                continue;
            }

            // Object: mode-based selection
            if (typeof spec === 'object' && spec !== null) {
                const mode = spec.mode || 'weighted';
                let pool = spec.pool || [];

                // If taxonomyFilter is specified, build pool from matching nodes
                if (spec.taxonomyFilter && Object.keys(spec.taxonomyFilter).length > 0) {
                    const matchingNodes = this.getNodesByTaxonomy(spec.taxonomyFilter);
                    // Filter to only items/traits that belong to this layer
                    const layer = this.getNode(layerId);
                    const layerItemIds = new Set(layer?.config?.itemIds || layer?.config?.traitIds || []);
                    pool = matchingNodes
                        .filter(n => layerItemIds.has(n.id))
                        .map(n => ({ id: n.id, weight: n.config?.selection?.baseWeight || 1 }));
                }

                if (pool.length === 0) continue;

                switch (mode) {
                    case 'weighted': {
                        const picked = this.selectWeightedFromPool(pool);
                        if (picked) resolved.push(picked);
                        break;
                    }

                    case 'chance': {
                        const chance = spec.chance ?? 0.5;
                        if (Math.random() < chance) {
                            // Pick one randomly from pool
                            const idx = Math.floor(Math.random() * pool.length);
                            const item = pool[idx];
                            resolved.push(typeof item === 'string' ? item : item.id);
                        }
                        break;
                    }

                    case 'pickN': {
                        const count = spec.count ?? 1;
                        const picks = this.selectNFromPool(pool, count);
                        resolved.push(...picks);
                        break;
                    }

                    case 'all': {
                        // Force all traits in pool
                        for (const item of pool) {
                            resolved.push(typeof item === 'string' ? item : item.id);
                        }
                        break;
                    }

                    default:
                        // Unknown mode, treat as weighted
                        const picked = this.selectWeightedFromPool(pool);
                        if (picked) resolved.push(picked);
                }
            }
        }

        return resolved;
    }

    /**
     * Select one item from a weighted pool.
     *
     * @param {Array} pool - Array of items (strings or {id, weight} objects)
     * @returns {string|null} Selected item ID or null if pool is empty
     */
    selectWeightedFromPool(pool) {
        if (!pool || pool.length === 0) return null;

        const total = pool.reduce((sum, item) => {
            const weight = typeof item === 'string' ? 1 : (item.weight ?? 1);
            return sum + weight;
        }, 0);

        let roll = Math.random() * total;

        for (const item of pool) {
            const weight = typeof item === 'string' ? 1 : (item.weight ?? 1);
            roll -= weight;
            if (roll <= 0) {
                return typeof item === 'string' ? item : item.id;
            }
        }

        // Fallback to first item
        const first = pool[0];
        return typeof first === 'string' ? first : first.id;
    }

    /**
     * Select N items from a weighted pool without replacement.
     *
     * @param {Array} pool - Array of items (strings or {id, weight} objects)
     * @param {number} n - Number of items to select
     * @returns {string[]} Array of selected item IDs
     */
    selectNFromPool(pool, n) {
        if (!pool || pool.length === 0) return [];

        const remaining = [...pool];
        const picks = [];

        for (let i = 0; i < n && remaining.length > 0; i++) {
            const total = remaining.reduce((sum, item) => {
                const weight = typeof item === 'string' ? 1 : (item.weight ?? 1);
                return sum + weight;
            }, 0);

            let roll = Math.random() * total;

            for (let j = 0; j < remaining.length; j++) {
                const item = remaining[j];
                const weight = typeof item === 'string' ? 1 : (item.weight ?? 1);
                roll -= weight;
                if (roll <= 0) {
                    const picked = remaining.splice(j, 1)[0];
                    picks.push(typeof picked === 'string' ? picked : picked.id);
                    break;
                }
            }
        }

        return picks;
    }

    evaluateFormula(formula, context) {
        const keys = Object.keys(context);
        const values = Object.values(context);

        let cached = this._formulaCache.get(formula);
        if (!cached || cached.keys.length !== keys.length || !cached.keys.every((k, i) => k === keys[i])) {
            const fn = new Function(...keys, `return ${formula}`);
            cached = { fn, keys: [...keys] };
            this._formulaCache.set(formula, cached);
        }

        return cached.fn(...values);
    }

    // ========================================
    // ACTION SYSTEM
    // ========================================

    /**
     * Check if an action is available for an entity.
     *
     * @param {Object} entity - The entity
     * @param {string} actionId - The action ID
     * @returns {boolean} True if action can be used
     */
    isActionAvailable(entity, actionId) {
        const action = this.getNode(actionId);
        if (!action || action.type !== 'action') return false;

        const cfg = action.config || {};

        // Check cooldown
        if (entity.actions?.[actionId]?.cooldownRemaining > 0) return false;

        // Check costs (can afford?)
        for (const [varId, cost] of Object.entries(cfg.costs || {})) {
            const varState = entity.variables[varId];
            if (!varState || varState.value < cost) return false;
        }

        // Check requirements (traits that must be active)
        for (const reqId of cfg.requirements || []) {
            if (!this.isNodeActive(entity, reqId)) return false;
        }

        // Check blockedBy (traits that prevent use)
        for (const blockId of cfg.blockedBy || []) {
            if (this.isNodeActive(entity, blockId)) return false;
        }

        // Check eligibility conditions
        if (cfg.eligibility && !this.evaluateConditions(entity, cfg.eligibility)) {
            return false;
        }

        return true;
    }

    /**
     * Get all available actions for an entity with calculated weights.
     *
     * @param {Object} entity - The entity
     * @returns {Array<{id: string, weight: number, action: Object}>} Available actions
     */
    getAvailableActions(entity) {
        const available = [];

        for (const action of this.getActions()) {
            if (!this.isActionAvailable(entity, action.id)) continue;

            let weight = action.config?.baseWeight ?? 50;

            // Apply preset action weights if entity has preset
            if (entity.presetId && this.entityManager) {
                const preset = this.entityManager.getPreset(entity.presetId);
                if (preset?.actions?.[action.id]) {
                    const presetAction = preset.actions[action.id];
                    if (typeof presetAction === 'number') {
                        weight = presetAction;
                    } else if (presetAction.weight !== undefined) {
                        // Check condition if specified
                        if (presetAction.condition) {
                            if (this.evaluateCondition(entity, presetAction.condition)) {
                                weight = presetAction.weight;
                            }
                        } else {
                            weight = presetAction.weight;
                        }
                    }
                }
            }

            // Apply relationship weight modifiers
            const influences = this.getRelationshipsTo(action.id)
                .filter(r => r.type === 'weight_influence');
            for (const rel of influences) {
                if (!this.isNodeActive(entity, rel.sourceId)) continue;
                if (!this.evaluateConditions(entity, rel.conditions)) continue;

                const value = this.calculateRelationshipValue(entity, rel);
                if (rel.config.operation === 'add') weight += value;
                else if (rel.config.operation === 'multiply') weight *= value;
            }

            if (weight > 0) {
                available.push({ id: action.id, weight, action });
            }
        }

        return available;
    }

    /**
     * Select an action using weighted random selection.
     *
     * @param {Object} entity - The entity
     * @returns {Object|null} Selected action {id, weight, action} or null
     */
    selectAction(entity) {
        const available = this.getAvailableActions(entity);
        if (available.length === 0) return null;

        const total = available.reduce((sum, a) => sum + a.weight, 0);
        let roll = Math.random() * total;

        for (const a of available) {
            roll -= a.weight;
            if (roll <= 0) return a;
        }

        return available[0];
    }

    /**
     * Execute an action, deducting costs and starting cooldown.
     *
     * @param {Object} entity - The entity
     * @param {string} actionId - The action ID
     * @returns {Object} Result {success, actionId, effects, action} or {success: false, reason}
     */
    executeAction(entity, actionId) {
        if (!this.isActionAvailable(entity, actionId)) {
            return { success: false, reason: 'Action not available' };
        }

        const action = this.getNode(actionId);
        const cfg = action.config || {};

        // Deduct costs
        for (const [varId, cost] of Object.entries(cfg.costs || {})) {
            if (entity.variables[varId]) {
                entity.variables[varId].value = Math.max(
                    entity.variables[varId].min,
                    entity.variables[varId].value - cost
                );
            }
        }

        // Start cooldown
        if (!entity.actions) entity.actions = {};
        if (!entity.actions[actionId]) entity.actions[actionId] = {};
        entity.actions[actionId].cooldownRemaining = cfg.cooldown || 0;

        this.log(entity, 'actionExecuted', { actionId });

        // Return action data for game code to handle effects
        return {
            success: true,
            actionId,
            effects: cfg.effects || {},
            action
        };
    }

    /**
     * Get action cooldown status for an entity.
     *
     * @param {Object} entity - The entity
     * @param {string} actionId - The action ID
     * @returns {Object} {cooldownRemaining, cooldownTotal, ready}
     */
    getActionCooldown(entity, actionId) {
        const action = this.getNode(actionId);
        const cooldownTotal = action?.config?.cooldown || 0;
        const cooldownRemaining = entity.actions?.[actionId]?.cooldownRemaining || 0;

        return {
            cooldownRemaining,
            cooldownTotal,
            ready: cooldownRemaining <= 0
        };
    }

    log(entity, event, data = {}) {
        entity._internal.log.push({ timestamp: Date.now(), event, data });
        if (entity._internal.log.length > 1000) {
            entity._internal.log = entity._internal.log.slice(-500);
        }
    }

    // ========================================
    // ANALYSIS (for editor)
    // ========================================

    getWeights(entity, layerId) {
        const traits = this.getLayerTraits(layerId);
        const currentActive = new Set(entity?.layers[layerId]?.active || []);

        const result = [];
        for (const trait of traits) {
            const isActive = currentActive.has(trait.id);
            const isThreshold = trait.config.selection?.mode === 'threshold';
            const isEligible = entity ? this.checkEligibility(entity, trait) : true;
            const hasIncompat = entity ? this.hasIncompatibility(entity, trait) : false;
            const weight = entity ? this.calculateWeight(entity, trait) : trait.config.selection?.baseWeight ?? 20;

            result.push({
                id: trait.id,
                name: trait.name,
                isActive, isThreshold, isEligible, hasIncompat, weight,
                baseWeight: trait.config.selection?.baseWeight ?? 20
            });
        }

        const eligibleWeight = result
            .filter(r => !r.isActive && !r.isThreshold && r.isEligible && !r.hasIncompat && r.weight > 0)
            .reduce((sum, r) => sum + r.weight, 0);

        for (const r of result) {
            r.percentage = eligibleWeight > 0 ? (r.weight / eligibleWeight) * 100 : 0;
        }

        return result;
    }

    previewInfluences(nodeId) {
        const incoming = this.getRelationshipsTo(nodeId);
        const outgoing = this.getRelationshipsFrom(nodeId);

        return {
            incoming: incoming.map(r => ({
                ...r,
                sourceName: this.getNode(r.sourceId)?.name || r.sourceId
            })),
            outgoing: outgoing.map(r => ({
                ...r,
                targetName: this.getNode(r.targetId)?.name || r.targetId
            }))
        };
    }
}


// ============================================================================
// ENTITY MANAGER - Storage & Runtime State
// ============================================================================

/**
 * Runtime state manager for entities.
 * Handles storage, activation, ticking, modifiers, and events.
 * Works with SpawnManager for generation or can be used standalone.
 *
 * @class EntityManager
 * @fires EntityManager#variableChanged - When a variable value changes
 * @fires EntityManager#modifierApplied - When a modifier is applied
 * @fires EntityManager#modifierRemoved - When a modifier is removed
 * @fires EntityManager#compoundActivated - When a compound becomes active
 * @fires EntityManager#compoundDeactivated - When a compound becomes inactive
 * @fires EntityManager#entityStored - When an entity is stored
 * @fires EntityManager#entityActivated - When an entity is activated
 * @fires EntityManager#entityRemoved - When an entity is removed
 * @example
 * const manager = new EntityManager();
 * manager.store(entity);
 * manager.activate(entity.id);
 * manager.tick(entity.id, 1); // Tick for 1 second
 */
class EntityManager {
    /**
     * Create a new EntityManager instance.
     *
     * @param {SpawnManager|null} [spawnManager=null] - SpawnManager to link for generation
     */
    constructor(spawnManager = null) {
        /** @type {SpawnManager|null} Linked SpawnManager */
        this.spawnManager = spawnManager;
        /** @type {Map<string, Object>} Registered presets */
        this.presets = new Map();
        /** @type {Map<string, Object>} Preset groups */
        this.presetGroups = new Map();
        /** @type {Map<string, Object>} Entity groups */
        this.groups = new Map();
        /** @type {Map<string, Object>} All stored entities */
        this.stored = new Map();
        /** @type {Map<string, Object>} Currently active entities */
        this.active = new Map();
        /** @type {Map<string, Array>} Entity state history */
        this.history = new Map();
        /** @type {Object} Global spawn context */
        this.spawnContext = {};
        /** @type {Object} Manager configuration */
        this.config = {
            tickRate: 1000,
            maxHistory: 50,
            maxEntities: null
        };
        /** @type {number|null} Auto-tick interval ID */
        this.tickInterval = null;
        /** @type {Map<string, Set>} Event listeners */
        this.listeners = new Map();
        /** @type {boolean} When true, cascade recalculations are deferred */
        this._batchingCascade = false;
        /** @type {boolean} Dirty flag for deferred cascade */
        this._cascadeDirty = false;
        /** @type {Object|null} Entity reference for deferred cascade */
        this._cascadeEntity = null;

        // ========================================
        // ENTITY POOLING (Multi-Pool System)
        // ========================================

        /** @type {Map<string, Object>} Named pools registry */
        this.pools = new Map();
        /** @type {string} Default pool ID for backward compatibility */
        this.defaultPoolId = 'default';

        // Legacy single-pool references (for backward compatibility)
        // These now proxy to the default pool
        /** @type {Array<Object>} @deprecated Use pools.get('default').entities instead */
        this.pool = [];
        /** @type {Object} @deprecated Use pools.get('default').config instead */
        this.poolConfig = {
            maxSize: 100,
            preWarm: 0,
            preWarmPreset: null,
            shrinkThreshold: 0.5,
            shrinkDelay: 30000
        };
        /** @type {Object} @deprecated Use pools.get('default').stats instead */
        this.poolStats = {
            size: 0,
            available: 0,
            inUse: 0,
            totalAcquired: 0,
            totalReleased: 0,
            totalCreated: 0
        };
        /** @type {number|null} Shrink timeout ID */
        this._shrinkTimeout = null;

        // Initialize default pool
        this._initDefaultPool();
    }

    /**
     * Initialize the default pool for backward compatibility.
     * @private
     */
    _initDefaultPool() {
        this.pools.set(this.defaultPoolId, {
            id: this.defaultPoolId,
            name: 'Default Pool',
            description: 'Default entity pool',
            config: { ...this.poolConfig },
            stats: { ...this.poolStats },
            entities: this.pool, // Share array reference for backward compat
            rules: null, // Default pool catches all unmatched entities
            _shrinkTimeout: null
        });
    }

    /**
     * Link a SpawnManager for generation integration.
     *
     * @param {SpawnManager} spawnManager - The SpawnManager to link
     * @returns {EntityManager} This instance for chaining
     */
    linkSpawnManager(spawnManager) {
        this.spawnManager = spawnManager;
        spawnManager.linkEntityManager(this);
        return this;
    }

    // ========================================
    // PRESETS
    // ========================================

    /**
     * Register a spawn preset template.
     *
     * @param {string} id - Unique preset ID
     * @param {Object} template - Preset template
     * @param {string} [template.name] - Display name
     * @param {Object} [template.attributes] - Attribute overrides
     * @param {string[]} [template.forceTraits] - Traits to force-activate
     * @returns {EntityManager} This instance for chaining
     * @fires EntityManager#presetRegistered
     * @example
     * manager.registerPreset('tavern_regular', {
     *   name: 'Regular Patron',
     *   attributes: { patience: 5 },
     *   forceTraits: ['trait_social']
     * });
     */
    registerPreset(id, template) {
        this.presets.set(id, {
            id,
            name: template.name || id,
            description: template.description || '',
            attributes: template.attributes || {},
            contexts: template.contexts || {},
            forceTraits: template.forceTraits || [],
            tags: template.tags || [],
            ...template
        });
        this.emit('presetRegistered', { id, template });
        return this;
    }

    registerPresets(presets) {
        for (const [id, template] of Object.entries(presets)) {
            this.registerPreset(id, template);
        }
        return this;
    }

    getPreset(id) { return this.presets.get(id) || null; }

    listPresets(filter = null) {
        let presets = Array.from(this.presets.values());
        if (filter) {
            if (filter.group) {
                presets = presets.filter(p => p.group === filter.group);
            }
            if (filter.tags) {
                presets = presets.filter(p => filter.tags.some(tag => p.tags.includes(tag)));
            }
            if (filter.taxonomy) {
                presets = presets.filter(p => {
                    if (!p.taxonomy) return false;
                    return Object.entries(filter.taxonomy).every(([k, v]) => p.taxonomy[k] === v);
                });
            }
            if (filter.search) {
                const search = filter.search.toLowerCase();
                presets = presets.filter(p =>
                    p.name.toLowerCase().includes(search) || p.id.toLowerCase().includes(search)
                );
            }
        }
        return presets;
    }

    /**
     * Get presets matching a taxonomy filter.
     *
     * @param {Object} filter - Taxonomy criteria to match
     * @returns {Array<Object>} Presets matching all criteria
     * @example
     * manager.getPresetsByTaxonomy({ type: 'humanoid' });
     */
    getPresetsByTaxonomy(filter) {
        return this.listPresets({ taxonomy: filter });
    }

    removePreset(id) {
        const existed = this.presets.delete(id);
        if (existed) this.emit('presetRemoved', { id });
        return existed;
    }

    // ========================================
    // PRESET GROUPS
    // ========================================

    registerPresetGroup(id, metadata = {}) {
        this.presetGroups.set(id, {
            id,
            name: metadata.name || id,
            description: metadata.description || ''
        });
        this.emit('presetGroupRegistered', { id, metadata });
        return this;
    }

    getPresetGroup(id) { return this.presetGroups.get(id) || null; }

    listPresetGroups() {
        return Array.from(this.presetGroups.values());
    }

    listPresetsByGroup(groupId) {
        return Array.from(this.presets.values()).filter(p => p.group === groupId);
    }

    removePresetGroup(id) {
        const existed = this.presetGroups.delete(id);
        if (existed) this.emit('presetGroupRemoved', { id });
        return existed;
    }

    // ========================================
    // GROUPS (Entity Groups)
    // ========================================

    createGroup(groupId, metadata = {}) {
        if (!this.groups.has(groupId)) {
            this.groups.set(groupId, {
                id: groupId,
                name: metadata.name || groupId,
                description: metadata.description || '',
                entities: new Set(),
                ...metadata
            });
            this.emit('groupCreated', { groupId, metadata });
        }
        return this;
    }

    addToGroup(groupId, entityId) {
        if (!this.groups.has(groupId)) this.createGroup(groupId);
        this.groups.get(groupId).entities.add(entityId);
        this.emit('addedToGroup', { groupId, entityId });
        return this;
    }

    removeFromGroup(groupId, entityId) {
        const group = this.groups.get(groupId);
        if (group) {
            group.entities.delete(entityId);
            this.emit('removedFromGroup', { groupId, entityId });
        }
        return this;
    }

    getGroup(groupId) {
        const group = this.groups.get(groupId);
        if (!group) return [];
        return Array.from(group.entities)
            .map(id => this.stored.get(id) || this.active.get(id))
            .filter(Boolean);
    }

    getGroupInfo(groupId) { return this.groups.get(groupId) || null; }

    listGroups() {
        return Array.from(this.groups.values()).map(g => ({
            id: g.id, name: g.name, description: g.description, count: g.entities.size
        }));
    }

    deleteGroup(groupId) {
        const existed = this.groups.delete(groupId);
        if (existed) this.emit('groupDeleted', { groupId });
        return existed;
    }

    // ========================================
    // STORAGE
    // ========================================

    store(entity, options = {}) {
        if (this.config.maxEntities !== null && this.stored.size >= this.config.maxEntities) {
            this.emit('storageLimitReached', { limit: this.config.maxEntities });
            return null;
        }

        this.stored.set(entity.id, entity);

        if (options.groups) {
            for (const groupId of options.groups) {
                this.addToGroup(groupId, entity.id);
            }
        }

        if (entity.configId) {
            this.addToGroup(`config:${entity.configId}`, entity.id);
        }

        this.emit('entityStored', { entity, options });
        return entity;
    }

    retrieve(entityId) {
        return this.stored.get(entityId) || this.active.get(entityId) || null;
    }

    remove(entityId) {
        const entity = this.stored.get(entityId) || this.active.get(entityId);
        if (!entity) return false;

        this.stored.delete(entityId);
        this.active.delete(entityId);
        this.history.delete(entityId);

        for (const group of this.groups.values()) {
            group.entities.delete(entityId);
        }

        this.emit('entityRemoved', { entityId, entity });
        return true;
    }

    getAllStored() { return Array.from(this.stored.values()); }

    // ========================================
    // ACTIVE ENTITIES
    // ========================================

    activate(entityOrId) {
        const entity = typeof entityOrId === 'string' ? this.stored.get(entityOrId) : entityOrId;
        if (!entity) return null;

        if (!this.stored.has(entity.id)) this.store(entity);

        this.active.set(entity.id, entity);
        entity._internal.lastTick = Date.now();

        this.emit('entityActivated', { entity });
        return entity;
    }

    deactivate(entityId) {
        const entity = this.active.get(entityId);
        if (!entity) return false;

        this.active.delete(entityId);
        this.emit('entityDeactivated', { entityId, entity });
        return true;
    }

    getActive(entityId) { return this.active.get(entityId) || null; }
    getAllActive() { return Array.from(this.active.values()); }
    isActive(entityId) { return this.active.has(entityId); }

    // ========================================
    // SPAWN CONTEXT
    // ========================================

    setSpawnContext(context) {
        this.spawnContext = { ...this.spawnContext, ...context };
        this.emit('spawnContextUpdated', { context: this.spawnContext });
        return this;
    }

    getSpawnContext() { return { ...this.spawnContext }; }
    clearSpawnContext() { this.spawnContext = {}; return this; }

    // ========================================
    // STATE HISTORY
    // ========================================

    snapshot(entityId) {
        const entity = this.retrieve(entityId);
        if (!entity) return null;

        if (!this.history.has(entityId)) this.history.set(entityId, []);

        const snapshots = this.history.get(entityId);
        const snapshot = {
            timestamp: Date.now(),
            state: JSON.parse(JSON.stringify({
                attributes: entity.attributes,
                variables: entity.variables,
                contexts: entity.contexts,
                layers: entity.layers,
                modifiers: entity.modifiers,
                compounds: entity.compounds,
                derived: entity.derived
            }))
        };

        snapshots.push(snapshot);
        if (snapshots.length > this.config.maxHistory) {
            snapshots.splice(0, snapshots.length - this.config.maxHistory);
        }

        this.emit('snapshotTaken', { entityId, snapshot });
        return snapshot;
    }

    getHistory(entityId) { return this.history.get(entityId) || []; }

    rollback(entityId, timestamp) {
        const entity = this.retrieve(entityId);
        const snapshots = this.history.get(entityId);

        if (!entity || !snapshots) return false;

        const snapshot = [...snapshots].reverse().find(s => s.timestamp <= timestamp);
        if (!snapshot) return false;

        Object.assign(entity.attributes, snapshot.state.attributes);
        Object.assign(entity.contexts, snapshot.state.contexts);
        entity.layers = JSON.parse(JSON.stringify(snapshot.state.layers));
        entity.modifiers = [...snapshot.state.modifiers];
        entity.compounds = [...snapshot.state.compounds];
        entity.derived = { ...snapshot.state.derived };

        for (const [varId, varState] of Object.entries(snapshot.state.variables)) {
            if (entity.variables[varId]) {
                entity.variables[varId].value = varState.value;
            }
        }

        this.emit('entityRolledBack', { entityId, timestamp, snapshot });
        return true;
    }

    // ========================================
    // RUNTIME - TICK
    // ========================================

    tick(entityId, deltaSeconds = null) {
        const entity = this.active.get(entityId);
        if (!entity) return null;

        const now = Date.now();
        if (deltaSeconds === null) {
            deltaSeconds = (now - entity._internal.lastTick) / 1000;
        }
        entity._internal.lastTick = now;

        for (const [varId, varState] of Object.entries(entity.variables)) {
            if (varState.changeMode === 'timed' && varState.direction !== 'none') {
                const oldValue = varState.value;
                varState.value += varState.currentRate * deltaSeconds;
                varState.value = Math.max(varState.min, Math.min(varState.max, varState.value));

                if (varState.value !== oldValue) {
                    this.checkThresholds(entity, varId);
                    this.emit('variableChanged', {
                        entityId: entity.id, varId, oldValue, newValue: varState.value
                    });
                }
            }
        }

        const expiredModifiers = [];
        for (let i = entity.modifiers.length - 1; i >= 0; i--) {
            const modId = entity.modifiers[i];
            const modState = entity._modifierStates?.[modId];

            if (modState) {
                // Skip duration countdown for static modifiers
                if (modState.isStatic) continue;

                if (modState.expiresAt && now >= modState.expiresAt) {
                    expiredModifiers.push(modId);
                } else if (modState.ticksRemaining !== undefined) {
                    modState.ticksRemaining--;
                    if (modState.ticksRemaining <= 0) expiredModifiers.push(modId);
                }
            }
        }

        for (const modId of expiredModifiers) {
            this.removeModifier(entity.id, modId);
        }

        // Check static modifier thresholds after variable updates
        this.checkModifierThresholds(entity);

        // Decrement action cooldowns
        if (entity.actions) {
            for (const [actionId, state] of Object.entries(entity.actions)) {
                if (state.cooldownRemaining > 0) {
                    state.cooldownRemaining = Math.max(0, state.cooldownRemaining - deltaSeconds);
                }
            }
        }

        if (this.spawnManager) {
            this.spawnManager.calculateDerived(entity);
        }

        this.emit('tick', { entityId: entity.id, deltaSeconds });
        return entity;
    }

    tickAll(deltaSeconds = null) {
        for (const entityId of this.active.keys()) {
            this.tick(entityId, deltaSeconds);
        }
    }

    startAutoTick(rate = null) {
        if (this.tickInterval) return;
        const tickRate = rate || this.config.tickRate;
        this.tickInterval = setInterval(() => this.tickAll(), tickRate);
        this.emit('autoTickStarted', { rate: tickRate });
    }

    stopAutoTick() {
        if (this.tickInterval) {
            clearInterval(this.tickInterval);
            this.tickInterval = null;
            this.emit('autoTickStopped');
        }
    }

    // ========================================
    // RUNTIME - VARIABLES
    // ========================================

    modifyVariable(entityId, varId, delta) {
        const entity = this.retrieve(entityId);
        if (!entity) return false;

        const varState = entity.variables[varId];
        if (!varState) return false;

        const oldValue = varState.value;
        varState.value = Math.max(varState.min, Math.min(varState.max, varState.value + delta));

        if (varState.value !== oldValue) {
            this.checkThresholds(entity, varId);
            this.checkModifierThresholds(entity);
            if (this.spawnManager) this.spawnManager.calculateDerived(entity);
            this.emit('variableChanged', { entityId, varId, oldValue, newValue: varState.value });
        }

        return true;
    }

    setVariable(entityId, varId, value) {
        const entity = this.retrieve(entityId);
        if (!entity) return false;

        const varState = entity.variables[varId];
        if (!varState) return false;

        const oldValue = varState.value;
        varState.value = Math.max(varState.min, Math.min(varState.max, value));

        if (varState.value !== oldValue) {
            this.checkThresholds(entity, varId);
            this.checkModifierThresholds(entity);
            if (this.spawnManager) this.spawnManager.calculateDerived(entity);
            this.emit('variableChanged', { entityId, varId, oldValue, newValue: varState.value });
        }

        return true;
    }

    // ========================================
    // RUNTIME - MODIFIERS
    // ========================================

    applyModifier(entityId, modifierId, config = {}) {
        const entity = this.retrieve(entityId);
        if (!entity) return false;

        if (!entity._modifierStates) entity._modifierStates = {};

        const existing = entity.modifiers.includes(modifierId);
        const isStatic = config.isStatic || config.trigger?.static || false;

        if (existing && entity._modifierStates[modifierId]) {
            const modState = entity._modifierStates[modifierId];
            if (config.stacking === 'refresh') {
                modState.appliedAt = Date.now();
                if (!isStatic && config.duration && config.durationType === 'timed') {
                    modState.expiresAt = Date.now() + (config.duration * 1000);
                }
            } else if (config.stacking === 'stack') {
                modState.stacks = Math.min((modState.stacks || 1) + 1, config.maxStacks || 99);
            }
        } else {
            entity.modifiers.push(modifierId);
            entity._modifierStates[modifierId] = {
                appliedAt: Date.now(),
                stacks: 1,
                isStatic: isStatic,
                // Static modifiers don't have duration - they expire based on removal conditions
                expiresAt: !isStatic && config.durationType === 'timed' && config.duration
                    ? Date.now() + (config.duration * 1000) : null,
                ticksRemaining: !isStatic && config.durationType === 'ticks' ? config.duration : undefined
            };
        }

        this._runCascade(entity);

        this.emit('modifierApplied', { entityId, modifierId });
        return true;
    }

    removeModifier(entityId, modifierId) {
        const entity = this.retrieve(entityId);
        if (!entity) return false;

        const index = entity.modifiers.indexOf(modifierId);
        if (index === -1) return false;

        entity.modifiers.splice(index, 1);
        if (entity._modifierStates) delete entity._modifierStates[modifierId];

        this._runCascade(entity);

        this.emit('modifierRemoved', { entityId, modifierId });
        return true;
    }

    // ========================================
    // RUNTIME - TRAITS
    // ========================================

    activateTrait(entityId, traitId) {
        const entity = this.retrieve(entityId);
        if (!entity || !this.spawnManager) return false;

        const result = this.spawnManager.activateTrait(entity, traitId);
        if (result) {
            this._runCascade(entity);
            this.emit('traitActivated', { entityId, traitId });
        }
        return result;
    }

    deactivateTrait(entityId, traitId) {
        const entity = this.retrieve(entityId);
        if (!entity || !this.spawnManager) return false;

        const result = this.spawnManager.deactivateTrait(entity, traitId);
        if (result) {
            this._runCascade(entity);
            this.emit('traitDeactivated', { entityId, traitId });
        }
        return result;
    }

    /**
     * Run the cascade recalculation triple (rates, compounds, derived).
     * If batching is active, marks dirty and defers execution.
     * @param {Object} entity - The entity to recalculate
     */
    _runCascade(entity) {
        if (this._batchingCascade) {
            this._cascadeDirty = true;
            this._cascadeEntity = entity;
            return;
        }
        if (!this.spawnManager) return;
        this.spawnManager.recalculateRates(entity);
        this.spawnManager.checkCompounds(entity);
        this.spawnManager.calculateDerived(entity);
    }

    // ========================================
    // THRESHOLDS
    // ========================================

    checkThresholds(entity, varId) {
        if (!this.spawnManager) return;

        const varState = entity.variables[varId];

        const traits = this.spawnManager._thresholdTraitsByVar.get(varId) || [];

        for (const trait of traits) {
            const trigger = trait.config.selection.trigger;
            const autoRemove = trait.config.selection.autoRemove;
            const layerId = trait.config.layerId;
            const isActive = entity.layers[layerId]?.active?.includes(trait.id);

            if (!isActive && this.evaluateThreshold(varState.value, trigger)) {
                this.activateTrait(entity.id, trait.id);
            }

            if (isActive && autoRemove && this.evaluateThreshold(varState.value, autoRemove)) {
                this.deactivateTrait(entity.id, trait.id);
            }
        }
    }

    evaluateThreshold(value, condition) {
        if (!condition) return false;
        const threshold = condition.value;
        switch (condition.operator || condition.op) {
            case '<': return value < threshold;
            case '<=': return value <= threshold;
            case '>': return value > threshold;
            case '>=': return value >= threshold;
            case '=':
            case '==': return value === threshold;
            case '!=': return value !== threshold;
            default: return false;
        }
    }

    /**
     * Get the current numeric value of a node (delegates to SpawnManager).
     * Needed by evaluateSingleCondition for threshold comparisons.
     */
    getNodeValue(entity, nodeId) {
        if (this.spawnManager) {
            return this.spawnManager.getNodeValue(entity, nodeId);
        }
        // Fallback: check entity directly
        if (entity.attributes && entity.attributes[nodeId] !== undefined) return entity.attributes[nodeId];
        if (entity.variables && entity.variables[nodeId]) return entity.variables[nodeId].value;
        if (entity.derived && entity.derived[nodeId] !== undefined) return entity.derived[nodeId];
        return null;
    }

    /**
     * Evaluate multi-condition trigger with per-expression connectors
     * Supports both new format (connector per condition) and legacy format (global logic)
     * @param {Object} entity - The entity to evaluate against
     * @param {Object} trigger - The trigger config with conditions array
     * @returns {boolean} - Whether the trigger conditions are met
     */
    evaluateModifierTrigger(entity, trigger) {
        if (!trigger) return false;

        // Multi-condition format
        if (trigger.conditions && trigger.conditions.length > 0) {
            return this.evaluateConditionsWithConnectors(entity, trigger.conditions, trigger.logic);
        }

        // Single condition (backwards compatibility)
        if (trigger.target) {
            const value = this.getNodeValue(entity, trigger.target);
            if (value === null || value === undefined) return false;
            return this.evaluateThreshold(value, trigger);
        }

        return false;
    }

    /**
     * Evaluate a list of conditions with per-expression connectors
     * @param {Object} entity - The entity to evaluate against
     * @param {Array} conditions - Array of conditions with optional connector property
     * @param {string} fallbackLogic - Fallback logic if no connectors (legacy format)
     * @returns {boolean} - Whether the conditions are met
     */
    evaluateConditionsWithConnectors(entity, conditions, fallbackLogic = 'all') {
        if (!conditions || conditions.length === 0) return false;

        // Evaluate first condition
        let result = this.evaluateConditionOrGroup(entity, conditions[0]);

        // Combine with subsequent conditions using their connectors
        for (let i = 1; i < conditions.length; i++) {
            const cond = conditions[i];
            const condResult = this.evaluateConditionOrGroup(entity, cond);

            // Use condition's connector, or fallback to global logic (for backwards compat)
            const connector = cond.connector || (fallbackLogic === 'any' ? 'OR' : 'AND');

            if (connector === 'OR') {
                result = result || condResult;
            } else {
                // AND
                result = result && condResult;
            }
        }

        return result;
    }

    /**
     * Evaluate removal conditions for static modifiers
     * For static modifiers without explicit removeConditions, removal happens when apply conditions are no longer met
     * @param {Object} entity - The entity to evaluate against
     * @param {Object} trigger - The trigger config
     * @returns {boolean} - Whether the removal conditions are met
     */
    evaluateRemoveConditions(entity, trigger) {
        if (!trigger) return false;

        // If explicit removeConditions exist, evaluate them
        if (trigger.removeConditions && trigger.removeConditions.length > 0) {
            return this.evaluateConditionsWithConnectors(entity, trigger.removeConditions, trigger.removeLogic);
        }

        // For static modifiers without explicit remove conditions,
        // removal happens when apply conditions are NO LONGER met (inverse)
        if (trigger.static && trigger.conditions && trigger.conditions.length > 0) {
            return !this.evaluateConditionsWithConnectors(entity, trigger.conditions, trigger.logic);
        }

        return false;
    }

    /**
     * Evaluate a single condition or a condition group
     * Groups use per-expression connectors (AND/OR between each condition)
     * @param {Object} entity - The entity to evaluate against
     * @param {Object} cond - A condition or condition group
     * @returns {boolean} - Whether the condition is met
     */
    evaluateConditionOrGroup(entity, cond) {
        // Check if this is a group
        if (cond.type === 'group' && cond.conditions && cond.conditions.length > 0) {
            // Use per-expression connectors within the group
            let result = this.evaluateSingleCondition(entity, cond.conditions[0]);

            for (let i = 1; i < cond.conditions.length; i++) {
                const innerCond = cond.conditions[i];
                const innerResult = this.evaluateSingleCondition(entity, innerCond);

                // Use connector from condition, default to OR inside groups (common pattern)
                const connector = innerCond.connector || 'OR';

                if (connector === 'OR') {
                    result = result || innerResult;
                } else {
                    result = result && innerResult;
                }
            }

            return result;
        }

        // Single condition
        return this.evaluateSingleCondition(entity, cond);
    }

    /**
     * Evaluate a single condition (not a group)
     * Supports 'active'/'inactive' operators for checking node state
     * @param {Object} entity - The entity to evaluate against
     * @param {Object} cond - The condition with target, operator, value
     * @returns {boolean} - Whether the condition is met
     */
    evaluateSingleCondition(entity, cond) {
        if (!cond || !cond.target) return false;

        // Check for 'active'/'inactive' operators (for traits, modifiers, compounds)
        if (cond.operator === 'active') {
            return this.isNodeActive(entity, cond.target);
        }
        if (cond.operator === 'inactive') {
            return !this.isNodeActive(entity, cond.target);
        }

        // Numeric comparison
        const value = this.getNodeValue(entity, cond.target);
        if (value === null || value === undefined) return false;
        return this.evaluateThreshold(value, cond);
    }

    /**
     * Check if a node (trait, modifier, compound) is active on an entity
     * @param {Object} entity - The entity to check
     * @param {string} nodeId - The node ID to check
     * @returns {boolean} - Whether the node is active
     */
    isNodeActive(entity, nodeId) {
        if (!this.spawnManager) return false;
        return this.spawnManager.isNodeActive(entity, nodeId);
    }

    /**
     * Check all static modifier thresholds and auto-apply/remove as needed
     * Called after variable updates in tick()
     * @param {Object} entity - The entity to check
     */
    checkModifierThresholds(entity) {
        if (!this.spawnManager) return;

        const modifiers = this.spawnManager._thresholdModifiers;

        // Use pre-computed exclusive groups
        const exclusiveGroups = this.spawnManager._exclusiveGroups;

        // Resolve exclusive groups first (pick winner per group)
        const groupWinners = this.resolveExclusiveGroups(entity, exclusiveGroups, modifiers);

        // Batch cascade: defer recalculations until all modifier changes are resolved
        this._batchingCascade = true;
        this._cascadeDirty = false;

        for (const modifier of modifiers) {
            const trigger = modifier.config.trigger;
            const isActive = entity.modifiers.includes(modifier.id);
            const isStatic = trigger.static || false;
            const shouldApply = this.evaluateModifierTrigger(entity, trigger);

            // Check if this modifier is in an exclusive group
            const groupResult = groupWinners.get(modifier.id);

            if (groupResult !== undefined) {
                // Exclusive group member â€” only the winner applies
                if (groupResult === true && !isActive) {
                    this.applyModifier(entity.id, modifier.id, {
                        ...modifier.config,
                        isStatic: isStatic
                    });
                } else if (groupResult === false && isActive) {
                    this.removeModifier(entity.id, modifier.id);
                }
            } else {
                // Not in an exclusive group â€” original behavior
                if (!isActive && shouldApply) {
                    this.applyModifier(entity.id, modifier.id, {
                        ...modifier.config,
                        isStatic: isStatic
                    });
                } else if (isActive && isStatic) {
                    const shouldRemove = this.evaluateRemoveConditions(entity, trigger);
                    if (shouldRemove) {
                        this.removeModifier(entity.id, modifier.id);
                    }
                }
            }
        }

        // Flush: run cascade once if any modifiers changed
        this._batchingCascade = false;
        if (this._cascadeDirty) {
            this._cascadeDirty = false;
            this._cascadeEntity = null;
            if (this.spawnManager) {
                this.spawnManager.recalculateRates(entity);
                this.spawnManager.checkCompounds(entity);
                this.spawnManager.calculateDerived(entity);
            }
        }
    }

    /**
     * Build exclusive groups from modifier exclusiveWith config
     * Returns a Map of modId -> Set of exclusive partner mod IDs
     */
    buildExclusiveGroups(modifiers) {
        const groups = new Map();
        for (const mod of modifiers) {
            const exclusive = mod.config.exclusiveWith;
            if (exclusive && exclusive.length > 0) {
                if (!groups.has(mod.id)) groups.set(mod.id, new Set());
                for (const partnerId of exclusive) {
                    groups.get(mod.id).add(partnerId);
                    // Ensure bidirectional: partner also knows about this modifier
                    if (!groups.has(partnerId)) groups.set(partnerId, new Set());
                    groups.get(partnerId).add(mod.id);
                }
            }
        }
        return groups;
    }

    /**
     * Resolve exclusive groups: for each group, evaluate all members and pick the winner.
     * Returns a Map of modId -> true (winner) | false (loser) for all group members.
     * Modifiers not in any group are not included in the map.
     */
    resolveExclusiveGroups(entity, exclusiveMap, modifiers) {
        const results = new Map();
        const visited = new Set();

        for (const [modId, partners] of exclusiveMap) {
            if (visited.has(modId)) continue;

            // Collect the full group (transitive closure)
            const group = new Set([modId]);
            const queue = [modId];
            while (queue.length > 0) {
                const current = queue.pop();
                const currentPartners = exclusiveMap.get(current);
                if (currentPartners) {
                    for (const p of currentPartners) {
                        if (!group.has(p)) {
                            group.add(p);
                            queue.push(p);
                        }
                    }
                }
            }

            // Mark all as visited
            for (const id of group) visited.add(id);

            // Evaluate which members' conditions are currently met
            const candidates = [];
            for (const id of group) {
                const mod = modifiers.find(m => m.id === id);
                if (mod && this.evaluateModifierTrigger(entity, mod.config.trigger)) {
                    candidates.push(mod);
                }
            }

            if (candidates.length === 0) {
                // No conditions met â€” all losers (remove any active)
                for (const id of group) results.set(id, false);
            } else if (candidates.length === 1) {
                // Only one qualifies â€” it wins
                for (const id of group) results.set(id, id === candidates[0].id);
            } else {
                // Multiple qualify â€” pick most specific
                const winner = this.getMostSpecificModifier(candidates);
                for (const id of group) results.set(id, id === winner.id);
            }
        }

        return results;
    }

    /**
     * Among multiple modifiers whose conditions are all met,
     * pick the most specific (narrowest threshold).
     * For same-variable same-operator: <= uses lowest value, >= uses highest value.
     * Falls back to config node order.
     */
    getMostSpecificModifier(candidates) {
        // Try to auto-detect specificity from single-condition triggers on same variable
        const singleCondCandidates = candidates.filter(m =>
            m.config.trigger?.conditions?.length === 1
        );

        if (singleCondCandidates.length === candidates.length) {
            const conds = singleCondCandidates.map(m => ({
                mod: m,
                cond: m.config.trigger.conditions[0]
            }));

            // Check if all target the same variable
            const targets = new Set(conds.map(c => c.cond.target));
            if (targets.size === 1) {
                // Group by operator direction
                const leOps = conds.filter(c => c.cond.operator === '<=' || c.cond.operator === '<');
                const geOps = conds.filter(c => c.cond.operator === '>=' || c.cond.operator === '>');

                if (leOps.length === conds.length) {
                    // All <= or <: lowest threshold value is most specific
                    leOps.sort((a, b) => a.cond.value - b.cond.value);
                    return leOps[0].mod;
                }
                if (geOps.length === conds.length) {
                    // All >= or >: highest threshold value is most specific
                    geOps.sort((a, b) => b.cond.value - a.cond.value);
                    return geOps[0].mod;
                }
            }
        }

        // Fallback: first candidate in config node order (already filtered from modifiers array)
        return candidates[0];
    }

    // ========================================
    // QUERYING
    // ========================================

    query(filter = {}) {
        let results = [];

        if (filter.fromGroup) {
            results = this.getGroup(filter.fromGroup);
        } else if (filter.fromActive) {
            results = this.getAllActive();
        } else {
            results = this.getAllStored();
        }

        if (filter.where) {
            results = results.filter(entity => this.matchesWhere(entity, filter.where));
        }

        if (filter.sortBy) {
            const desc = filter.sortDesc || false;
            results.sort((a, b) => {
                const aVal = this.getNestedValue(a, filter.sortBy) || 0;
                const bVal = this.getNestedValue(b, filter.sortBy) || 0;
                return desc ? bVal - aVal : aVal - bVal;
            });
        }

        if (filter.limit) {
            results = results.slice(0, filter.limit);
        }

        return results;
    }

    matchesWhere(entity, where) {
        for (const [path, condition] of Object.entries(where)) {
            const actual = this.getNestedValue(entity, path);
            if (typeof condition === 'object' && condition !== null) {
                for (const [op, value] of Object.entries(condition)) {
                    if (!this.compareValues(actual, op, value)) return false;
                }
            } else {
                if (actual !== condition) return false;
            }
        }
        return true;
    }

    getNestedValue(obj, path) {
        return path.split('.').reduce((curr, key) => curr?.[key], obj);
    }

    compareValues(actual, op, expected) {
        switch (op) {
            case 'eq': return actual === expected;
            case 'ne': return actual !== expected;
            case 'gt': return actual > expected;
            case 'gte': return actual >= expected;
            case 'lt': return actual < expected;
            case 'lte': return actual <= expected;
            case 'in': return Array.isArray(expected) && expected.includes(actual);
            case 'includes': return Array.isArray(actual) && actual.includes(expected);
            default: return false;
        }
    }

    // ========================================
    // STATE SUMMARY
    // ========================================

    getState(entityId) {
        const entity = this.retrieve(entityId);
        if (!entity) return null;

        const activeTraits = [];
        for (const [layerId, layerState] of Object.entries(entity.layers)) {
            for (const traitId of layerState.active) {
                const trait = this.spawnManager?.getNode(traitId);
                activeTraits.push({ id: traitId, name: trait?.name || traitId, layerId });
            }
        }

        const activeModifiers = entity.modifiers.map(modId => {
            const mod = this.spawnManager?.getNode(modId);
            const state = entity._modifierStates?.[modId] || {};
            return { id: modId, name: mod?.name || modId, stacks: state.stacks, expiresAt: state.expiresAt };
        });

        const activeCompounds = entity.compounds.map(compId => {
            const comp = this.spawnManager?.getNode(compId);
            return { id: compId, name: comp?.name || compId };
        });

        return {
            id: entity.id,
            name: entity.name,
            presetId: entity.presetId,
            createdAt: entity.createdAt,
            isActive: this.active.has(entity.id),
            attributes: { ...entity.attributes },
            variables: Object.fromEntries(
                Object.entries(entity.variables).map(([k, v]) => [k, {
                    value: v.value, rate: v.currentRate, min: v.min, max: v.max
                }])
            ),
            contexts: { ...entity.contexts },
            activeTraits,
            activeModifiers,
            activeCompounds,
            derived: { ...entity.derived }
        };
    }

    // ========================================
    // ENTITY POOLING
    // ========================================

    /**
     * Configure the entity pool for reuse/recycling.
     * Useful for scenarios with frequent spawn/despawn (JRPG combat, bullet hell, etc.)
     *
     * @param {Object} config - Pool configuration
     * @param {number} [config.maxSize=100] - Maximum entities to keep in pool
     * @param {number} [config.preWarm=0] - Number of entities to pre-create
     * @param {string} [config.preWarmPreset=null] - Preset to use for pre-warming
     * @param {number} [config.shrinkThreshold=0.5] - Shrink pool when usage below this ratio
     * @param {number} [config.shrinkDelay=30000] - Delay before shrinking (ms)
     * @returns {EntityManager} This instance for chaining
     * @example
     * // JRPG combat setup
     * entityManager.configurePool({
     *   maxSize: 50,
     *   preWarm: 10,
     *   preWarmPreset: 'enemy_goblin'
     * });
     */
    configurePool(config) {
        this.poolConfig = { ...this.poolConfig, ...config };

        // Pre-warm if requested
        if (config.preWarm && config.preWarm > 0) {
            this.preWarmPool(config.preWarm, config.preWarmPreset);
        }

        return this;
    }

    /**
     * Acquire an entity from the pool or create a new one.
     * Faster than spawn() for high-frequency scenarios.
     *
     * @param {string|Object} [presetIdOrOverrides] - Preset ID or override object
     * @param {Object} [overrides={}] - Additional overrides when using preset
     * @returns {Object} The acquired entity
     * @example
     * // Acquire enemy for combat
     * const enemy = entityManager.acquire('enemy_goblin');
     *
     * // Acquire with overrides
     * const boss = entityManager.acquire('enemy_goblin', {
     *   attributes: { strength: 20 }
     * });
     *
     * // When combat ends, release back to pool
     * entityManager.release(enemy);
     */
    acquire(presetIdOrOverrides, overrides = {}) {
        let entity;
        let fromPool = false;

        // Try to get from pool first
        if (this.pool.length > 0) {
            entity = this.pool.pop();
            fromPool = true;

            // Reset entity state for reuse
            this._resetEntityForReuse(entity, presetIdOrOverrides, overrides);

            this.poolStats.available--;
        } else {
            // Create new entity
            if (!this.spawnManager) {
                throw new Error('EntityManager requires a linked SpawnManager for acquire()');
            }

            if (typeof presetIdOrOverrides === 'string') {
                entity = this.spawnManager.spawn(presetIdOrOverrides, overrides);
            } else {
                entity = this.spawnManager.generate(presetIdOrOverrides || overrides);
            }

            this.poolStats.totalCreated++;
        }

        if (entity) {
            // Store and activate
            this.store(entity);
            this.activate(entity);

            this.poolStats.inUse++;
            this.poolStats.totalAcquired++;

            this.emit('entityAcquired', { entityId: entity.id, fromPool });
        }

        return entity;
    }

    /**
     * Release an entity back to the pool for reuse.
     * Entity is deactivated and removed from active tracking.
     *
     * @param {Object|string} entityOrId - Entity or entity ID to release
     * @returns {boolean} True if released to pool, false if pool full or entity not found
     * @example
     * // Release enemy after combat
     * entityManager.release(enemy);
     * entityManager.release('entity_123');
     */
    release(entityOrId) {
        const entityId = typeof entityOrId === 'string' ? entityOrId : entityOrId?.id;
        const entity = this.stored.get(entityId);

        if (!entity) return false;

        // Deactivate and remove from tracking
        this.deactivate(entityId);
        this.stored.delete(entityId);
        this.active.delete(entityId);

        // Clear history for this entity
        this.history.delete(entityId);

        // Remove from all groups
        for (const group of this.groups.values()) {
            group.entities.delete(entityId);
        }

        this.poolStats.inUse = Math.max(0, this.poolStats.inUse - 1);
        this.poolStats.totalReleased++;

        // Add to pool if not full
        if (this.pool.length < this.poolConfig.maxSize) {
            // Clean up entity for pooling
            this._prepareEntityForPool(entity);
            this.pool.push(entity);
            this.poolStats.available++;
            this.poolStats.size = this.pool.length;

            this.emit('entityReleased', { entityId, toPool: true });

            // Schedule shrink check
            this._scheduleShrinkCheck();

            return true;
        }

        this.emit('entityReleased', { entityId, toPool: false });
        return false;
    }

    /**
     * Pre-warm the pool by creating entities ahead of time.
     * Useful to avoid spawn hitches during gameplay.
     *
     * @param {number} count - Number of entities to pre-create
     * @param {string} [presetId] - Preset to use (random if not specified)
     * @returns {EntityManager} This instance for chaining
     * @example
     * // Pre-warm for wave-based combat
     * entityManager.preWarmPool(20, 'enemy_basic');
     */
    preWarmPool(count, presetId = null) {
        if (!this.spawnManager) {
            console.warn('EntityManager requires a linked SpawnManager for preWarmPool()');
            return this;
        }

        const toCreate = Math.min(count, this.poolConfig.maxSize - this.pool.length);

        for (let i = 0; i < toCreate; i++) {
            let entity;
            if (presetId) {
                entity = this.spawnManager.spawn(presetId);
            } else {
                entity = this.spawnManager.generate();
            }

            if (entity) {
                this._prepareEntityForPool(entity);
                this.pool.push(entity);
                this.poolStats.totalCreated++;
            }
        }

        this.poolStats.size = this.pool.length;
        this.poolStats.available = this.pool.length;

        return this;
    }

    /**
     * Clear all entities from the pool.
     *
     * @returns {EntityManager} This instance for chaining
     */
    clearPool() {
        this.pool = [];
        this.poolStats.size = 0;
        this.poolStats.available = 0;

        if (this._shrinkTimeout) {
            clearTimeout(this._shrinkTimeout);
            this._shrinkTimeout = null;
        }

        return this;
    }

    /**
     * Get current pool statistics.
     *
     * @returns {Object} Pool stats
     * @example
     * const stats = entityManager.getPoolStats();
     * console.log(`Pool: ${stats.available}/${stats.size} available, ${stats.inUse} in use`);
     */
    getPoolStats() {
        return {
            ...this.poolStats,
            size: this.pool.length,
            available: this.pool.length
        };
    }

    /**
     * Reset an entity's state for reuse from pool.
     * @private
     */
    _resetEntityForReuse(entity, presetIdOrOverrides, overrides = {}) {
        if (!this.spawnManager) return;

        // Get preset or overrides
        let preset = null;
        let finalOverrides = overrides;

        if (typeof presetIdOrOverrides === 'string') {
            preset = this.getPreset(presetIdOrOverrides);
        } else if (presetIdOrOverrides) {
            finalOverrides = { ...presetIdOrOverrides, ...overrides };
        }

        // Generate fresh ID
        entity.id = `entity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        entity.createdAt = Date.now();
        entity.presetId = preset?.id || null;

        // Re-roll attributes
        const attributes = this.spawnManager.getAttributes();
        for (const attr of attributes) {
            const cfg = attr.config;
            const range = cfg.defaultRange || [cfg.min, cfg.max];

            // Check for override (supports fixed values, ranges, and variance)
            if (preset?.attributes?.[attr.id] !== undefined) {
                entity.attributes[attr.id] = this.spawnManager.resolvePresetAttributeValue(
                    preset.attributes[attr.id],
                    cfg.precision ?? 0
                );
            } else if (finalOverrides.attributes?.[attr.id] !== undefined) {
                entity.attributes[attr.id] = this.spawnManager.resolvePresetAttributeValue(
                    finalOverrides.attributes[attr.id],
                    cfg.precision ?? 0
                );
            } else {
                entity.attributes[attr.id] = this.spawnManager.rollRange(range[0], range[1], cfg.precision ?? 0);
            }
        }

        // Reset variables to initial
        const variables = this.spawnManager.getVariables();
        for (const varNode of variables) {
            const cfg = varNode.config;
            entity.variables[varNode.id] = {
                value: cfg.initial ?? cfg.min ?? 0,
                baseRate: cfg.baseRate ?? 0,
                currentRate: cfg.baseRate ?? 0,
                min: cfg.min ?? 0,
                max: cfg.max ?? 100,
                changeMode: cfg.changeMode || 'manual',
                direction: cfg.direction || 'none'
            };
        }

        // Clear layers
        for (const layerId of Object.keys(entity.layers)) {
            entity.layers[layerId] = { active: [], lastRoll: null };
        }

        // Clear modifiers and compounds
        entity.modifiers = [];
        entity.compounds = [];
        entity._modifierStates = {};

        // Clear derived
        entity.derived = {};

        // Clear internal log
        entity._internal = {
            log: [],
            lastTick: Date.now()
        };

        // Re-roll initial layers
        const layers = this.spawnManager.getLayers();
        for (const layer of layers) {
            const timing = layer.config?.timing?.rollAt || 'spawn';
            if (timing === 'spawn' || timing === 'create') {
                this.spawnManager.rollLayer(entity, layer.id);
            }
        }

        // Force traits if specified (supports both legacy forceTraits and new traits object)
        const forceTraits = [
            ...(preset?.forceTraits || []),
            ...this.spawnManager.resolvePresetTraits(preset?.traits),
            ...(finalOverrides.forceTraits || []),
            ...this.spawnManager.resolvePresetTraits(finalOverrides.traits)
        ];
        for (const traitId of forceTraits) {
            this.spawnManager.forceActivateTrait(entity, traitId);
        }

        // Recalculate
        this._runCascade(entity);
    }

    /**
     * Prepare an entity for storage in the pool.
     * @private
     */
    _prepareEntityForPool(entity) {
        // Clear most state but keep structure
        entity._internal = { log: [], lastTick: 0 };
        entity.modifiers = [];
        entity.compounds = [];
        entity._modifierStates = {};

        // Clear layer actives but keep structure
        for (const layerId of Object.keys(entity.layers)) {
            entity.layers[layerId] = { active: [], lastRoll: null };
        }
    }

    /**
     * Schedule a pool shrink check (legacy - delegates to default pool).
     * @private
     * @deprecated Use _scheduleShrinkCheckForPool() instead
     */
    _scheduleShrinkCheck() {
        this._scheduleShrinkCheckForPool(this.defaultPoolId);
    }

    /**
     * Check if pool should shrink.
     * @private
     * @param {string} [poolId] - Pool to check (defaults to default pool)
     */
    _checkPoolShrink(poolId = this.defaultPoolId) {
        const pool = this.pools.get(poolId);
        if (!pool) return;

        const usage = pool.stats.inUse / (pool.stats.inUse + pool.entities.length);

        if (usage < pool.config.shrinkThreshold && pool.entities.length > 10) {
            // Shrink to half size
            const targetSize = Math.max(10, Math.floor(pool.entities.length / 2));
            while (pool.entities.length > targetSize) {
                pool.entities.pop();
            }
            pool.stats.size = pool.entities.length;
            pool.stats.available = pool.entities.length;

            // Sync legacy references for default pool
            if (poolId === this.defaultPoolId) {
                this.poolStats.size = pool.stats.size;
                this.poolStats.available = pool.stats.available;
            }
        }
    }

    /**
     * Schedule a pool shrink check for a specific pool.
     * @private
     * @param {string} [poolId] - Pool to schedule check for
     */
    _scheduleShrinkCheckForPool(poolId = this.defaultPoolId) {
        const pool = this.pools.get(poolId);
        if (!pool || pool._shrinkTimeout) return;
        if (!pool.config.shrinkDelay) return;

        pool._shrinkTimeout = setTimeout(() => {
            pool._shrinkTimeout = null;
            this._checkPoolShrink(poolId);
        }, pool.config.shrinkDelay);
    }

    // ========================================
    // MULTI-POOL MANAGEMENT
    // ========================================

    /**
     * Create a new named entity pool.
     *
     * @param {string} poolId - Unique pool identifier
     * @param {Object} [options={}] - Pool configuration
     * @param {string} [options.name] - Display name for the pool
     * @param {string} [options.description] - Pool description
     * @param {number} [options.maxSize=100] - Maximum entities in pool
     * @param {number} [options.preWarm=0] - Entities to pre-create
     * @param {string} [options.preWarmPreset] - Preset for pre-warming
     * @param {number} [options.shrinkThreshold=0.5] - Shrink when usage below ratio
     * @param {number} [options.shrinkDelay=30000] - Delay before shrinking (ms)
     * @param {Object} [options.rules] - Assignment rules for this pool
     * @returns {Object} The created pool instance
     * @fires EntityManager#poolCreated
     * @example
     * manager.createPool('enemies', {
     *   name: 'Enemy Pool',
     *   maxSize: 50,
     *   preWarm: 10,
     *   preWarmPreset: 'goblin',
     *   rules: { conditions: [{ source: 'preset', match: 'enemy_*' }] }
     * });
     */
    createPool(poolId, options = {}) {
        if (this.pools.has(poolId)) {
            console.warn(`Pool '${poolId}' already exists. Use configurePool() to modify.`);
            return this.pools.get(poolId);
        }

        const pool = {
            id: poolId,
            name: options.name || poolId,
            description: options.description || '',
            config: {
                maxSize: options.maxSize ?? 100,
                preWarm: options.preWarm ?? 0,
                preWarmPreset: options.preWarmPreset ?? null,
                shrinkThreshold: options.shrinkThreshold ?? 0.5,
                shrinkDelay: options.shrinkDelay ?? 30000
            },
            stats: {
                size: 0,
                available: 0,
                inUse: 0,
                totalAcquired: 0,
                totalReleased: 0,
                totalCreated: 0
            },
            entities: [],
            rules: options.rules || null,
            _shrinkTimeout: null
        };

        this.pools.set(poolId, pool);
        this.emit('poolCreated', { poolId, pool });

        // Pre-warm if requested
        if (pool.config.preWarm > 0) {
            this.preWarmPool(pool.config.preWarm, pool.config.preWarmPreset, poolId);
        }

        return pool;
    }

    /**
     * Get a pool by ID.
     *
     * @param {string} poolId - Pool identifier
     * @returns {Object|null} The pool instance or null if not found
     */
    getPool(poolId) {
        return this.pools.get(poolId) || null;
    }

    /**
     * List all pools.
     *
     * @returns {Array<Object>} Array of pool summaries
     * @example
     * const pools = manager.listPools();
     * // [{ id: 'default', name: 'Default Pool', stats: {...} }, ...]
     */
    listPools() {
        return Array.from(this.pools.values()).map(pool => ({
            id: pool.id,
            name: pool.name,
            description: pool.description,
            stats: { ...pool.stats },
            hasRules: !!pool.rules
        }));
    }

    /**
     * Remove a pool. Entities in the pool are moved to default pool.
     *
     * @param {string} poolId - Pool to remove
     * @returns {boolean} True if removed, false if not found or is default
     * @fires EntityManager#poolRemoved
     */
    removePool(poolId) {
        if (poolId === this.defaultPoolId) {
            console.warn('Cannot remove the default pool.');
            return false;
        }

        const pool = this.pools.get(poolId);
        if (!pool) return false;

        // Move pooled entities to default pool
        const defaultPool = this.pools.get(this.defaultPoolId);
        for (const entity of pool.entities) {
            if (defaultPool.entities.length < defaultPool.config.maxSize) {
                entity.poolId = this.defaultPoolId;
                defaultPool.entities.push(entity);
                defaultPool.stats.available++;
                defaultPool.stats.size++;
            }
        }

        // Clear timeout
        if (pool._shrinkTimeout) {
            clearTimeout(pool._shrinkTimeout);
        }

        this.pools.delete(poolId);
        this.emit('poolRemoved', { poolId });

        // Sync legacy references
        this.poolStats.size = defaultPool.stats.size;
        this.poolStats.available = defaultPool.stats.available;

        return true;
    }

    /**
     * Configure a specific pool (or default pool for backward compatibility).
     *
     * @param {string|Object} poolIdOrConfig - Pool ID or config object (for backward compat)
     * @param {Object} [config] - Configuration when poolId is provided
     * @returns {EntityManager} This instance for chaining
     * @example
     * // New API - configure named pool
     * manager.configurePool('enemies', { maxSize: 50 });
     *
     * // Legacy API - configure default pool
     * manager.configurePool({ maxSize: 100 });
     */
    configurePool(poolIdOrConfig, config = null) {
        let poolId, poolConfig;

        // Backward compatibility: single object = default pool config
        if (typeof poolIdOrConfig === 'object') {
            poolId = this.defaultPoolId;
            poolConfig = poolIdOrConfig;
        } else {
            poolId = poolIdOrConfig;
            poolConfig = config || {};
        }

        const pool = this.pools.get(poolId);
        if (!pool) {
            console.warn(`Pool '${poolId}' not found. Use createPool() first.`);
            return this;
        }

        // Update config
        pool.config = { ...pool.config, ...poolConfig };

        // Sync legacy references for default pool
        if (poolId === this.defaultPoolId) {
            this.poolConfig = { ...pool.config };
        }

        // Pre-warm if requested
        if (poolConfig.preWarm && poolConfig.preWarm > 0) {
            this.preWarmPool(poolConfig.preWarm, poolConfig.preWarmPreset, poolId);
        }

        this.emit('poolConfigured', { poolId, config: pool.config });
        return this;
    }

    /**
     * Acquire an entity from a specific pool or determine pool via rules.
     *
     * @param {string|Object} [presetIdOrOverrides] - Preset ID or override object
     * @param {Object} [overrides={}] - Additional overrides
     * @param {string} [targetPoolId] - Specific pool to acquire from (auto-determined if omitted)
     * @returns {Object} The acquired entity
     * @fires EntityManager#entityAcquired
     * @example
     * // Acquire from auto-determined pool
     * const entity = manager.acquire('enemy_goblin');
     *
     * // Acquire from specific pool
     * const entity = manager.acquire('enemy_goblin', {}, 'enemies');
     */
    acquire(presetIdOrOverrides, overrides = {}, targetPoolId = null) {
        let entity;
        let fromPool = false;
        let poolId;

        // Determine target pool
        if (targetPoolId) {
            poolId = targetPoolId;
        } else {
            // Will be determined after entity generation if rules exist
            poolId = this.defaultPoolId;
        }

        const pool = this.pools.get(poolId);
        if (!pool) {
            console.warn(`Pool '${poolId}' not found, using default.`);
            poolId = this.defaultPoolId;
        }

        const actualPool = this.pools.get(poolId);

        // Try to get from pool first
        if (actualPool.entities.length > 0) {
            entity = actualPool.entities.pop();
            fromPool = true;

            // Reset entity state for reuse
            this._resetEntityForReuse(entity, presetIdOrOverrides, overrides);

            actualPool.stats.available--;
        } else {
            // Create new entity
            if (!this.spawnManager) {
                throw new Error('EntityManager requires a linked SpawnManager for acquire()');
            }

            if (typeof presetIdOrOverrides === 'string') {
                entity = this.spawnManager.spawn(presetIdOrOverrides, overrides);
            } else {
                entity = this.spawnManager.generate(presetIdOrOverrides || overrides);
            }

            actualPool.stats.totalCreated++;
        }

        if (entity) {
            // Determine final pool if rules exist and no explicit target
            if (!targetPoolId) {
                const determinedPoolId = this.getPoolForEntity(entity);
                if (determinedPoolId !== poolId) {
                    // Entity belongs to a different pool based on rules
                    poolId = determinedPoolId;
                }
            }

            // Set pool association on entity
            entity.poolId = poolId;

            // Store and activate
            this.store(entity);
            this.activate(entity);

            actualPool.stats.inUse++;
            actualPool.stats.totalAcquired++;

            // Sync legacy stats for default pool
            if (poolId === this.defaultPoolId) {
                this.poolStats.inUse = actualPool.stats.inUse;
                this.poolStats.totalAcquired = actualPool.stats.totalAcquired;
                this.poolStats.totalCreated = actualPool.stats.totalCreated;
            }

            this.emit('entityAcquired', { entityId: entity.id, fromPool, poolId });
        }

        return entity;
    }

    /**
     * Release an entity back to its pool (or specified pool).
     *
     * @param {Object|string} entityOrId - Entity or entity ID
     * @param {string} [targetPoolId] - Pool to release to (uses entity's poolId if omitted)
     * @returns {boolean} True if released to pool
     * @fires EntityManager#entityReleased
     */
    release(entityOrId, targetPoolId = null) {
        const entityId = typeof entityOrId === 'string' ? entityOrId : entityOrId?.id;
        const entity = this.stored.get(entityId);

        if (!entity) return false;

        // Determine pool
        const poolId = targetPoolId || entity.poolId || this.defaultPoolId;
        const pool = this.pools.get(poolId) || this.pools.get(this.defaultPoolId);

        // Deactivate and remove from tracking
        this.deactivate(entityId);
        this.stored.delete(entityId);
        this.active.delete(entityId);

        // Clear history for this entity
        this.history.delete(entityId);

        // Remove from all groups
        for (const group of this.groups.values()) {
            group.entities.delete(entityId);
        }

        pool.stats.inUse = Math.max(0, pool.stats.inUse - 1);
        pool.stats.totalReleased++;

        // Sync legacy stats for default pool
        if (poolId === this.defaultPoolId) {
            this.poolStats.inUse = pool.stats.inUse;
            this.poolStats.totalReleased = pool.stats.totalReleased;
        }

        // Add to pool if not full
        if (pool.entities.length < pool.config.maxSize) {
            // Clean up entity for pooling
            this._prepareEntityForPool(entity);
            entity.poolId = poolId;
            pool.entities.push(entity);
            pool.stats.available++;
            pool.stats.size = pool.entities.length;

            // Sync legacy stats
            if (poolId === this.defaultPoolId) {
                this.poolStats.available = pool.stats.available;
                this.poolStats.size = pool.stats.size;
            }

            this.emit('entityReleased', { entityId, toPool: true, poolId });

            // Schedule shrink check
            this._scheduleShrinkCheckForPool(poolId);

            return true;
        }

        this.emit('entityReleased', { entityId, toPool: false, poolId });
        return false;
    }

    /**
     * Move an entity from one pool to another.
     *
     * @param {Object|string} entityOrId - Entity or entity ID
     * @param {string} targetPoolId - Pool to move to
     * @returns {boolean} True if moved successfully
     * @fires EntityManager#entityMovedPool
     */
    moveToPool(entityOrId, targetPoolId) {
        const entityId = typeof entityOrId === 'string' ? entityOrId : entityOrId?.id;
        const entity = this.stored.get(entityId);

        if (!entity) return false;

        const targetPool = this.pools.get(targetPoolId);
        if (!targetPool) {
            console.warn(`Target pool '${targetPoolId}' not found.`);
            return false;
        }

        const fromPoolId = entity.poolId || this.defaultPoolId;
        if (fromPoolId === targetPoolId) return true; // Already in target pool

        const fromPool = this.pools.get(fromPoolId);

        // Update pool stats
        if (fromPool) {
            fromPool.stats.inUse = Math.max(0, fromPool.stats.inUse - 1);
        }
        targetPool.stats.inUse++;

        // Update entity's pool association
        entity.poolId = targetPoolId;

        this.emit('entityMovedPool', { entityId, fromPool: fromPoolId, toPool: targetPoolId });
        return true;
    }

    /**
     * Pre-warm a specific pool.
     *
     * @param {number} count - Number of entities to pre-create
     * @param {string} [presetId] - Preset to use
     * @param {string} [poolId] - Pool to warm (defaults to default)
     * @returns {EntityManager} This instance for chaining
     */
    preWarmPool(count, presetId = null, poolId = null) {
        const targetPoolId = poolId || this.defaultPoolId;
        const pool = this.pools.get(targetPoolId);

        if (!pool) {
            console.warn(`Pool '${targetPoolId}' not found.`);
            return this;
        }

        if (!this.spawnManager) {
            console.warn('EntityManager requires a linked SpawnManager for preWarmPool()');
            return this;
        }

        const toCreate = Math.min(count, pool.config.maxSize - pool.entities.length);

        for (let i = 0; i < toCreate; i++) {
            let entity;
            if (presetId) {
                entity = this.spawnManager.spawn(presetId);
            } else {
                entity = this.spawnManager.generate();
            }

            if (entity) {
                this._prepareEntityForPool(entity);
                entity.poolId = targetPoolId;
                pool.entities.push(entity);
                pool.stats.totalCreated++;
            }
        }

        pool.stats.size = pool.entities.length;
        pool.stats.available = pool.entities.length;

        // Sync legacy stats for default pool
        if (targetPoolId === this.defaultPoolId) {
            this.poolStats.size = pool.stats.size;
            this.poolStats.available = pool.stats.available;
            this.poolStats.totalCreated = pool.stats.totalCreated;
        }

        return this;
    }

    /**
     * Clear a specific pool.
     *
     * @param {string} [poolId] - Pool to clear (defaults to default)
     * @returns {EntityManager} This instance for chaining
     */
    clearPool(poolId = null) {
        const targetPoolId = poolId || this.defaultPoolId;
        const pool = this.pools.get(targetPoolId);

        if (!pool) return this;

        pool.entities.length = 0;
        pool.stats.size = 0;
        pool.stats.available = 0;

        if (pool._shrinkTimeout) {
            clearTimeout(pool._shrinkTimeout);
            pool._shrinkTimeout = null;
        }

        // Sync legacy references for default pool
        if (targetPoolId === this.defaultPoolId) {
            this.pool.length = 0;
            this.poolStats.size = 0;
            this.poolStats.available = 0;
        }

        return this;
    }

    /**
     * Get statistics for a specific pool.
     *
     * @param {string} [poolId] - Pool ID (defaults to default for backward compat)
     * @returns {Object} Pool statistics
     */
    getPoolStats(poolId = null) {
        const targetPoolId = poolId || this.defaultPoolId;
        const pool = this.pools.get(targetPoolId);

        if (!pool) {
            return { size: 0, available: 0, inUse: 0, totalAcquired: 0, totalReleased: 0, totalCreated: 0 };
        }

        return {
            ...pool.stats,
            size: pool.entities.length,
            available: pool.entities.length
        };
    }

    /**
     * Get statistics for all pools.
     *
     * @returns {Object} Map of poolId to stats
     */
    getAllPoolStats() {
        const stats = {};
        for (const [poolId, pool] of this.pools) {
            stats[poolId] = this.getPoolStats(poolId);
        }
        return stats;
    }

    /**
     * Set assignment rules for a pool.
     *
     * @param {string} poolId - Pool to configure
     * @param {Object} rules - Assignment rules
     * @param {Array<Object>} [rules.conditions] - Rule conditions
     * @param {string} [rules.fallback='default'] - Fallback pool if no match
     * @returns {EntityManager} This instance for chaining
     * @example
     * manager.setPoolRules('enemies', {
     *   conditions: [
     *     { source: 'preset', match: 'enemy_*' },
     *     { source: 'trait', match: 'hostile' }
     *   ]
     * });
     */
    setPoolRules(poolId, rules) {
        const pool = this.pools.get(poolId);
        if (!pool) {
            console.warn(`Pool '${poolId}' not found.`);
            return this;
        }

        pool.rules = rules;
        this.emit('poolRulesUpdated', { poolId, rules });
        return this;
    }

    /**
     * Determine which pool an entity should belong to based on rules.
     *
     * @param {Object} entity - Entity to evaluate
     * @returns {string} Pool ID the entity should belong to
     */
    getPoolForEntity(entity) {
        // 1. Check for explicit pool assignment
        if (entity.poolId && this.pools.has(entity.poolId)) {
            return entity.poolId;
        }

        // 2. Evaluate rules for each pool
        const matches = [];
        for (const [poolId, pool] of this.pools) {
            if (poolId === this.defaultPoolId || !pool.rules?.conditions) continue;

            const score = this._evaluatePoolRules(entity, pool.rules);
            if (score > 0) {
                matches.push({ poolId, score, priority: pool.rules.priority || 0 });
            }
        }

        // Sort by priority then score
        if (matches.length > 0) {
            matches.sort((a, b) => {
                if (a.priority !== b.priority) return b.priority - a.priority;
                return b.score - a.score;
            });
            return matches[0].poolId;
        }

        // 3. Fallback to default pool
        return this.defaultPoolId;
    }

    /**
     * Evaluate pool rules against an entity.
     * @private
     */
    _evaluatePoolRules(entity, rules) {
        if (!rules?.conditions || rules.conditions.length === 0) return 0;

        let score = 0;
        for (const condition of rules.conditions) {
            if (this._evaluatePoolCondition(entity, condition)) {
                score += condition.weight || 1;
            }
        }

        return score;
    }

    /**
     * Evaluate a single pool condition.
     * @private
     */
    _evaluatePoolCondition(entity, condition) {
        const { source, match, operator, value } = condition;

        switch (source) {
            case 'preset':
                // Match preset ID (supports glob-like * patterns)
                if (!entity.presetId) return false;
                return this._matchPattern(entity.presetId, match);

            case 'trait':
                // Check if entity has an active trait
                for (const layer of Object.values(entity.layers || {})) {
                    if (layer.active?.includes(match)) return true;
                }
                return false;

            case 'attribute':
                // Check attribute value
                const attrValue = entity.attributes?.[match];
                if (attrValue === undefined) return false;
                return this._evaluateOperator(attrValue, operator || 'eq', value);

            case 'variable':
                // Check variable value
                const varState = entity.variables?.[match];
                if (!varState) return false;
                return this._evaluateOperator(varState.value, operator || 'eq', value);

            case 'modifier':
                // Check if modifier is active
                return entity.modifiers?.some(m =>
                    typeof m === 'string' ? m === match : m.id === match
                );

            case 'compound':
                // Check if compound is active
                return entity.compounds?.some(c =>
                    typeof c === 'string' ? c === match : c.id === match
                );

            default:
                return false;
        }
    }

    /**
     * Match a string against a glob-like pattern.
     * @private
     */
    _matchPattern(str, pattern) {
        if (!pattern.includes('*')) return str === pattern;

        // Convert glob to regex
        const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
        return regex.test(str);
    }

    /**
     * Evaluate a comparison operator.
     * @private
     */
    _evaluateOperator(value, operator, target) {
        switch (operator) {
            case 'eq': return value === target;
            case 'ne': return value !== target;
            case 'gt': return value > target;
            case 'gte': return value >= target;
            case 'lt': return value < target;
            case 'lte': return value <= target;
            default: return false;
        }
    }

    // ========================================
    // SERIALIZATION
    // ========================================

    export() {
        // Export pools (excluding entities array and timeout)
        const poolsExport = Array.from(this.pools.entries()).map(([id, pool]) => [id, {
            id: pool.id,
            name: pool.name,
            description: pool.description,
            config: { ...pool.config },
            stats: { ...pool.stats },
            rules: pool.rules ? JSON.parse(JSON.stringify(pool.rules)) : null
        }]);

        return {
            presets: Array.from(this.presets.entries()),
            groups: Array.from(this.groups.entries()).map(([id, g]) => [id, {
                ...g, entities: Array.from(g.entities)
            }]),
            stored: Array.from(this.stored.entries()),
            active: Array.from(this.active.keys()),
            spawnContext: this.spawnContext,
            config: this.config,
            pools: poolsExport
        };
    }

    import(data) {
        if (data.presets) this.presets = new Map(data.presets);
        if (data.groups) {
            this.groups = new Map(data.groups.map(([id, g]) => [id, {
                ...g, entities: new Set(g.entities)
            }]));
        }
        if (data.stored) this.stored = new Map(data.stored);
        if (data.active) {
            for (const entityId of data.active) {
                const entity = this.stored.get(entityId);
                if (entity) this.active.set(entityId, entity);
            }
        }
        if (data.spawnContext) this.spawnContext = data.spawnContext;
        if (data.config) this.config = { ...this.config, ...data.config };

        // Import pools
        if (data.pools) {
            for (const [poolId, poolData] of data.pools) {
                if (poolId === this.defaultPoolId) {
                    // Update default pool
                    const defaultPool = this.pools.get(this.defaultPoolId);
                    defaultPool.name = poolData.name || defaultPool.name;
                    defaultPool.description = poolData.description || '';
                    defaultPool.config = { ...defaultPool.config, ...poolData.config };
                    defaultPool.rules = poolData.rules || null;
                    // Sync legacy references
                    this.poolConfig = { ...defaultPool.config };
                } else {
                    // Create or update other pools
                    this.createPool(poolId, {
                        name: poolData.name,
                        description: poolData.description,
                        ...poolData.config,
                        rules: poolData.rules
                    });
                }
            }
        }

        this.emit('dataImported', { data });
        return this;
    }

    // ========================================
    // EVENTS
    // ========================================

    on(event, callback) {
        if (!this.listeners.has(event)) this.listeners.set(event, new Set());
        this.listeners.get(event).add(callback);
        return () => this.off(event, callback);
    }

    off(event, callback) { this.listeners.get(event)?.delete(callback); }

    emit(event, data = {}) {
        this.listeners.get(event)?.forEach(cb => {
            try { cb(data); } catch (e) { console.error(`EntityManager event error (${event}):`, e); }
        });
    }
}


// ============================================================================
// SPAWN ENGINE - Convenience Wrapper (Backward Compatible)
// ============================================================================

/**
 * Main entry point combining SpawnManager and EntityManager into a unified API.
 * This is the recommended class for most use cases.
 *
 * Provides convenient methods for:
 * - Spawning entities (random or from presets)
 * - Managing entity lifecycle (activate, tick, despawn)
 * - Modifying runtime state (variables, modifiers, traits)
 * - Querying entity state
 * - Subscribing to events
 *
 * @class SpawnEngine
 * @example
 * // Create engine with config
 * const engine = new SpawnEngine(config);
 *
 * // Spawn entities
 * const entity = engine.spawn();
 * const warrior = engine.spawn('preset_warrior');
 *
 * // Tick in game loop
 * engine.tickAll(deltaTime);
 *
 * // Listen for events
 * engine.on('compoundActivated', (data) => {
 *   console.log('Compound activated:', data.compoundId);
 * });
 *
 * // Modify state
 * engine.modifyVariable(entity, 'var_hunger', -20);
 * engine.applyModifier(entity, 'mod_well_fed');
 *
 * // Query state
 * const state = engine.getState(entity.id);
 */
class SpawnEngine {
    /**
     * Create a new SpawnEngine instance.
     *
     * @param {Object|null} [config=null] - Configuration object to load
     * @example
     * const engine = new SpawnEngine(config);
     */
    constructor(config = null) {
        /** @type {SpawnManager} The SpawnManager for generation logic */
        this.spawnManager = new SpawnManager(config);
        /** @type {EntityManager} The EntityManager for runtime state */
        this.entityManager = new EntityManager();
        this.entityManager.linkSpawnManager(this.spawnManager);

        /** @type {Map<string, Object>} Internal entity storage for backward compatibility */
        this.entities = new Map();

        // Auto-load presets if config was provided
        if (config) {
            this._loadPresetsFromConfig();
        }
    }

    // ========================================
    // CONFIG (backward compatible)
    // ========================================

    loadConfig(config) {
        this.spawnManager.loadConfig(config);

        // Auto-register presets from config
        this._loadPresetsFromConfig();

        return this;
    }

    _loadPresetsFromConfig() {
        const cfg = this.spawnManager.config;
        if (!cfg) return;

        // Clear existing presets first (they may be from previous config)
        this.entityManager.presets.clear();
        this.entityManager.presetGroups.clear();

        // Register preset groups
        if (cfg.presetGroups && cfg.presetGroups.length > 0) {
            for (const group of cfg.presetGroups) {
                this.entityManager.presetGroups.set(group.id, {
                    id: group.id,
                    name: group.name || group.id,
                    description: group.description || ''
                });
            }
        }

        // Register presets
        if (cfg.presets && cfg.presets.length > 0) {
            for (const preset of cfg.presets) {
                this.entityManager.registerPreset(preset.id, preset);
            }
        }
    }

    get config() {
        return this.spawnManager.config;
    }

    // ========================================
    // GENERATION
    // ========================================

    /**
     * Spawn a new entity, optionally from a preset.
     *
     * @param {string|Object} [presetIdOrOverrides] - Preset ID or override object
     * @param {Object} [overrides={}] - Additional overrides when using preset
     * @param {Object} [overrides.attributes] - Attribute value overrides
     * @param {Object} [overrides.contexts] - Context value overrides
     * @param {string[]} [overrides.forceTraits] - Trait IDs to force-activate
     * @returns {Object} The spawned entity
     * @example
     * // Random generation
     * const entity = engine.spawn();
     *
     * // From preset
     * const patron = engine.spawn('preset_tavern_regular');
     *
     * // With overrides
     * const custom = engine.spawn({ attributes: { strength: 10 } });
     *
     * // Preset with overrides
     * const strong = engine.spawn('preset_warrior', { attributes: { strength: 10 } });
     */
    spawn(presetIdOrOverrides, overrides = {}) {
        let entity;

        if (presetIdOrOverrides === undefined) {
            // No args = random generation (backward compatible)
            entity = this.spawnManager.generate();
        } else if (typeof presetIdOrOverrides === 'string') {
            // String = preset ID
            entity = this.spawnManager.spawn(presetIdOrOverrides, overrides);
            if (!entity) {
                // Fallback to generate if preset not found
                entity = this.spawnManager.generate(overrides);
            }
        } else {
            // Object = overrides for generation
            entity = this.spawnManager.generate(presetIdOrOverrides);
        }

        if (entity) {
            this.entities.set(entity.id, entity);
            this.entityManager.store(entity);
            this.entityManager.activate(entity);
        }

        return entity;
    }

    generate(overrides = {}) {
        const entity = this.spawnManager.generate(overrides);
        if (entity) {
            this.entities.set(entity.id, entity);
            this.entityManager.store(entity);
        }
        return entity;
    }

    spawnWhere(query, overrides = {}) {
        const entity = this.spawnManager.spawnWhere(query, overrides);
        if (entity) {
            this.entities.set(entity.id, entity);
            this.entityManager.store(entity);
            this.entityManager.activate(entity);
        }
        return entity;
    }

    createSnapshot(overrides = {}) {
        return this.spawnManager.generate(overrides);
    }

    // ========================================
    // ENTITY ACCESS (backward compatible)
    // ========================================

    getEntity(entityId) {
        return this.entities.get(entityId) || this.entityManager.retrieve(entityId);
    }

    getAllEntities() {
        return Array.from(this.entities.values());
    }

    despawn(entityId) {
        this.entities.delete(entityId);
        return this.entityManager.remove(entityId);
    }

    register(entity) {
        if (!entity.id) {
            entity.id = `entity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        }
        this.entities.set(entity.id, entity);
        this.entityManager.store(entity);
        return entity;
    }

    // ========================================
    // PRESETS & GROUPS
    // ========================================

    registerPreset(id, template) {
        this.entityManager.registerPreset(id, template);
        return this;
    }

    registerPresets(presets) {
        this.entityManager.registerPresets(presets);
        return this;
    }

    getPreset(id) { return this.entityManager.getPreset(id); }
    listPresets(filter) { return this.entityManager.listPresets(filter); }

    createGroup(groupId, metadata = {}) {
        this.entityManager.createGroup(groupId, metadata);
        return this;
    }

    addToGroup(groupId, entityId) {
        this.entityManager.addToGroup(groupId, entityId);
        return this;
    }

    getGroup(groupId) { return this.entityManager.getGroup(groupId); }
    listGroups() { return this.entityManager.listGroups(); }

    // ========================================
    // SPAWN CONTEXT
    // ========================================

    setSpawnContext(context) {
        this.entityManager.setSpawnContext(context);
        return this;
    }

    getSpawnContext() { return this.entityManager.getSpawnContext(); }

    // ========================================
    // RUNTIME (backward compatible)
    // ========================================

    tick(entityOrId, deltaSeconds = null) {
        const entity = typeof entityOrId === 'string' ? this.getEntity(entityOrId) : entityOrId;
        if (!entity) return null;

        // Ensure entity is active for ticking
        if (!this.entityManager.isActive(entity.id)) {
            this.entityManager.activate(entity);
        }

        return this.entityManager.tick(entity.id, deltaSeconds);
    }

    tickAll(deltaSeconds = null) {
        // Activate all entities for ticking
        for (const entity of this.entities.values()) {
            if (!this.entityManager.isActive(entity.id)) {
                this.entityManager.activate(entity);
            }
        }
        this.entityManager.tickAll(deltaSeconds);
    }

    startAutoTick() {
        this.entityManager.startAutoTick(this.config.engineConfig.tickRate);
    }

    stopAutoTick() {
        this.entityManager.stopAutoTick();
    }

    modifyVariable(entity, varId, delta) {
        const entityObj = typeof entity === 'string' ? this.getEntity(entity) : entity;
        if (!entityObj) return false;
        return this.entityManager.modifyVariable(entityObj.id, varId, delta);
    }

    setVariable(entity, varId, value) {
        const entityObj = typeof entity === 'string' ? this.getEntity(entity) : entity;
        if (!entityObj) return false;
        return this.entityManager.setVariable(entityObj.id, varId, value);
    }

    applyModifier(entity, modifierId) {
        const entityObj = typeof entity === 'string' ? this.getEntity(entity) : entity;
        if (!entityObj) return false;

        const modifier = this.spawnManager.getNode(modifierId);
        const config = modifier?.config || {};

        return this.entityManager.applyModifier(entityObj.id, modifierId, config);
    }

    removeModifier(entity, modifierId) {
        const entityObj = typeof entity === 'string' ? this.getEntity(entity) : entity;
        if (!entityObj) return false;
        return this.entityManager.removeModifier(entityObj.id, modifierId);
    }

    activateTrait(entity, traitId) {
        const entityObj = typeof entity === 'string' ? this.getEntity(entity) : entity;
        if (!entityObj) return false;
        return this.entityManager.activateTrait(entityObj.id, traitId);
    }

    // Backward compatibility alias
    activateItem(entity, itemId) {
        return this.activateTrait(entity, itemId);
    }

    deactivateTrait(entity, traitId) {
        const entityObj = typeof entity === 'string' ? this.getEntity(entity) : entity;
        if (!entityObj) return false;
        return this.entityManager.deactivateTrait(entityObj.id, traitId);
    }

    // Backward compatibility alias
    deactivateItem(entity, itemId) {
        return this.deactivateTrait(entity, itemId);
    }

    // ========================================
    // STATE
    // ========================================

    getState(entityId) {
        return this.entityManager.getState(entityId);
    }

    snapshot(entityId) { return this.entityManager.snapshot(entityId); }
    getHistory(entityId) { return this.entityManager.getHistory(entityId); }
    rollback(entityId, timestamp) { return this.entityManager.rollback(entityId, timestamp); }
    query(filter) { return this.entityManager.query(filter); }

    // ========================================
    // NODE QUERIES (backward compatible)
    // ========================================

    getNode(nodeId) { return this.spawnManager.getNode(nodeId); }
    getNodesByType(type) { return this.spawnManager.getNodesByType(type); }
    getAttributes() { return this.spawnManager.getAttributes(); }
    getVariables() { return this.spawnManager.getVariables(); }
    getContexts() { return this.spawnManager.getContexts(); }
    getLayers() { return this.spawnManager.getLayers(); }
    getLayerTraits(layerId) { return this.spawnManager.getLayerTraits(layerId); }
    getLayerItems(layerId) { return this.spawnManager.getLayerTraits(layerId); }
    getTraits() { return this.spawnManager.getTraits(); }
    getModifiers() { return this.spawnManager.getModifiers(); }
    getCompounds() { return this.spawnManager.getCompounds(); }
    getDerived() { return this.spawnManager.getDerived(); }
    getActions() { return this.spawnManager.getActions(); }
    getNodesByTaxonomy(filter) { return this.spawnManager.getNodesByTaxonomy(filter); }
    getTaxonomyValues(level) { return this.spawnManager.getTaxonomyValues(level); }

    // ========================================
    // ACTION SYSTEM
    // ========================================

    /**
     * Check if an action is available for an entity.
     * @param {string|Object} entityOrId - Entity or entity ID
     * @param {string} actionId - Action ID
     * @returns {boolean}
     */
    isActionAvailable(entityOrId, actionId) {
        const entity = typeof entityOrId === 'string'
            ? this.entityManager.getEntity(entityOrId)
            : entityOrId;
        return this.spawnManager.isActionAvailable(entity, actionId);
    }

    /**
     * Get all available actions for an entity.
     * @param {string|Object} entityOrId - Entity or entity ID
     * @returns {Array<{id, weight, action}>}
     */
    getAvailableActions(entityOrId) {
        const entity = typeof entityOrId === 'string'
            ? this.entityManager.getEntity(entityOrId)
            : entityOrId;
        return this.spawnManager.getAvailableActions(entity);
    }

    /**
     * Select an action using weighted random.
     * @param {string|Object} entityOrId - Entity or entity ID
     * @returns {Object|null} {id, weight, action} or null
     */
    selectAction(entityOrId) {
        const entity = typeof entityOrId === 'string'
            ? this.entityManager.getEntity(entityOrId)
            : entityOrId;
        return this.spawnManager.selectAction(entity);
    }

    /**
     * Execute an action, deducting costs and starting cooldown.
     * @param {string|Object} entityOrId - Entity or entity ID
     * @param {string} actionId - Action ID
     * @returns {Object} {success, actionId, effects, action} or {success: false, reason}
     */
    executeAction(entityOrId, actionId) {
        const entity = typeof entityOrId === 'string'
            ? this.entityManager.getEntity(entityOrId)
            : entityOrId;
        return this.spawnManager.executeAction(entity, actionId);
    }

    /**
     * Get action cooldown status.
     * @param {string|Object} entityOrId - Entity or entity ID
     * @param {string} actionId - Action ID
     * @returns {Object} {cooldownRemaining, cooldownTotal, ready}
     */
    getActionCooldown(entityOrId, actionId) {
        const entity = typeof entityOrId === 'string'
            ? this.entityManager.getEntity(entityOrId)
            : entityOrId;
        return this.spawnManager.getActionCooldown(entity, actionId);
    }

    // ========================================
    // OUTCOME LAYERS
    // ========================================

    /**
     * Roll an outcome layer - clears previous results and rolls fresh.
     * Use for layers with timing.rollAt = 'manual', like attack/defense outcomes.
     * @param {string|Object} entityOrId - Entity or entity ID
     * @param {string} layerId - The layer to roll
     * @param {number} [rolls=1] - Number of times to roll
     * @returns {Object} {success, selected, previousActive, layerId}
     * @example
     * // Define attack outcome layer with timing.rollAt = 'manual'
     * // Then roll outcomes during combat
     * const result = engine.rollOutcome(attacker, 'layer_attack_outcome');
     * if (result.selected.includes('item_critical')) {
     *   damage *= 2;
     * }
     */
    rollOutcome(entityOrId, layerId, rolls = 1) {
        const entity = typeof entityOrId === 'string'
            ? this.entityManager.getEntity(entityOrId)
            : entityOrId;
        return this.spawnManager.rollOutcome(entity, layerId, rolls);
    }

    /**
     * Roll a layer and add to existing active items (doesn't clear first).
     * @param {string|Object} entityOrId - Entity or entity ID
     * @param {string} layerId - The layer to roll
     * @returns {Object} Roll result
     */
    rollLayer(entityOrId, layerId) {
        const entity = typeof entityOrId === 'string'
            ? this.entityManager.getEntity(entityOrId)
            : entityOrId;
        return this.spawnManager.rollLayer(entity, layerId);
    }

    // ========================================
    // RELATIONSHIP QUERIES (backward compatible)
    // ========================================

    getRelationshipsFrom(nodeId) { return this.spawnManager.getRelationshipsFrom(nodeId); }
    getRelationshipsTo(nodeId) { return this.spawnManager.getRelationshipsTo(nodeId); }
    getRelationshipsByType(type) { return this.spawnManager.getRelationshipsByType(type); }

    // ========================================
    // ANALYSIS
    // ========================================

    getWeights(entity, layerId) { return this.spawnManager.getWeights(entity, layerId); }
    previewInfluences(nodeId) { return this.spawnManager.previewInfluences(nodeId); }

    // ========================================
    // EVENTS
    // ========================================

    on(event, callback) {
        return this.entityManager.on(event, callback);
    }

    emit(event, data) {
        this.entityManager.emit(event, data);
    }

    // ========================================
    // SERIALIZATION
    // ========================================

    exportEntity(entityId) {
        const entity = this.getEntity(entityId);
        if (!entity) return null;
        return JSON.parse(JSON.stringify(entity));
    }

    importEntity(data) {
        const entity = JSON.parse(JSON.stringify(data));
        this.entities.set(entity.id, entity);
        this.entityManager.store(entity);
        return entity.id;
    }

    export() {
        return {
            config: this.spawnManager.config,
            entityManager: this.entityManager.export()
        };
    }

    import(data) {
        if (data.config) this.spawnManager.loadConfig(data.config);
        if (data.entityManager) this.entityManager.import(data.entityManager);
        return this;
    }

    // ========================================
    // ENTITY POOLING
    // ========================================

    /**
     * Configure the entity pool for high-frequency spawn/despawn scenarios.
     *
     * @param {Object} config - Pool configuration
     * @param {number} [config.maxSize=100] - Maximum entities to keep in pool
     * @param {number} [config.preWarm=0] - Number of entities to pre-create
     * @param {string} [config.preWarmPreset=null] - Preset to use for pre-warming
     * @returns {SpawnEngine} This instance for chaining
     * @example
     * // Setup for JRPG combat
     * engine.configurePool({
     *   maxSize: 50,
     *   preWarm: 10,
     *   preWarmPreset: 'enemy_basic'
     * });
     *
     * // Combat loop
     * const enemy = engine.acquire('enemy_goblin');
     * // ... combat ...
     * engine.release(enemy);
     */
    configurePool(config) {
        this.entityManager.configurePool(config);
        return this;
    }

    /**
     * Acquire an entity from pool or create new.
     * Faster than spawn() for frequent spawn/despawn patterns.
     *
     * @param {string|Object} [presetIdOrOverrides] - Preset ID or overrides
     * @param {Object} [overrides={}] - Additional overrides
     * @returns {Object} The acquired entity (active and ready to use)
     * @example
     * // Start combat encounter
     * const enemies = [
     *   engine.acquire('enemy_goblin'),
     *   engine.acquire('enemy_goblin'),
     *   engine.acquire('enemy_orc', { attributes: { strength: 15 } })
     * ];
     */
    acquire(presetIdOrOverrides, overrides = {}) {
        const entity = this.entityManager.acquire(presetIdOrOverrides, overrides);
        if (entity) {
            this.entities.set(entity.id, entity);
        }
        return entity;
    }

    /**
     * Release an entity back to the pool for reuse.
     *
     * @param {Object|string} entityOrId - Entity or entity ID
     * @returns {boolean} True if released to pool
     * @example
     * // Enemy defeated
     * engine.release(enemy);
     *
     * // Release all enemies after combat
     * enemies.forEach(e => engine.release(e));
     */
    release(entityOrId) {
        const entityId = typeof entityOrId === 'string' ? entityOrId : entityOrId?.id;
        this.entities.delete(entityId);
        return this.entityManager.release(entityOrId);
    }

    /**
     * Pre-warm the pool with entities.
     *
     * @param {number} count - Number of entities to pre-create
     * @param {string} [presetId] - Preset to use
     * @param {string} [poolId] - Target pool (defaults to default)
     * @returns {SpawnEngine} This instance for chaining
     * @example
     * // Before wave-based combat
     * engine.preWarmPool(30, 'enemy_basic');
     *
     * // Pre-warm specific pool
     * engine.preWarmPool(20, 'goblin', 'enemies');
     */
    preWarmPool(count, presetId = null, poolId = null) {
        this.entityManager.preWarmPool(count, presetId, poolId);
        return this;
    }

    /**
     * Get current pool statistics.
     *
     * @param {string} [poolId] - Pool ID (defaults to default pool)
     * @returns {Object} Pool stats (size, available, inUse, totals)
     */
    getPoolStats(poolId = null) {
        return this.entityManager.getPoolStats(poolId);
    }

    // ========================================
    // MULTI-POOL MANAGEMENT
    // ========================================

    /**
     * Create a new named entity pool.
     *
     * @param {string} poolId - Unique pool identifier
     * @param {Object} [options={}] - Pool configuration
     * @returns {Object} The created pool instance
     * @example
     * engine.createPool('enemies', {
     *   name: 'Enemy Pool',
     *   maxSize: 50,
     *   preWarm: 10,
     *   preWarmPreset: 'goblin',
     *   rules: { conditions: [{ source: 'preset', match: 'enemy_*' }] }
     * });
     */
    createPool(poolId, options = {}) {
        return this.entityManager.createPool(poolId, options);
    }

    /**
     * Get a pool by ID.
     *
     * @param {string} poolId - Pool identifier
     * @returns {Object|null} The pool instance or null
     */
    getPool(poolId) {
        return this.entityManager.getPool(poolId);
    }

    /**
     * List all pools.
     *
     * @returns {Array<Object>} Array of pool summaries
     */
    listPools() {
        return this.entityManager.listPools();
    }

    /**
     * Remove a pool. Entities are moved to default pool.
     *
     * @param {string} poolId - Pool to remove
     * @returns {boolean} True if removed
     */
    removePool(poolId) {
        return this.entityManager.removePool(poolId);
    }

    /**
     * Move an entity to a different pool.
     *
     * @param {Object|string} entityOrId - Entity or entity ID
     * @param {string} targetPoolId - Target pool
     * @returns {boolean} True if moved
     */
    moveToPool(entityOrId, targetPoolId) {
        return this.entityManager.moveToPool(entityOrId, targetPoolId);
    }

    /**
     * Set assignment rules for a pool.
     *
     * @param {string} poolId - Pool to configure
     * @param {Object} rules - Assignment rules
     * @returns {SpawnEngine} This instance for chaining
     */
    setPoolRules(poolId, rules) {
        this.entityManager.setPoolRules(poolId, rules);
        return this;
    }

    /**
     * Determine which pool an entity should belong to.
     *
     * @param {Object} entity - Entity to evaluate
     * @returns {string} Pool ID
     */
    getPoolForEntity(entity) {
        return this.entityManager.getPoolForEntity(entity);
    }

    /**
     * Get statistics for all pools.
     *
     * @returns {Object} Map of poolId to stats
     */
    getAllPoolStats() {
        return this.entityManager.getAllPoolStats();
    }

    /**
     * Clear a specific pool.
     *
     * @param {string} [poolId] - Pool to clear (defaults to default)
     * @returns {SpawnEngine} This instance for chaining
     */
    clearPool(poolId = null) {
        this.entityManager.clearPool(poolId);
        return this;
    }
}


// ============================================================================
// CSV IMPORTER
// ============================================================================

class CSVImporter {
    /**
     * Parse CSV string into array of objects.
     */
    static parse(csvString, options = {}) {
        const delimiter = options.delimiter || ',';
        const lines = csvString.trim().split(/\r?\n/);

        if (lines.length < 2) return [];

        const headers = this.parseLine(lines[0], delimiter);
        const rows = [];

        for (let i = 1; i < lines.length; i++) {
            const values = this.parseLine(lines[i], delimiter);
            if (values.length === 0 || (values.length === 1 && values[0] === '')) continue;

            const row = {};
            for (let j = 0; j < headers.length; j++) {
                const header = headers[j].trim();
                let value = values[j]?.trim() || '';

                // Auto-convert types
                if (value === 'true') value = true;
                else if (value === 'false') value = false;
                else if (value !== '' && !isNaN(value)) value = parseFloat(value);

                row[header] = value;
            }
            rows.push(row);
        }

        return rows;
    }

    static parseLine(line, delimiter) {
        const values = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
            const char = line[i];

            if (char === '"') {
                if (inQuotes && line[i + 1] === '"') {
                    current += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (char === delimiter && !inQuotes) {
                values.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        values.push(current);

        return values;
    }

    /**
     * Import attributes from CSV.
     * Expected columns: id, name, description, min, max, default_min, default_max, precision
     */
    static importAttributes(csvString, config) {
        const rows = this.parse(csvString);
        const nodes = [];

        for (const row of rows) {
            if (!row.id) continue;

            nodes.push({
                id: row.id,
                name: row.name || row.id,
                description: row.description || '',
                type: 'attribute',
                config: {
                    min: row.min ?? 0,
                    max: row.max ?? 100,
                    defaultRange: [row.default_min ?? row.min ?? 0, row.default_max ?? row.max ?? 100],
                    precision: row.precision ?? 0
                }
            });
        }

        config.nodes = config.nodes.filter(n => n.type !== 'attribute');
        config.nodes.push(...nodes);

        return nodes;
    }

    /**
     * Import variables from CSV.
     * Expected columns: id, name, description, min, max, initial, base_rate, change_mode, direction
     */
    static importVariables(csvString, config) {
        const rows = this.parse(csvString);
        const nodes = [];

        for (const row of rows) {
            if (!row.id) continue;

            nodes.push({
                id: row.id,
                name: row.name || row.id,
                description: row.description || '',
                type: 'variable',
                config: {
                    min: row.min ?? 0,
                    max: row.max ?? 100,
                    initial: row.initial ?? row.max ?? 100,
                    baseRate: row.base_rate ?? 0,
                    changeMode: row.change_mode || 'manual',
                    direction: row.direction || 'none'
                }
            });
        }

        config.nodes = config.nodes.filter(n => n.type !== 'variable');
        config.nodes.push(...nodes);

        return nodes;
    }

    /**
     * Import traits from CSV.
     * Expected columns: id, name, description, layer, base_weight
     */
    static importTraits(csvString, config) {
        const rows = this.parse(csvString);
        const nodes = [];
        const layerTraits = new Map();

        for (const row of rows) {
            if (!row.id || !row.layer) continue;

            nodes.push({
                id: row.id,
                name: row.name || row.id,
                description: row.description || '',
                type: 'trait',
                config: {
                    layerId: row.layer,
                    selection: {
                        baseWeight: row.base_weight ?? 20
                    }
                }
            });

            if (!layerTraits.has(row.layer)) {
                layerTraits.set(row.layer, []);
            }
            layerTraits.get(row.layer).push(row.id);
        }

        // Remove existing traits and add new ones
        config.nodes = config.nodes.filter(n => n.type !== 'trait' && n.type !== 'item');
        config.nodes.push(...nodes);

        // Update layer traitIds
        for (const [layerId, traitIds] of layerTraits) {
            const layer = config.nodes.find(n => n.id === layerId && n.type === 'layer');
            if (layer) {
                layer.config.traitIds = traitIds;
            }
        }

        return nodes;
    }

    /**
     * Import layers from CSV.
     * Expected columns: id, name, description, order, selection_mode, max_items, initial_rolls, roll_at
     */
    static importLayers(csvString, config) {
        const rows = this.parse(csvString);
        const nodes = [];

        for (const row of rows) {
            if (!row.id) continue;

            nodes.push({
                id: row.id,
                name: row.name || row.id,
                description: row.description || '',
                type: 'layer',
                config: {
                    order: row.order ?? 0,
                    selection: {
                        mode: row.selection_mode || 'weighted',
                        maxItems: row.max_items ?? 10,
                        initialRolls: row.initial_rolls ?? 1
                    },
                    timing: {
                        rollAt: row.roll_at || 'spawn'
                    },
                    traitIds: []
                }
            });
        }

        config.nodes = config.nodes.filter(n => n.type !== 'layer');
        config.nodes.push(...nodes);

        return nodes;
    }

    /**
     * Import presets from CSV.
     * Expected columns: id, name, description, tags, force_traits, [attribute columns...]
     */
    static importPresets(csvString, entityManager) {
        const rows = this.parse(csvString);
        const presets = [];

        for (const row of rows) {
            if (!row.id) continue;

            const preset = {
                id: row.id,
                name: row.name || row.id,
                description: row.description || '',
                tags: row.tags ? row.tags.split('|').map(t => t.trim()) : [],
                forceTraits: row.force_traits ? row.force_traits.split('|').map(t => t.trim()) : [],
                attributes: {}
            };

            // Collect attribute overrides (any column starting with 'attr_')
            for (const [key, value] of Object.entries(row)) {
                if (key.startsWith('attr_') && typeof value === 'number') {
                    preset.attributes[key] = value;
                }
            }

            presets.push(preset);
            entityManager.registerPreset(row.id, preset);
        }

        return presets;
    }

    /**
     * Import relationships from CSV.
     * Expected columns: id, source, target, type, operation, value, scaling, per_point_source
     */
    static importRelationships(csvString, config) {
        const rows = this.parse(csvString);
        const relationships = [];

        for (const row of rows) {
            if (!row.source || !row.target || !row.type) continue;

            relationships.push({
                id: row.id || `rel_${row.source}_${row.target}`,
                sourceId: row.source,
                targetId: row.target,
                type: row.type,
                config: {
                    operation: row.operation || 'add',
                    value: row.value ?? 0,
                    scaling: row.scaling || 'flat',
                    perPointSource: row.per_point_source || null
                }
            });
        }

        config.relationships = config.relationships.filter(r =>
            !relationships.find(nr => nr.id === r.id)
        );
        config.relationships.push(...relationships);

        return relationships;
    }
}


// ============================================================================
// EXPORTS
// ============================================================================

// Browser globals
if (typeof window !== 'undefined') {
    window.SpawnEngine = SpawnEngine;
    window.SpawnManager = SpawnManager;
    window.EntityManager = EntityManager;
    window.CSVImporter = CSVImporter;
}

// Node.js exports
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { SpawnEngine, SpawnManager, EntityManager, CSVImporter };
}

</script>
    <script>
// ============================================================================
// UTILS
// ============================================================================

/**
 * Spawn Editor - Utility Functions
 * Shared helpers for storage, notifications, and common operations
 */

// ========================================
// STORAGE
// ========================================

const STORAGE_KEYS = {
    CONFIG: 'spawnEditorConfig',
    ENTITIES: 'spawnEditorEntities',
    TUTORIAL_SEEN: 'spawnEditorTutorialSeen'
};

function loadFromStorage(key) {
    try {
        const saved = localStorage.getItem(key);
        return saved ? JSON.parse(saved) : null;
    } catch (e) {
        console.error(`Failed to load from storage (${key}):`, e);
        return null;
    }
}

function saveToStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (e) {
        console.error(`Failed to save to storage (${key}):`, e);
    }
}

// ========================================
// NOTIFICATIONS
// ========================================

// Toast notification
// showToast(message)                    â€” default success, 2s
// showToast(message, 'warning')         â€” colored by type, 2s
// showToast(message, 'error', 4000)     â€” colored, 4s
// showToast(message, 4000)              â€” default color, 4s (duration shorthand)
function showToast(message, typeOrDuration = 'success', duration) {
    // Support shorthand: showToast(msg, 4000)
    let type = 'success';
    let ms = 2000;
    if (typeof typeOrDuration === 'number') {
        ms = typeOrDuration;
    } else if (typeof typeOrDuration === 'string') {
        type = typeOrDuration;
        ms = duration || 2000;
    }

    // Remove existing toast
    const existing = document.querySelector('.utils-toast');
    if (existing) existing.remove();

    const colors = {
        success: 'var(--accent-success, #4a7c59)',
        warning: 'var(--accent-warning, #b87333)',
        error: 'var(--accent-danger, #a65d5d)',
        info: 'var(--accent-primary, #7c6f9f)'
    };

    const toast = document.createElement('div');
    toast.className = 'utils-toast';
    toast.style.cssText = `
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: ${colors[type] || colors.success};
        color: white;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-size: 0.85rem;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.2s ease, transform 0.2s ease;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    // Animate in
    requestAnimationFrame(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateX(-50%) translateY(0)';
    });

    // Animate out after duration
    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(-50%) translateY(-10px)';
        setTimeout(() => toast.remove(), 300);
    }, ms);
}

// ========================================
// MODAL HELPERS
// ========================================

function showModal(modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
        modal.classList.add('active');
    }
}

function closeModal(modalId) {
    if (modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
            modal.classList.remove('side-panel-mode');
            modal.classList.remove('sidebar-mode');
        }
    } else {
        // Close all modals if no ID provided
        document.querySelectorAll('.modal-overlay.active').forEach(m => {
            m.classList.remove('active');
            m.classList.remove('side-panel-mode');
            m.classList.remove('sidebar-mode');
        });
    }
    // Remove sidebar-modal-active class if no sidebar modals are open
    const activeSidebarModals = document.querySelectorAll('.modal-overlay.sidebar-mode.active');
    if (activeSidebarModals.length === 0) {
        document.body.classList.remove('sidebar-modal-active');
    }
}

// ========================================
// NODE HELPERS
// ========================================

/**
 * Extract node ID from compound requirement
 * Handles both string IDs and object format { item: "id" }, { trait: "id" }, etc.
 */
function getRequiredNodeId(req) {
    if (typeof req === 'string') return req;
    if (typeof req === 'object') {
        return req.item || req.modifier || req.trait || req.attribute || req.variable || req.id || null;
    }
    return null;
}

/**
 * Get display color for a node type
 */
function getNodeColor(type) {
    const colors = {
        attribute: 'var(--node-attribute)',
        variable: 'var(--node-variable)',
        context: 'var(--node-context)',
        layer: 'var(--node-layer)',
        item: 'var(--node-item)',
        trait: 'var(--node-trait)',
        modifier: 'var(--node-modifier)',
        compound: 'var(--node-compound)',
        derived: 'var(--node-derived)'
    };
    return colors[type] || 'var(--border-color)';
}

/**
 * Get icon for a node type
 */
function getNodeIcon(type) {
    const icons = {
        attribute: 'A',
        variable: 'V',
        context: 'C',
        layer: 'L',
        trait: 'T',
        modifier: 'M',
        compound: 'â˜…',
        derived: 'D'
    };
    return icons[type] || '?';
}

// ========================================
// ID GENERATION
// ========================================

/**
 * Generate a slug-style ID from a name
 */
function generateIdFromName(name) {
    return name
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');
}

/**
 * Generate a unique ID with optional prefix
 */
function generateUniqueId(prefix = 'node') {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// ========================================
// DEBOUNCE / THROTTLE
// ========================================

function debounce(fn, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn.apply(this, args), delay);
    };
}

function throttle(fn, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            fn.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// ========================================
// EXPORTS (for module usage)
// ========================================

// Browser globals for non-module usage
if (typeof window !== 'undefined') {
    window.STORAGE_KEYS = STORAGE_KEYS;
    window.loadFromStorage = loadFromStorage;
    window.saveToStorage = saveToStorage;
    window.showToast = showToast;
    window.showModal = showModal;
    window.closeModal = closeModal;
    window.getRequiredNodeId = getRequiredNodeId;
    window.getNodeColor = getNodeColor;
    window.getNodeIcon = getNodeIcon;
    window.generateIdFromName = generateIdFromName;
    window.generateUniqueId = generateUniqueId;
    window.debounce = debounce;
    window.throttle = throttle;
}

</script>
    <script>
// ============================================================================
// TUTORIAL
// ============================================================================

/**
 * Spawn Editor - Tutorial System
 * Interactive tutorial content and navigation
 */

// ========================================
// TUTORIAL CONTENT
// ========================================

const tutorialSteps = [
    {
        title: 'Welcome to Spawn Engine',
        icon: null,
        description: `
            <p>The Spawn Engine is a <strong>two-part system</strong> for generating and managing entities:</p>
            <div style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-attribute);">
                    <div style="font-weight: 600; margin-bottom: 0.25rem;">ðŸŽ² Spawner</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Roll attributes, select from layers, output entity snapshot</div>
                </div>
                <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-variable);">
                    <div style="font-weight: 600; margin-bottom: 0.25rem;">â±ï¸ Entity Manager</div>
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Track state over time, apply modifiers, check compounds</div>
                </div>
            </div>
            <p style="margin-top: 0.75rem;">This tutorial explains each concept. You'll see examples from different game types to understand how flexible the system is.</p>
        `,
        tip: 'The building blocks are universal, but your configuration makes them specific. A "Layer" might hold personality traits OR monster types - it depends on what you need!',
        examples: null
    },
    {
        title: 'Attributes (Spawner)',
        icon: 'var(--node-attribute)',
        description: `
            <p><strong>Attributes</strong> are <em>numeric values assigned at spawn</em> that serve as fundamental stats for the entity. They can change via game events (like leveling up) but typically remain stable.</p>
            <p style="margin-top: 0.75rem;">Think of attributes as the entity's core stats. They influence which traits get selected and can affect variable rates.</p>
        `,
        tip: 'Attributes are for numbers. If you want a choice from a list (warrior/mage/rogue), use a Layer instead!',
        examples: [
            { icon: 'ðŸº', game: 'Tavern Patron', desc: 'Patience (1-10), Generosity, Charm - core personality stats' },
            { icon: 'âš”ï¸', game: 'RPG Monster', desc: 'Strength, Speed, Intelligence - base stats that can grow' },
            { icon: 'ðŸ ', game: 'Colony Citizen', desc: 'Skill, Health, Social - innate capabilities' },
            { icon: 'ðŸ’•', game: 'Dating Sim', desc: 'Charm, Wit, Kindness, Confidence - character stats' }
        ]
    },
    {
        title: 'Layers & Traits (Spawner)',
        icon: 'var(--node-layer)',
        description: `
            <p><strong>Layers</strong> are organizational containers - like folders - that group <strong>Traits</strong>. While attributes are <em>numbers</em>, traits are <em>categorical flags</em> - things an entity either has or doesn't.</p>
            <p style="margin-top: 0.75rem;">Each layer defines selection logic: weighted random, pick N, first match, etc. Traits within layers can be influenced by attributes and other traits through relationships.</p>
        `,
        tip: 'Monster species, character class, personality traits - anything that\'s "one of these options" belongs in a layer!',
        examples: [
            { icon: 'âš”ï¸', game: 'RPG Monster', desc: 'Layer: Species â†’ Goblin, Orc, Dragon. Layer: Behavior â†’ Aggressive, Defensive' },
            { icon: 'ðŸº', game: 'Tavern Patron', desc: 'Layer: Personality (max 3) â†’ Optimist, Grumpy, Social. Layer: Mood (dynamic)' },
            { icon: 'ðŸ ', game: 'Colony Citizen', desc: 'Layer: Profession â†’ Farmer, Builder, Guard. Layer: Personality traits' },
            { icon: 'ðŸ’•', game: 'Dating Sim', desc: 'Layer: Archetype â†’ Shy, Outgoing, Mysterious. Layer: Interests (multiple)' }
        ]
    },
    {
        title: 'Relationships',
        icon: 'var(--accent-primary)',
        description: `
            <p><strong>Relationships</strong> connect nodes together. They define how one thing influences another - changing weights, modifying rates, or gating eligibility.</p>
            <p style="margin-top: 0.75rem;">This is where the magic happens! Relationships create emergent complexity from simple parts.</p>
        `,
        tip: 'A good spawn system has many relationships. They\'re what make entities feel unique and reactive!',
        examples: [
            { icon: 'âž•', game: 'Weight Influence', desc: '"Optimist" adds +30 weight to "Cheerful" (more likely to select)' },
            { icon: 'âš¡', game: 'Rate Modifier', desc: '"High Patience" multiplies boredom rate by 0.5 (slower buildup)' },
            { icon: 'ðŸš«', game: 'Eligibility Gate', desc: '"Introverted" blocks "Social Butterfly" from being selected' },
            { icon: 'ðŸ”„', game: 'Replaces', desc: '"Starving" replaces "Hungry" when hunger gets critical' }
        ]
    },
    {
        title: 'Variables (Entity Manager)',
        icon: 'var(--node-variable)',
        description: `
            <p><strong>Variables</strong> are <em>values that change during gameplay</em>. The Entity Manager tracks these over time - they can deplete, accumulate, or respond to events.</p>
            <p style="margin-top: 0.75rem;">Variables create urgency and drama. When they cross thresholds, they can trigger traits (like "Starving" when hunger hits 0) or affect derived values.</p>
        `,
        tip: 'Variables + Thresholds = Emergent behavior! A patron getting hungry â†’ irritable â†’ causing trouble is all driven by variable changes.',
        examples: [
            { icon: 'ðŸº', game: 'Tavern Patron', desc: 'Hunger (depletes), Boredom (accumulates), Intoxication' },
            { icon: 'âš”ï¸', game: 'RPG Monster', desc: 'Health (bounded), Rage (accumulates), Stamina (depletes)' },
            { icon: 'ðŸ ', game: 'Colony Citizen', desc: 'Energy (depletes), Happiness (responds to events), Hunger' },
            { icon: 'ðŸ’•', game: 'Dating Sim', desc: 'Affection (events), Trust (slow build), Tension (accumulates)' }
        ]
    },
    {
        title: 'Modifiers (Entity Manager)',
        icon: 'var(--node-modifier)',
        description: `
            <p><strong>Modifiers</strong> are <em>temporary effects</em> that can be applied and removed during gameplay. They have duration (timed, tick-based, or permanent) and stacking behavior.</p>
            <p style="margin-top: 0.75rem;">Modifiers can influence variable rates, trait weights, or eligibility - just like traits, but temporary.</p>
        `,
        tip: 'Use modifiers for buffs, debuffs, status effects - anything that comes and goes during gameplay!',
        examples: [
            { icon: 'âš”ï¸', game: 'RPG Monster', desc: 'Enraged (10s), Stunned (2s), Poisoned (30s tick damage)' },
            { icon: 'ðŸº', game: 'Tavern Patron', desc: 'Well-Fed (removes hunger effects), Tipsy (affects behavior)' },
            { icon: 'ðŸ ', game: 'Colony Citizen', desc: 'Sick (reduces work rate), Inspired (bonus productivity)' },
            { icon: 'ðŸ’•', game: 'Dating Sim', desc: 'Impressed (temp +trust), Offended (temp -affection)' }
        ]
    },
    {
        title: 'Compounds (Entity Manager)',
        icon: 'var(--node-compound)',
        description: `
            <p><strong>Compounds</strong> are <em>emergent states</em> that automatically form when multiple conditions are met. They represent combinations that create something new.</p>
            <p style="margin-top: 0.75rem;">The Entity Manager continuously checks compound requirements. When all conditions are met, the compound forms. When they break, it dissolves.</p>
        `,
        tip: 'Compounds create emergent storytelling! "Hangry" isn\'t assigned - it emerges from being both Starving AND Grumpy.',
        examples: [
            { icon: 'ðŸº', game: 'Tavern Patron', desc: 'Hangry = Starving + Grumpy. Jolly-Drunk = Tipsy + Optimist' },
            { icon: 'âš”ï¸', game: 'RPG Monster', desc: 'Berserk = Low Health + High Rage. Cornered = Low Stamina + Surrounded' },
            { icon: 'ðŸ ', game: 'Colony Citizen', desc: 'Burnout = Exhausted + High Stress. Content = Well-Fed + Low Stress' },
            { icon: 'ðŸ’•', game: 'Dating Sim', desc: 'Crushing = High Affection + Shy. Heartbroken = Low Trust + Recent Rejection' }
        ]
    },
    {
        title: 'Ready to Build!',
        icon: null,
        description: `
            <p>You now understand the two-part system! Here's the typical workflow:</p>
            <div style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div>
                    <div style="font-weight: 600; color: var(--node-attribute); margin-bottom: 0.5rem;">ðŸŽ² Spawner Setup</div>
                    <ol style="padding-left: 1.25rem; color: var(--text-secondary); font-size: 0.85rem;">
                        <li style="margin-bottom: 0.35rem;">Define <strong>Attributes</strong> (numeric stats)</li>
                        <li style="margin-bottom: 0.35rem;">Create <strong>Layers</strong> (trait categories)</li>
                        <li style="margin-bottom: 0.35rem;">Add <strong>Traits</strong> to layers</li>
                        <li>Add <strong>Relationships</strong> (weights/gates)</li>
                    </ol>
                </div>
                <div>
                    <div style="font-weight: 600; color: var(--node-variable); margin-bottom: 0.5rem;">â±ï¸ Entity Manager Setup</div>
                    <ol style="padding-left: 1.25rem; color: var(--text-secondary); font-size: 0.85rem;">
                        <li style="margin-bottom: 0.35rem;">Add <strong>Variables</strong> (changing values)</li>
                        <li style="margin-bottom: 0.35rem;">Create <strong>Modifiers</strong> (temp effects)</li>
                        <li style="margin-bottom: 0.35rem;">Define <strong>Compounds</strong> (emergent states)</li>
                        <li>Add rate/value <strong>Relationships</strong></li>
                    </ol>
                </div>
            </div>
        `,
        tip: 'Start simple! You can always add complexity later. Even 2-3 attributes and a single layer can create interesting variety.',
        examples: null
    }
];

// ========================================
// TUTORIAL STATE
// ========================================

let tutorialStep = 0;
let hasSeenTutorial = false;

function initTutorial() {
    hasSeenTutorial = localStorage.getItem('spawnEditorTutorialSeen') === 'true';
}

// ========================================
// TUTORIAL FUNCTIONS
// ========================================

function showTutorial() {
    tutorialStep = 0;
    document.getElementById('tutorialOverlay').classList.add('active');
    renderTutorialStep();
}

function closeTutorial() {
    document.getElementById('tutorialOverlay').classList.remove('active');
    localStorage.setItem('spawnEditorTutorialSeen', 'true');
    hasSeenTutorial = true;
}

function nextTutorialStep() {
    if (tutorialStep < tutorialSteps.length - 1) {
        tutorialStep++;
        renderTutorialStep();
    } else {
        closeTutorial();
    }
}

function prevTutorialStep() {
    if (tutorialStep > 0) {
        tutorialStep--;
        renderTutorialStep();
    }
}

function renderTutorialStep() {
    const step = tutorialSteps[tutorialStep];

    // Scroll to top of tutorial body
    const bodyEl = document.getElementById('tutorialBody');
    bodyEl.scrollTop = 0;

    // Update step indicators
    const stepsEl = document.getElementById('tutorialSteps');
    stepsEl.innerHTML = tutorialSteps.map((_, i) => `
        <span class="tutorial-step-dot ${i === tutorialStep ? 'active' : ''} ${i < tutorialStep ? 'completed' : ''}"></span>
    `).join('');

    bodyEl.innerHTML = `
        <div class="tutorial-title">
            ${step.icon ? `<span class="icon" style="background: ${step.icon}"></span>` : ''}
            ${step.title}
        </div>
        <div class="tutorial-description">${step.description}</div>
        ${step.tip ? `
            <div class="tutorial-tip">
                <span class="tutorial-tip-label">ðŸ’¡ Tip:</span>
                ${step.tip}
            </div>
        ` : ''}
        ${step.examples ? `
            <div class="tutorial-examples">
                <div class="tutorial-examples-title">Examples in Different Games</div>
                ${step.examples.map(ex => `
                    <div class="tutorial-example">
                        <span class="tutorial-example-icon">${ex.icon}</span>
                        <div>
                            <span class="tutorial-example-game">${ex.game}:</span>
                            <span class="tutorial-example-desc">${ex.desc}</span>
                        </div>
                    </div>
                `).join('')}
            </div>
        ` : ''}
    `;

    // Update nav buttons
    document.getElementById('tutorialPrev').style.display = tutorialStep === 0 ? 'none' : 'block';
    document.getElementById('tutorialNext').textContent = tutorialStep === tutorialSteps.length - 1 ? 'Get Started!' : 'Next';
}

/**
 * Check if this is a first-time user and optionally show tutorial
 * @param {Function} additionalCheck - Optional callback that returns true if tutorial should show
 */
function checkFirstTimeUser(additionalCheck) {
    if (!hasSeenTutorial) {
        // Allow additional conditions (e.g., config has no nodes)
        if (additionalCheck && !additionalCheck()) {
            return;
        }
        // Show tutorial after a short delay
        setTimeout(() => {
            // Re-check the additional condition
            if (additionalCheck && !additionalCheck()) {
                return;
            }
            showTutorial();
        }, 500);
    }
}

// ========================================
// EXPORTS
// ========================================

if (typeof window !== 'undefined') {
    window.tutorialSteps = tutorialSteps;
    window.initTutorial = initTutorial;
    window.showTutorial = showTutorial;
    window.closeTutorial = closeTutorial;
    window.nextTutorialStep = nextTutorialStep;
    window.prevTutorialStep = prevTutorialStep;
    window.renderTutorialStep = renderTutorialStep;
    window.checkFirstTimeUser = checkFirstTimeUser;
    window.hasSeenTutorial = () => hasSeenTutorial;
}

// ========================================
// REGISTER WITH TUTORIAL SYSTEM
// ========================================

// Register as 'concepts' module when TutorialSystem is available
// This allows the concepts tutorial to be accessed via TutorialSystem.start('concepts')
(function registerConceptsTutorial() {
    // Wait for TutorialSystem to be available
    function tryRegister() {
        if (typeof TutorialSystem !== 'undefined') {
            TutorialSystem.register({
                id: 'concepts',
                name: 'Core Concepts Tutorial',
                displayStyle: 'overlay',
                steps: tutorialSteps.map((step, index) => ({
                    ...step,
                    id: step.id || `step_${index}`
                })),
                onComplete: () => {
                    // Mark as seen in the legacy system too
                    localStorage.setItem('spawnEditorTutorialSeen', 'true');
                    hasSeenTutorial = true;
                    if (typeof showToast === 'function') {
                        showToast('Core concepts tutorial completed!', 'success');
                    }
                }
            });
        }
    }

    // Try immediately (if TutorialSystem loaded first)
    tryRegister();

    // Also try after DOM is ready (if we loaded first)
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', tryRegister);
    }
})();

</script>
    <script>
// ============================================================================
// WIZARD
// ============================================================================

/**
 * Spawn Editor - Config Wizard
 * Step-by-step guide for building a functional config from scratch
 * Unlike the tutorial (which explains concepts), this wizard walks users
 * through actually CREATING nodes and relationships.
 */

// ========================================
// WIZARD STATE
// ========================================

let wizardActive = false;
let wizardStep = 0;
let wizardConfig = {
    configName: null,
    attributeId: null,
    variableId: null,
    variableApId: null,         // Action Points variable
    layerId: null,
    layer2Id: null,
    traitIds: [],
    trait2Ids: [],
    tickSystemId: null,
    modifierId: null,
    modifierStunnedId: null,    // Stunned modifier
    modifierEnragedId: null,    // Enraged modifier
    relationshipIds: [],
    traitCreationCount: 0,
    trait2CreationCount: 0,
    startedFresh: false
};

// ========================================
// WIZARD STEPS
// ========================================

const wizardSteps = [
    {
        id: 'intro',
        title: 'Build Your Entity System',
        description: `
            <p>This wizard will walk you through creating a <strong>complete entity system from scratch</strong>. By the end, you'll have:</p>
            <ul style="margin: 0.75rem 0; padding-left: 1.5rem; color: var(--text-secondary);">
                <li><strong><span class="wizard-term" data-term="attributes">Attributes</span></strong> - base stats set at spawn (like Max HP)</li>
                <li><strong><span class="wizard-term" data-term="variables">Variables</span></strong> - values that change during gameplay (like Current HP)</li>
                <li><strong><span class="wizard-term" data-term="layers">Layers</span> & <span class="wizard-term" data-term="traits">Traits</span></strong> - categories with selectable options (like Class: Warrior/Mage)</li>
                <li><strong><span class="wizard-term" data-term="relationships">Relationships</span></strong> - connections that make the system dynamic</li>
                <li><strong><span class="wizard-term" data-term="tick system">Tick System</span></strong> - how time/turns work in your game</li>
                <li><strong><span class="wizard-term" data-term="modifiers">Modifiers</span></strong> - temporary effects with durations (buffs/debuffs)</li>
            </ul>
            <p style="margin-top: 0.75rem;">We'll use RPG examples, but you can <strong>rename everything</strong> for your specific game!</p>
        `,
        action: null,
        validate: null
    },
    {
        id: 'config_name',
        title: 'Step 1: Name Your System',
        description: `
            <p>First, let's give your entity system a name. This helps you identify it later when you have multiple configs.</p>
            <p style="margin-top: 0.5rem; color: var(--text-secondary); font-size: 0.85rem;">Examples: "RPG Monsters", "Tavern NPCs", "Card Collection", "Dating Sim Characters"</p>
            <p style="margin-top: 0.5rem; color: var(--text-muted); font-size: 0.8rem;">Leave blank to use default: <em>"My RPG System"</em></p>
        `,
        tip: 'Pick something descriptive! You can always change it later in the sidebar.',
        action: {
            type: 'nameConfig'
        },
        validate: () => {
            return config.name && config.name !== 'New Config' && config.name.trim().length > 0;
        },
        skipText: 'Use default'
    },
    {
        id: 'attribute',
        title: 'Step 2: Create an Attribute',
        description: `
            <p><strong><span class="wizard-term" data-term="attributes">Attributes</span></strong> are base stats assigned when an entity spawns. Think of them as the <strong>permanent foundation</strong> - like a character's Max HP, base Strength, or Intelligence score.</p>
            <p style="margin-top: 0.5rem;">Let's create <strong>"Strength"</strong> ranging from 1-10:</p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                <li>Set once at spawn (randomly within range)</li>
                <li>Can be modified by game events (leveling up) but typically stable</li>
                <li>Other systems can reference this value</li>
            </ul>
        `,
        tip: 'Think "Max HP" not "Current HP". Attributes define capacity and constraints, <span class="wizard-term" data-term="variables">variables</span> track current state.',
        action: {
            type: 'createNode',
            nodeType: 'attribute',
            suggestedId: 'attr_strength',
            suggestedName: 'Strength',
            config: { min: 1, max: 10 }
        },
        validate: () => {
            const attrs = config.nodes.filter(n => n.type === 'attribute');
            if (attrs.length > 0) {
                wizardConfig.attributeId = attrs[0].id;
                return true;
            }
            return false;
        },
        skipText: 'I already have attributes',
        successMessage: (config) => {
            const attr = config.nodes.find(n => n.type === 'attribute');
            if (!attr) return null;
            const min = attr.config?.min ?? attr.config?.defaultRange?.[0] ?? 1;
            const max = attr.config?.max ?? attr.config?.defaultRange?.[1] ?? 10;
            const rangeText = min === max ? `exactly ${min}` : `${min}-${max}`;
            return `
                <p style="color: var(--accent-success); font-weight: 600;">âœ“ Created: ${attr.name}</p>
                <p style="margin-top: 0.5rem; font-size: 0.9rem;">Attributes are foundational and numeric. Any entity you spawn will now have <strong>${attr.name}</strong> with a value of <strong>${rangeText}</strong>.</p>
                <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">Next: Let's add a variable that can change during gameplay.</p>
            `;
        }
    },
    {
        id: 'variable',
        title: 'Step 3: Create a Variable',
        description: `
            <p><strong><span class="wizard-term" data-term="variables">Variables</span></strong> track values that <strong>change during gameplay</strong>. They can count <strong>down</strong> (like Stamina depleting) or <strong>up</strong> (like a cooldown timer recovering).</p>
            <p style="margin-top: 0.5rem;">Let's create <strong>"Rage"</strong> - a resource that builds up over time:</p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                <li><strong>Min/Max</strong>: 0-100 (the allowed range)</li>
                <li><strong>Default</strong>: 0 (starts empty)</li>
                <li><strong>Rate</strong>: 10 per tick (~10 turns to fill)</li>
            </ul>
            <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                <em>More examples:</em> Stamina (depletes with actions), Cooldown Timer (counts up until ready), Combo Counter (+1 per hit, triggers at 5)
            </p>
        `,
        tip: 'Variables power gameplay loops! Some deplete (Stamina, HP), some build up (Rage, Cooldowns), some stay event-driven (Trust, Reputation).',
        action: {
            type: 'createNode',
            nodeType: 'variable',
            suggestedId: 'var_rage',
            suggestedName: 'Rage',
            config: { min: 0, max: 100, default: 0, rate: 10, changeMode: 'timed' }
        },
        validate: () => {
            const vars = config.nodes.filter(n => n.type === 'variable');
            if (vars.length > 0) {
                wizardConfig.variableId = vars[0].id;
                return true;
            }
            return false;
        },
        skipText: 'I have variables',
        successMessage: (config) => {
            const attr = config.nodes.find(n => n.type === 'attribute');
            const variable = config.nodes.find(n => n.type === 'variable');
            if (!variable) return null;
            const attrName = attr?.name || 'your attribute';
            const rate = variable.config?.baseRate ?? variable.config?.rate ?? 0;
            const direction = rate > 0 ? 'builds up' : rate < 0 ? 'depletes' : 'changes via events';
            return `
                <p style="color: var(--accent-success); font-weight: 600;">âœ“ Created: ${variable.name}</p>
                <p style="margin-top: 0.5rem; font-size: 0.9rem;">Your system now has:</p>
                <ul style="margin: 0.25rem 0; padding-left: 1.5rem; font-size: 0.9rem;">
                    <li><strong>${attrName}</strong> (attribute): Set once at spawn</li>
                    <li><strong>${variable.name}</strong> (variable): ${direction} over time</li>
                </ul>
                <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">Next: Let's connect them with a relationship!</p>
                <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted);"><em>ðŸ’¡ Advanced: Later you can add class-specific rate modifiers (e.g., Warriors build ${variable.name} faster via a rate_modifier relationship).</em></p>
            `;
        }
    },
    {
        id: 'relationship1',
        title: 'Step 4: Connect Attribute to Variable',
        description: `
            <p>Now the magic begins! Let's make <strong>Strength increase starting Rage</strong>. Stronger entities start angrier and closer to going berserk!</p>
            <p style="margin-top: 0.5rem;">Create a <strong>Value Modifier</strong> relationship:</p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem;">
                <li>Source: <strong>Strength</strong> (your attribute)</li>
                <li>Target: <strong>Rage</strong> (your variable)</li>
                <li>Type: <strong>Value Modifier</strong></li>
                <li>Operation: <strong>Add</strong>, Value: <strong>3</strong></li>
            </ul>
            <p style="color: var(--text-secondary); font-size: 0.8rem;">This adds 3 to starting rage per point of strength. Strength 8 = starts with 24 rage!</p>
        `,
        tip: '<span class="wizard-term" data-term="relationships">Relationships</span> are the heart of the system - they create emergent behavior from simple rules.',
        action: {
            type: 'createRelationship',
            sourceId: () => wizardConfig.attributeId,
            targetId: () => wizardConfig.variableId,
            relType: 'value_modifier',
            operation: 'add',
            value: 3
        },
        validate: () => {
            const rels = config.relationships.filter(r => r.type === 'value_modifier');
            return rels.length > 0;
        },
        skipText: 'Skip relationship'
    },
    {
        id: 'layer',
        title: 'Step 5: Create a Layer (Folder)',
        description: `
            <p><strong><span class="wizard-term" data-term="layers">Layers</span></strong> are like <strong>folders</strong> that organize related <span class="wizard-term" data-term="traits">traits</span>. Each layer holds a set of options, and entities pick from each layer when spawned.</p>
            <p style="margin-top: 0.5rem;">Let's create a <strong>"Class"</strong> layer for character classes:</p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                <li>Entities will pick <strong>ONE</strong> class from this layer</li>
                <li>Selection can be weighted (some classes more common)</li>
                <li>Different layers = different categories (Class, Species, Mood, etc.)</li>
            </ul>
            <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted);"><em>Example: For Class, each entity gets exactly one. But other layers might allow multiple selections (e.g., "pick 2-3 resistances").</em></p>
        `,
        tip: 'You can have many <span class="wizard-term" data-term="layers">layers</span>! Species layer (Human/Elf/Orc), Mood layer (Happy/Sad/Angry), Behavior layer (Aggressive/Passive), etc.',
        action: {
            type: 'createNode',
            nodeType: 'layer',
            suggestedId: 'layer_class',
            suggestedName: 'Class'
        },
        validate: () => {
            // If we already assigned a layer for this wizard session, we're done
            if (wizardConfig.layerId && config.nodes.some(n => n.id === wizardConfig.layerId)) {
                return true;
            }
            // Otherwise check for any layers and assign the first one
            const layers = config.nodes.filter(n => n.type === 'layer');
            if (layers.length > 0) {
                wizardConfig.layerId = layers[0].id;
                return true;
            }
            return false;
        },
        skipText: 'I already have layers',
        successMessage: (config) => {
            const layer = config.nodes.find(n => n.type === 'layer');
            if (!layer) return null;
            return `
                <p style="color: var(--accent-success); font-weight: 600;">âœ“ Created: ${layer.name} (layer)</p>
                <p style="margin-top: 0.5rem; font-size: 0.9rem;">Your <strong>${layer.name}</strong> layer is like an empty folder waiting for options. Each entity will pick from this layer when spawned.</p>
                <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">Next: Add traits (the options inside this folder)!</p>
            `;
        }
    },
    {
        id: 'traits',
        title: 'Step 6: Add Traits to Layer',
        description: `
            <p>Now add <strong>traits</strong> to your Class layer. Traits are the selectable options entities can spawn with.</p>
            <p style="margin-top: 0.5rem;">Add two traits: <strong>"Warrior"</strong> and <strong>"Mage"</strong></p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                <li>Each trait has a <strong>base weight</strong> (selection probability)</li>
                <li>Equal weights = equal chance. Unequal weights create rarity.</li>
                <li>Weights can be influenced by attributes (coming next!)</li>
            </ul>
            <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted);"><em>Tip: Use "Equalize Weights" later to set all traits to the same probability, or set different values (e.g., Warrior: 50, Mage: 30, Legendary Hero: 5).</em></p>
        `,
        tip: 'Contrasting traits create variety: Melee/Ranged, Aggressive/Defensive, Fast/Slow.',
        action: {
            type: 'createNode',
            nodeType: 'trait',
            suggestedId: 'trait_warrior',
            suggestedName: 'Warrior',
            requireMultiple: true,
            multipleCount: 2,
            getSuggestedName: (index) => index === 0 ? 'Warrior' : 'Mage',
            getSuggestedId: (index) => index === 0 ? 'trait_warrior' : 'trait_mage'
        },
        validate: () => {
            const layer = config.nodes.find(n => n.id === wizardConfig.layerId);
            const traitIds = layer?.config?.traitIds || layer?.config?.itemIds || [];
            if (traitIds.length >= 2) {
                wizardConfig.traitIds = traitIds.slice(0, 2);
                return true;
            }
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
            if (traits.length >= 2) {
                wizardConfig.traitIds = traits.slice(0, 2).map(t => t.id);
                return true;
            }
            return false;
        },
        skipText: 'I have traits already'
    },
    {
        id: 'relationship2',
        title: 'Step 7: Add Another Relationship',
        description: `
            <p>Let's add <strong>another</strong> relationship - this time making <strong>strong entities more likely to be Warriors</strong>! This is called a <strong>Weight Influence</strong>.</p>
            <p style="margin-top: 0.5rem;">Create this relationship:</p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem;">
                <li>Source: <strong>Strength</strong></li>
                <li>Target: <strong>Warrior</strong></li>
                <li>Type: <strong>Weight Influence</strong></li>
                <li>Operation: <strong>Add</strong>, Value: <strong>10</strong></li>
            </ul>
            <p style="color: var(--text-secondary); font-size: 0.8rem;">Now high-strength entities gravitate toward Warrior class!</p>
        `,
        tip: 'Relationships can connect any node types! This one links an attribute to a trait, while the earlier one linked an attribute to a variable.',
        action: {
            type: 'createRelationship',
            sourceId: () => wizardConfig.attributeId,
            targetId: () => wizardConfig.traitIds[0],
            relType: 'weight_influence',
            operation: 'add',
            value: 10
        },
        validate: () => {
            const rels = config.relationships.filter(r => r.type === 'weight_influence');
            return rels.length > 0;
        },
        skipText: 'Skip relationship'
    },
    {
        id: 'relationship_reverse',
        title: 'Step 8: Reverse the Flow',
        description: `
            <p>You just made <strong>Strength influence which class is chosen</strong>. But what if instead of "strong entities are more likely to be Warriors", we want "<strong>Warriors ARE stronger</strong>"?</p>
            <p style="margin-top: 0.5rem;">Let's add a second relationship - this time from Warrior TO Strength:</p>
            <div style="margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-card); border-radius: 6px; border-left: 3px solid var(--node-trait);">
                <strong>Spawn Order:</strong> Class is selected <em>after</em> Strength is rolled, so Warrior can modify the already-rolled Strength value.
            </div>
            <p style="margin-top: 0.5rem;">Create this relationship:</p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem;">
                <li>Source: <strong>Warrior</strong> (the trait)</li>
                <li>Target: <strong>Strength</strong> (the attribute)</li>
                <li>Type: <strong>Value Modifier</strong></li>
                <li>Operation: <strong>Add</strong>, Value: <strong>2</strong></li>
            </ul>
            <p style="color: var(--text-secondary); font-size: 0.8rem;">Now Warriors get +2 Strength! Combined with Step 7, you have bidirectional causality.</p>
        `,
        tip: 'This bidirectional pattern is powerful: attributes influence class selection, then class modifies attributes. Design your causality to fit your game!',
        action: {
            type: 'createRelationship',
            sourceId: () => wizardConfig.traitIds[0],
            targetId: () => wizardConfig.attributeId,
            relType: 'value_modifier',
            operation: 'add',
            value: 2
        },
        validate: () => {
            // Check for a value_modifier from a trait to an attribute
            const rels = config.relationships.filter(r => {
                if (r.type !== 'value_modifier') return false;
                const source = config.nodes.find(n => n.id === r.sourceId);
                const target = config.nodes.find(n => n.id === r.targetId);
                return source && target &&
                    (source.type === 'trait' || source.type === 'item') &&
                    target.type === 'attribute';
            });
            return rels.length > 0;
        },
        skipText: 'Skip this step',
        successMessage: () => {
            const warrior = config.nodes.find(n => n.id === wizardConfig.traitIds[0]);
            const attr = config.nodes.find(n => n.id === wizardConfig.attributeId);
            const warriorName = warrior?.name || 'Warrior';
            const attrName = attr?.name || 'Strength';
            return `
                <p style="color: var(--accent-success); font-weight: 600;">âœ“ Bidirectional relationship created!</p>
                <p style="margin-top: 0.5rem; font-size: 0.9rem;">
                    Now you have <strong>two-way causality</strong>:
                </p>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem;">
                    <li>${attrName} â†’ ${warriorName} (weight influence)</li>
                    <li>${warriorName} â†’ ${attrName} (+2 value modifier)</li>
                </ul>
                <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">High-strength entities tend to become Warriors, and Warriors become even stronger!</p>
            `;
        }
    },
    {
        id: 'ticksystem',
        title: 'Step 9: Set Up Time (Tick System)',
        description: `
            <p>Before we create modifiers, let's set up how <strong>time works</strong> in your system.</p>
            <p style="margin-top: 0.75rem;"><strong>Tick Systems</strong> control:</p>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                <li>How long modifiers last (e.g., "Stunned for 2 turns")</li>
                <li>When variables change (e.g., "Cooldown resets each turn")</li>
                <li>When threshold checks happen</li>
            </ul>
            <div style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85rem;">
                <div style="background: var(--bg-card); padding: 0.5rem 0.75rem; border-radius: 4px; border-left: 2px solid var(--node-ticksystem);">
                    <strong>Turn-based:</strong> You call tick() when a turn ends
                </div>
                <div style="background: var(--bg-card); padding: 0.5rem 0.75rem; border-radius: 4px; border-left: 2px solid var(--node-ticksystem);">
                    <strong>Real-time:</strong> Engine auto-ticks every N ms
                </div>
            </div>
            <p style="margin-top: 0.75rem;">Let's create a <strong>"Combat Turns"</strong> tick system:</p>
        `,
        tip: 'Most RPGs use turn-based ticks. Real-time games (like tavern sims) use automatic intervals. You can have multiple tick systems!',
        action: {
            type: 'createNode',
            nodeType: 'ticksystem',
            suggestedId: 'tick_combat',
            suggestedName: 'Combat Turns',
            config: {
                unit: 'turns',
                interval: null  // Manual - game calls tick()
            }
        },
        validate: () => {
            const ticks = config.nodes.filter(n => n.type === 'ticksystem');
            if (ticks.length > 0) {
                wizardConfig.tickSystemId = ticks[0].id;
                return true;
            }
            return false;
        },
        skipText: 'Skip tick system',
        successMessage: (config) => {
            const tick = config.nodes.find(n => n.type === 'ticksystem');
            if (!tick) return null;
            const tickType = tick.config?.tickUnit?.type === 'timed' ? 'auto-advances' : 'turn-based';
            return `
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <span style="font-size: 1.5rem;">&#9201;</span>
                    <div>
                        <strong>${tick.name || tick.id}</strong> is ready! (${tickType})<br>
                        <span style="font-size: 0.85rem; color: var(--text-secondary);">
                            Next: Add Action Points to track what entities can do each turn.
                        </span>
                    </div>
                </div>
                <div style="margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-card); border-radius: 4px; font-size: 0.8rem; color: var(--text-muted);">
                    ðŸ’¡ <strong>Tip:</strong> Use the <strong>Ticks</strong> tab later to configure advanced trigger conditions and view all tick-bound modifiers.
                </div>
            `;
        }
    },
    {
        id: 'action_points',
        title: 'Step 10: Add Action Points',
        description: `
            <p>The tick system tracks turn progression. Now let's add <strong>Action Points (AP)</strong> - the resource entities spend to perform actions each turn.</p>
            <div style="margin: 0.5rem 0; padding: 0.5rem 0.75rem; background: var(--bg-card); border-radius: 6px; font-size: 0.8rem; color: var(--text-secondary);">
                <strong>Flow:</strong> Tick System (turn order) â†’ Action Points (what you can do) â†’ Modifiers (alter AP)
            </div>
            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                <li><strong>Min/Max</strong>: 0-5 (can't go negative or exceed 5)</li>
                <li><strong>Default</strong>: 3 (start with 3 AP per turn)</li>
                <li><strong>Change Mode</strong>: Manual (your game resets it each turn)</li>
            </ul>
        `,
        tip: 'AP is flexible: rogues could get more AP, heavy attacks could cost more, stunned entities get 0 AP. Modifiers can add or subtract!',
        action: {
            type: 'createNode',
            nodeType: 'variable',
            suggestedId: 'var_action_points',
            suggestedName: 'Action Points',
            config: { min: 0, max: 5, default: 3, rate: 0, changeMode: 'manual' }
        },
        validate: () => {
            // Look for an action points variable (or any second variable)
            const vars = config.nodes.filter(n => n.type === 'variable');
            if (vars.length >= 2) {
                // Find the AP variable specifically, or use the second one
                const apVar = vars.find(v => v.id.includes('action') || v.name.toLowerCase().includes('action'));
                wizardConfig.variableApId = apVar?.id || vars[1].id;
                return true;
            }
            return false;
        },
        skipText: 'Skip AP',
        successMessage: () => {
            const apVar = config.nodes.find(n => n.id === wizardConfig.variableApId);
            if (!apVar) return null;
            const defaultVal = apVar.config?.default ?? apVar.config?.defaultValue ?? 3;
            const max = apVar.config?.max ?? 5;
            return `
                <p style="color: var(--accent-success); font-weight: 600;">âœ“ Created: ${apVar.name}</p>
                <p style="margin-top: 0.5rem; font-size: 0.9rem;">
                    Entities now have <strong>${defaultVal} ${apVar.name}</strong> (max ${max}) to spend each turn.
                </p>
                <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    Next: Create modifiers that actually DO something by affecting AP!
                </p>
            `;
        }
    },
    {
        id: 'modifier_stunned',
        title: 'Step 11: Create Stunned Modifier',
        description: () => {
            const tickSystem = config.nodes.find(n => n.type === 'ticksystem');
            const tickName = tickSystem?.name || 'Combat Turns';
            const tickLabel = tickSystem?.config?.tickUnit?.label || 'turns';
            const apVar = config.nodes.find(n => n.id === wizardConfig.variableApId);
            const apName = apVar?.name || 'Action Points';

            return `
                <p><strong>Stunned</strong> is a debuff that <strong>prevents all actions</strong>. Let's make it set AP to 0!</p>
                <p style="margin-top: 0.5rem;">This shows how modifiers can <strong>directly impact gameplay</strong> through relationships.</p>
                <div style="margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-card); border-radius: 6px; border-left: 3px solid var(--node-modifier);">
                    <strong>What we'll create:</strong><br>
                    <span style="font-size: 0.85rem;">Stunned modifier + relationship to ${apName} (set to 0)</span>
                </div>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    <li><strong>Duration</strong>: 1 ${tickLabel.slice(0, -1)} (bound to ${tickName})</li>
                    <li><strong>Trigger</strong>: Game-applied (your code calls applyModifier)</li>
                    <li><strong>Effect</strong>: While active, ${apName} = 0</li>
                </ul>
            `;
        },
        tip: 'Status effects like Stunned, Frozen, or Silenced should affect gameplay variables. This makes your system reactive and tactical!',
        action: {
            type: 'createNode',
            nodeType: 'modifier',
            suggestedId: 'mod_stunned',
            suggestedName: 'Stunned',
            config: {
                trigger: { type: 'manual' },
                duration: {
                    type: 'ticks',
                    value: 1,
                    tickSystemId: () => wizardConfig.tickSystemId || 'tick_combat'
                }
            }
        },
        validate: () => {
            const mods = config.nodes.filter(n => n.type === 'modifier');
            const stunnedMod = mods.find(m => m.id.includes('stun') || m.name.toLowerCase().includes('stun'));
            if (stunnedMod) {
                wizardConfig.modifierStunnedId = stunnedMod.id;
                return true;
            }
            // Accept any modifier as fallback
            if (mods.length > 0) {
                wizardConfig.modifierStunnedId = mods[0].id;
                return true;
            }
            return false;
        },
        skipText: 'Skip Stunned',
        successMessage: () => {
            const mod = config.nodes.find(n => n.id === wizardConfig.modifierStunnedId);
            if (!mod) return null;
            const tickSystem = config.nodes.find(n => n.type === 'ticksystem');
            const tickLabel = tickSystem?.config?.tickUnit?.label || 'turns';
            return `
                <p style="color: var(--accent-success); font-weight: 600;">âœ“ Created: ${mod.name}</p>
                <p style="margin-top: 0.5rem; font-size: 0.9rem;">
                    <strong>Important:</strong> Add a relationship from ${mod.name} â†’ Action Points (value_modifier, set to 0) to make it actually work!
                </p>
                <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    Use the sidebar to select ${mod.name}, then click "Add Relationship" to connect it to Action Points.
                </p>
            `;
        }
    },
    {
        id: 'modifier_enraged',
        title: 'Step 12: Create Enraged Buff',
        description: () => {
            const apVar = config.nodes.find(n => n.id === wizardConfig.variableApId);
            const apName = apVar?.name || 'Action Points';
            const rageVar = config.nodes.find(n => n.id === wizardConfig.variableId);
            const rageName = rageVar?.name || 'Rage';

            return `
                <p><strong>Enraged</strong> triggers <strong>automatically when ${rageName} exceeds 80</strong>. It grants <strong>+2 bonus AP</strong>!</p>
                <p style="margin-top: 0.5rem;">This shows <strong>threshold-triggered</strong> modifiers that buff the entity.</p>
                <div style="margin: 0.75rem 0; padding: 0.75rem; background: var(--bg-card); border-radius: 6px; border-left: 3px solid var(--accent-success);">
                    <strong>What we'll create:</strong><br>
                    <span style="font-size: 0.85rem;">Enraged modifier (threshold: ${rageName} > 80) + relationship to ${apName} (+2)</span>
                </div>
                <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    <li><strong>Trigger</strong>: ${rageName} > 80</li>
                    <li><strong>Auto-remove</strong>: When ${rageName} â‰¤ 80</li>
                    <li><strong>Effect</strong>: While active, ${apName} +2</li>
                </ul>
            `;
        },
        tip: 'Threshold triggers create emergent gameplay! Rage builds from combat, then Enraged kicks in giving extra actions for a berserker feel.',
        action: {
            type: 'createNode',
            nodeType: 'modifier',
            suggestedId: 'mod_enraged',
            suggestedName: 'Enraged',
            config: {
                trigger: {
                    type: 'threshold',
                    variableId: () => wizardConfig.variableId || 'var_rage',
                    condition: 'above',
                    value: 80
                },
                autoRemove: true
            }
        },
        validate: () => {
            const mods = config.nodes.filter(n => n.type === 'modifier');
            const enragedMod = mods.find(m => m.id.includes('enrage') || m.name.toLowerCase().includes('enrage'));
            if (enragedMod) {
                wizardConfig.modifierEnragedId = enragedMod.id;
                return true;
            }
            // Need at least 2 modifiers (Stunned + Enraged)
            if (mods.length >= 2) {
                wizardConfig.modifierEnragedId = mods[1].id;
                return true;
            }
            return false;
        },
        skipText: 'Skip Enraged',
        successMessage: () => {
            const mod = config.nodes.find(n => n.id === wizardConfig.modifierEnragedId);
            if (!mod) return null;
            const apVar = config.nodes.find(n => n.id === wizardConfig.variableApId);
            const apName = apVar?.name || 'Action Points';
            return `
                <p style="color: var(--accent-success); font-weight: 600;">âœ“ Created: ${mod.name}</p>
                <p style="margin-top: 0.5rem; font-size: 0.9rem;">
                    <strong>Important:</strong> Add a relationship from ${mod.name} â†’ ${apName} (value_modifier, add 2) to complete the buff!
                </p>
                <p style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    Use the sidebar to select ${mod.name}, then click "Add Relationship".
                </p>
            `;
        }
    },
    {
        id: 'complete',
        title: 'Your Combat System is Ready!',
        description: () => {
            const attr = config.nodes.find(n => n.id === wizardConfig.attributeId);
            const rageVar = config.nodes.find(n => n.id === wizardConfig.variableId);
            const apVar = config.nodes.find(n => n.id === wizardConfig.variableApId);
            const traits = wizardConfig.traitIds.map(id => config.nodes.find(n => n.id === id)).filter(Boolean);
            const stunnedMod = config.nodes.find(n => n.id === wizardConfig.modifierStunnedId);
            const enragedMod = config.nodes.find(n => n.id === wizardConfig.modifierEnragedId);

            const attrName = attr?.name || 'Strength';
            const rageName = rageVar?.name || 'Rage';
            const apName = apVar?.name || 'Action Points';
            const traitNames = traits.map(t => t?.name || 'trait').join('/');
            const stunnedName = stunnedMod?.name || 'Stunned';
            const enragedName = enragedMod?.name || 'Enraged';

            return `
                <p style="color: var(--accent-success); font-weight: 600; font-size: 1.1rem;">Congratulations!</p>
                <p>You've built a <strong>complete turn-based combat foundation</strong>!</p>

                <div style="margin: 1rem 0; padding: 0.75rem; background: var(--bg-card); border-radius: 6px;">
                    <strong>What you created:</strong>
                    <ul style="margin: 0.5rem 0 0 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                        <li><strong>${attrName}</strong> attribute (1-10)</li>
                        <li><strong>${rageName}</strong> variable (builds over time)</li>
                        <li><strong>${apName}</strong> (3 per turn)</li>
                        <li><strong>Class</strong> layer with ${traitNames}</li>
                        <li><strong>Bidirectional relationships</strong> (${attrName} â†” ${traits[0]?.name || 'Warrior'})</li>
                        <li><strong>${stunnedName}</strong> modifier (AP = 0)</li>
                        <li><strong>${enragedName}</strong> modifier (${rageName} > 80 â†’ +2 AP)</li>
                    </ul>
                </div>

                <div style="margin: 1rem 0; padding: 0.75rem; background: rgba(74, 124, 89, 0.1); border: 1px solid var(--accent-success); border-radius: 6px;">
                    <strong style="color: var(--accent-success);">ðŸ§ª Test Your System:</strong>
                    <ol style="margin: 0.5rem 0 0 0; padding-left: 1.5rem; font-size: 0.85rem;">
                        <li>Go to <strong>Preview</strong> tab</li>
                        <li>Click <strong>Spawn Entity</strong> twice (get one ${traits[0]?.name || 'Warrior'} and one ${traits[1]?.name || 'Mage'})</li>
                        <li>Notice ${traits[0]?.name || 'Warriors'} have <strong>+2 ${attrName}</strong> from class bonus</li>
                        <li>Click an entity's <strong>${rageName}</strong> value, set to 85</li>
                        <li>Watch <strong>${enragedName}</strong> activate â†’ AP becomes 5 (3 + 2)</li>
                        <li>Click <strong>Apply Modifier</strong> â†’ select <strong>${stunnedName}</strong></li>
                        <li>Watch AP drop to 0 (${stunnedName} overrides)</li>
                    </ol>
                </div>

                <p style="margin-top: 1rem; font-weight: 600;">Don't Forget the Relationships!</p>
                <p style="font-size: 0.85rem; color: var(--text-secondary);">
                    The modifiers need relationships to actually affect ${apName}:
                </p>
                <ul style="margin: 0.25rem 0; padding-left: 1.5rem; font-size: 0.85rem; color: var(--text-secondary);">
                    <li><strong>${stunnedName}</strong> â†’ ${apName}: value_modifier, <strong>set</strong> to 0</li>
                    <li><strong>${enragedName}</strong> â†’ ${apName}: value_modifier, <strong>add</strong> 2</li>
                </ul>

                <p style="margin-top: 1rem; font-weight: 600;">Next Steps:</p>
                <ol style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.85rem;">
                    <li><strong>Add relationships</strong> to complete modifier effects</li>
                    <li><strong>Preview tab</strong> - Test spawning and modifier behavior</li>
                    <li><strong>Code tab</strong> - Copy integration snippets for your game</li>
                    <li><strong>Export</strong> - Download your config JSON</li>
                </ol>
            `;
        },
        action: null,
        validate: null,
        linkedTutorials: [
            {
                moduleId: 'entity-management',
                label: 'Learn about Entity Pools & Management',
                returnLabel: 'Return to Config Wizard'
            },
            {
                moduleId: 'presets',
                label: 'Create Spawn Presets for your entities',
                returnLabel: 'Return to Config Wizard'
            }
        ]
    }
];

// ========================================
// WIZARD FUNCTIONS
// ========================================

function startWizard() {
    // If config has content, offer choice
    if (config.nodes.length > 0) {
        showWizardStartChoice();
        return;
    }

    // Empty config - start fresh
    initWizardFresh();
}

function showWizardStartChoice() {
    // Create choice modal - wizard is a tutorial, so default to fresh start
    let modal = document.getElementById('wizardStartModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'wizardStartModal';
        modal.className = 'modal-overlay active';
        modal.innerHTML = `
            <div class="modal" style="max-width: 480px;">
                <div class="modal-header">
                    <span class="modal-title">Start Wizard</span>
                    <button class="btn btn-icon" onclick="closeWizardStartModal()">âœ•</button>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 0.75rem;">The wizard is designed to walk you through building a config <strong>from scratch</strong>.</p>
                    <p style="margin-bottom: 1rem; color: var(--text-secondary); font-size: 0.9rem;">You have an existing config with ${config.nodes.length} node(s). Starting the wizard will clear it.</p>

                    <p style="margin-bottom: 0.5rem; font-weight: 500;">Would you like to export your current config first?</p>

                    <div style="display: flex; gap: 0.75rem; margin-top: 1rem;">
                        <button class="btn btn-secondary" onclick="exportAndStartWizard()" style="flex: 1;">
                            Export & Start
                        </button>
                        <button class="btn btn-primary" onclick="initWizardFresh()" style="flex: 1;">
                            Start Fresh
                        </button>
                        <button class="btn btn-secondary" onclick="closeWizardStartModal()" style="flex: 0.7;">
                            Cancel
                        </button>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
    } else {
        // Update the node count in case it changed
        modal.querySelector('.modal-body p:nth-child(2)').innerHTML =
            `You have an existing config with <strong>${config.nodes.length}</strong> node(s). Starting the wizard will clear it.`;
        modal.classList.add('active');
    }
}

function exportAndStartWizard() {
    // Export current config first, then start wizard fresh
    if (typeof exportConfig === 'function') {
        exportConfig();
    }
    // Small delay to let the download start
    setTimeout(() => {
        initWizardFresh();
    }, 100);
}

function closeWizardStartModal() {
    const modal = document.getElementById('wizardStartModal');
    if (modal) {
        modal.classList.remove('active');
    }
}

function initWizardFresh() {
    closeWizardStartModal();

    // Clear config
    config = {
        id: 'new-config',
        name: 'New Config',
        version: '3.0',
        tier: 'free',
        nodes: [],
        relationships: [],
        presetGroups: [],
        presets: [],
        engineConfig: {
            tickRate: 1000,
            maxSpawns: null
        }
    };

    // Reload engine and UI
    if (typeof engine !== 'undefined') {
        engine.loadConfig(config);
    }
    if (typeof saveToStorage === 'function') {
        saveToStorage();
    }
    if (typeof render === 'function') {
        render();
    }

    // Reset wizard state
    wizardConfig = {
        configName: null,
        attributeId: null,
        variableId: null,
        variableApId: null,
        layerId: null,
        layer2Id: null,
        traitIds: [],
        trait2Ids: [],
        tickSystemId: null,
        modifierId: null,
        modifierStunnedId: null,
        modifierEnragedId: null,
        relationshipIds: [],
        traitCreationCount: 0,
        trait2CreationCount: 0,
        startedFresh: true
    };

    wizardActive = true;
    wizardStep = 0;

    showWizardOverlay();
    renderWizardStep();
}

function initWizardContinue() {
    closeWizardStartModal();

    // Keep existing config, just reset wizard tracking
    wizardConfig = {
        configName: config.name,
        attributeId: null,
        variableId: null,
        variableApId: null,
        layerId: null,
        layer2Id: null,
        traitIds: [],
        trait2Ids: [],
        tickSystemId: null,
        modifierId: null,
        modifierStunnedId: null,
        modifierEnragedId: null,
        relationshipIds: [],
        traitCreationCount: 0,
        trait2CreationCount: 0,
        startedFresh: false
    };

    // Try to detect existing nodes for wizard state
    const attrs = config.nodes.filter(n => n.type === 'attribute');
    if (attrs.length > 0) wizardConfig.attributeId = attrs[0].id;

    const vars = config.nodes.filter(n => n.type === 'variable');
    if (vars.length > 0) wizardConfig.variableId = vars[0].id;
    if (vars.length > 1) wizardConfig.variableApId = vars[1].id;

    const layers = config.nodes.filter(n => n.type === 'layer');
    if (layers.length > 0) wizardConfig.layerId = layers[0].id;

    const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
    if (traits.length >= 2) {
        wizardConfig.traitIds = traits.slice(0, 2).map(t => t.id);
        wizardConfig.traitCreationCount = traits.length;
    }

    const ticks = config.nodes.filter(n => n.type === 'ticksystem');
    if (ticks.length > 0) wizardConfig.tickSystemId = ticks[0].id;

    const mods = config.nodes.filter(n => n.type === 'modifier');
    if (mods.length > 0) wizardConfig.modifierId = mods[0].id;
    if (mods.length > 0) wizardConfig.modifierStunnedId = mods[0].id;
    if (mods.length > 1) wizardConfig.modifierEnragedId = mods[1].id;

    wizardActive = true;
    wizardStep = 0;

    showWizardOverlay();
    renderWizardStep();
}

function showWizardOverlay() {
    let overlay = document.getElementById('wizardOverlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'wizardOverlay';
        overlay.className = 'wizard-overlay';
        overlay.innerHTML = `
            <div class="wizard-panel">
                <div class="wizard-header">
                    <span class="wizard-title" id="wizardTitle">Config Wizard</span>
                    <span class="wizard-progress" id="wizardProgress">Step 1 of ${wizardSteps.length}</span>
                </div>
                <div class="wizard-body" id="wizardBody">
                    <!-- Content rendered by JS -->
                </div>
                <div class="wizard-footer">
                    <div class="wizard-nav">
                        <button class="btn btn-secondary" id="wizardSkip" onclick="skipWizardStep()">Skip</button>
                        <button class="btn btn-secondary" id="wizardPrev" onclick="prevWizardStep()">Back</button>
                        <button class="btn btn-primary" id="wizardAction" onclick="doWizardAction()">Create</button>
                        <button class="btn btn-primary" id="wizardNext" onclick="nextWizardStep()" style="display: none;">Next</button>
                    </div>
                    <button class="btn btn-icon" onclick="closeWizard()" title="Close wizard" style="margin-top: 0.25rem;">âœ• Close</button>
                </div>
            </div>
        `;
        document.body.appendChild(overlay);
    }
    overlay.classList.add('active');
    document.body.classList.add('wizard-active');

    // Create success popup if it doesn't exist
    if (!document.getElementById('wizardSuccessPopup')) {
        const popup = document.createElement('div');
        popup.id = 'wizardSuccessPopup';
        popup.className = 'wizard-success-popup';
        popup.innerHTML = `
            <div class="wizard-success-popup-header">
                <div class="wizard-success-popup-content" id="wizardSuccessPopupContent"></div>
                <button class="wizard-success-popup-close" onclick="closeWizardSuccessPopup()" title="Close">&times;</button>
            </div>
        `;
        document.body.appendChild(popup);
    }

    // Initialize term tooltips
    setTimeout(initWizardTooltips, 100);
}

function showWizardSuccessPopup(html) {
    const popup = document.getElementById('wizardSuccessPopup');
    const content = document.getElementById('wizardSuccessPopupContent');
    if (popup && content) {
        content.innerHTML = html;
        popup.classList.add('visible');
    }
}

function closeWizardSuccessPopup() {
    const popup = document.getElementById('wizardSuccessPopup');
    if (popup) {
        popup.classList.remove('visible');
    }
}

// ========================================
// WIZARD TERM TOOLTIPS
// ========================================

const wizardTermDefinitions = {
    attributes: 'Numeric values set at spawn that represent fundamental stats (Strength, Intelligence). Typically stable but can change via game events like leveling up.',
    attribute: 'A numeric value set at spawn representing a fundamental stat. Stable but can change via game events.',
    variables: 'Values that change during gameplay. Can deplete (HP, Stamina), accumulate (Rage), or change via events (Mana on spell use).',
    variable: 'A value that changes during gameplay. Can deplete, accumulate over time, or change via events.',
    layers: 'Categories that organize related traits. Each layer is like a folder - entities pick from each layer when spawned.',
    layer: 'A category that organizes related traits. Like a folder containing options for entities to choose from.',
    traits: 'Selectable options within a layer. Each has a weight for selection probability. Examples: Warrior, Mage, Aggressive, Defensive.',
    trait: 'A selectable option within a layer. Has a base weight determining selection probability.',
    modifiers: 'Temporary effects applied by game code. Examples: Stunned, Poisoned, Buffed. Can have durations and affect other values.',
    modifier: 'A temporary effect applied by your game code. Has optional duration and can affect other values via relationships.',
    compounds: 'Emergent states that activate when multiple conditions are met. Example: "Hangry" activates when both Hungry AND Grumpy are active.',
    compound: 'An emergent state that activates when multiple other traits/modifiers are active simultaneously.',
    relationships: 'Connections between nodes that create dynamic behavior. Examples: Strength affects Warrior probability, Stunned sets AP to 0.',
    relationship: 'A connection between two nodes that creates dynamic behavior - one affects the other.',
    'tick system': 'Controls how time works in your system. Turn-based (you call tick) or real-time (auto-ticks at interval).',
    ticksystem: 'Controls time progression. Modifiers use it for durations, variables for rate changes.',
    'weight influence': 'A relationship type that changes trait selection probability. Higher influence = more likely to be selected.',
    'value modifier': 'A relationship type that directly changes a numeric value (add, multiply, or set).',
    'rate modifier': 'A relationship type that changes how fast a variable ticks (faster/slower depletion or accumulation).',
    threshold: 'A trigger condition based on a variable\'s value. Example: "Activate when HP drops below 25%".'
};

function createWizardTooltip() {
    if (document.getElementById('wizardTooltip')) return;

    const tooltip = document.createElement('div');
    tooltip.id = 'wizardTooltip';
    tooltip.className = 'wizard-tooltip';
    tooltip.innerHTML = '<div class="wizard-tooltip-title"></div><div class="wizard-tooltip-text"></div>';
    document.body.appendChild(tooltip);
}

function showWizardTermTooltip(e) {
    const term = e.target.dataset.term;
    const definition = wizardTermDefinitions[term] || wizardTermDefinitions[term.toLowerCase()];
    if (!definition) return;

    createWizardTooltip();
    const tooltip = document.getElementById('wizardTooltip');
    const titleEl = tooltip.querySelector('.wizard-tooltip-title');
    const textEl = tooltip.querySelector('.wizard-tooltip-text');

    titleEl.textContent = term;
    textEl.textContent = definition;

    // Position tooltip near the element
    const rect = e.target.getBoundingClientRect();
    const tooltipRect = tooltip.getBoundingClientRect();

    let left = rect.left + (rect.width / 2) - 140; // Center-ish
    let top = rect.top - 10; // Above the element

    // Keep within viewport
    if (left < 10) left = 10;
    if (left + 280 > window.innerWidth) left = window.innerWidth - 290;

    tooltip.style.left = left + 'px';
    tooltip.style.top = (top - tooltip.offsetHeight) + 'px';
    tooltip.classList.add('visible');
}

function hideWizardTermTooltip() {
    const tooltip = document.getElementById('wizardTooltip');
    if (tooltip) {
        tooltip.classList.remove('visible');
    }
}

function initWizardTooltips() {
    // Delegate event handling to the wizard body
    const wizardBody = document.getElementById('wizardBody');
    if (!wizardBody) return;

    wizardBody.addEventListener('mouseenter', (e) => {
        if (e.target.classList.contains('wizard-term')) {
            showWizardTermTooltip(e);
        }
    }, true);

    wizardBody.addEventListener('mouseleave', (e) => {
        if (e.target.classList.contains('wizard-term')) {
            hideWizardTermTooltip();
        }
    }, true);
}

function closeWizard() {
    wizardActive = false;
    closeWizardSuccessPopup();
    const overlay = document.getElementById('wizardOverlay');
    if (overlay) {
        overlay.classList.remove('active');
    }
    document.body.classList.remove('wizard-active');
}

function renderWizardStep() {
    const step = wizardSteps[wizardStep];
    const isComplete = step.validate ? step.validate() : false;

    // Update progress
    document.getElementById('wizardTitle').textContent = step.title;
    document.getElementById('wizardProgress').textContent = `Step ${wizardStep + 1} of ${wizardSteps.length}`;

    // Render body
    const bodyEl = document.getElementById('wizardBody');

    // Get description - support both string and function
    const description = typeof step.description === 'function' ? step.description() : step.description;

    // Special handling for config name step
    if (step.id === 'config_name') {
        bodyEl.innerHTML = `
            <div class="wizard-description">${description}</div>
            <div style="margin: 1rem 0;">
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 500;">System Name:</label>
                <input type="text" id="wizardConfigName"
                    value="${config.name !== 'New Config' ? config.name : ''}"
                    placeholder="My RPG System"
                    style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-secondary); color: var(--text-primary); font-size: 1rem;"
                    onkeyup="updateWizardConfigName(this.value)"
                >
            </div>
            ${step.tip ? `
                <div class="wizard-tip">
                    <span class="wizard-tip-icon">ðŸ’¡</span>
                    ${step.tip}
                </div>
            ` : ''}
            ${isComplete ? `
                <div class="wizard-complete-notice">
                    <span style="color: var(--accent-success);">âœ“</span> Name set!
                </div>
            ` : ''}
        `;
    } else {
        // Check if we have a custom success message for completed steps
        const successHtml = isComplete && step.successMessage ? step.successMessage(config) : null;

        // Render linked tutorials if present
        const linkedTutorialsHtml = renderWizardLinkedTutorials(step.linkedTutorials);

        bodyEl.innerHTML = `
            <div class="wizard-description">${description}</div>
            ${step.tip ? `
                <div class="wizard-tip">
                    <span class="wizard-tip-icon">ðŸ’¡</span>
                    ${step.tip}
                </div>
            ` : ''}
            ${isComplete && !successHtml ? `
                <div class="wizard-complete-notice">
                    <span style="color: var(--accent-success);">âœ“</span> This step is complete!
                </div>
            ` : ''}
            ${linkedTutorialsHtml}
        `;

        // Show success popup if there's a custom success message
        if (isComplete && successHtml) {
            showWizardSuccessPopup(successHtml);
        } else {
            closeWizardSuccessPopup();
        }
    }

    // Update buttons
    const prevBtn = document.getElementById('wizardPrev');
    const nextBtn = document.getElementById('wizardNext');
    const actionBtn = document.getElementById('wizardAction');
    const skipBtn = document.getElementById('wizardSkip');

    prevBtn.style.display = wizardStep === 0 ? 'none' : 'inline-block';

    // First step (intro) and last step (complete) have no action
    if (step.id === 'intro') {
        actionBtn.style.display = 'none';
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = 'Get Started';
        skipBtn.style.display = 'none';
    } else if (step.id === 'config_name') {
        actionBtn.style.display = 'none';
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = isComplete ? 'Continue' : 'Set Name & Continue';
        skipBtn.style.display = 'inline-block';
        skipBtn.textContent = step.skipText || 'Skip';
    } else if (step.id === 'complete') {
        actionBtn.style.display = 'none';
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = 'Start Building!';
        skipBtn.style.display = 'none';
    } else if (isComplete) {
        actionBtn.style.display = 'none';
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = 'Continue';
        skipBtn.style.display = 'none';
    } else {
        actionBtn.style.display = 'inline-block';
        actionBtn.textContent = step.action?.type === 'createRelationship' ? 'Add Relationship' : 'Add Node';
        nextBtn.style.display = 'none';
        skipBtn.style.display = step.skipText ? 'inline-block' : 'none';
        skipBtn.textContent = step.skipText || 'Skip';
    }
}

function updateWizardConfigName(value) {
    // Update config with whatever value is typed (even if empty for now)
    const trimmedValue = value ? value.trim() : '';

    if (trimmedValue.length > 0) {
        config.name = trimmedValue;
        config.id = trimmedValue.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
        wizardConfig.configName = trimmedValue;
    }

    // Update sidebar inputs if they exist (don't update wizard input - that causes cursor reset)
    const sidebarNameInput = document.getElementById('configName');
    const sidebarIdInput = document.getElementById('configId');
    if (sidebarNameInput && trimmedValue) sidebarNameInput.value = config.name;
    if (sidebarIdInput && trimmedValue) sidebarIdInput.value = config.id;

    // Update header title to show new config name
    if (typeof updateHeaderTitle === 'function') {
        updateHeaderTitle();
    }

    if (typeof saveToStorage === 'function') {
        saveToStorage();
    }

    // Update completion notice without re-rendering entire step (avoids cursor reset)
    const completionNotice = document.querySelector('.wizard-complete-notice');
    const isComplete = trimmedValue.length > 0 && trimmedValue !== 'New Config';

    if (isComplete && !completionNotice) {
        // Add completion notice
        const bodyEl = document.getElementById('wizardBody');
        const existingNotice = bodyEl.querySelector('.wizard-complete-notice');
        if (!existingNotice) {
            const notice = document.createElement('div');
            notice.className = 'wizard-complete-notice';
            notice.innerHTML = '<span style="color: var(--accent-success);">âœ“</span> Name set!';
            bodyEl.appendChild(notice);
        }
        // Update buttons
        updateWizardButtons(true);
    } else if (!isComplete && completionNotice) {
        // Remove completion notice
        completionNotice.remove();
        updateWizardButtons(false);
    }
}

function updateWizardButtons(isComplete) {
    const actionBtn = document.getElementById('wizardAction');
    const nextBtn = document.getElementById('wizardNext');
    const skipBtn = document.getElementById('wizardSkip');
    const step = wizardSteps[wizardStep];

    if (step.id === 'config_name') {
        actionBtn.style.display = 'none';
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = isComplete ? 'Continue' : 'Set Name & Continue';
        skipBtn.style.display = 'inline-block';
        skipBtn.textContent = step.skipText || 'Skip';
    }
}

function doWizardAction() {
    const step = wizardSteps[wizardStep];
    if (!step.action) return;

    // Check if step is already complete - prevent duplicate creation
    if (step.validate && step.validate()) {
        // Step already complete, just show the next step instead
        renderWizardStep();
        return;
    }

    if (step.action.type === 'createNode') {
        openWizardNodeModal(step.action);
    } else if (step.action.type === 'createRelationship') {
        openWizardRelationshipModal(step.action);
    } else if (step.action.type === 'nameConfig') {
        // Focus the name input
        const input = document.getElementById('wizardConfigName');
        if (input) input.focus();
    }
}

function openWizardNodeModal(action) {
    // Show the add node modal with sidebar mode
    const modal = document.getElementById('addNodeModal');
    if (!modal) return;

    modal.classList.add('active');
    modal.classList.add('sidebar-mode'); // Use sidebar mode instead of overlay

    // Reset ID lock state
    if (typeof userEditedId !== 'undefined') userEditedId = false;
    if (typeof idLocked !== 'undefined') idLocked = true;

    // Select the node type FIRST - this renders the Name/ID fields
    if (typeof selectNodeType === 'function') {
        selectNodeType(action.nodeType);
    }

    // Determine suggested name/id - support dynamic suggestions for traits
    let suggestedName = action.suggestedName;
    let suggestedId = action.suggestedId;

    // For traits with multiple suggestions, use dynamic function based on creation count
    if (action.nodeType === 'trait' && action.getSuggestedName) {
        const traitIndex = wizardConfig.traitCreationCount || 0;
        suggestedName = action.getSuggestedName(traitIndex);
        suggestedId = action.getSuggestedId ? action.getSuggestedId(traitIndex) : `trait_${suggestedName.toLowerCase().replace(/\s+/g, '_')}`;
    }

    // Pre-fill values AFTER the type is selected (fields now exist)
    // Use requestAnimationFrame + setTimeout to ensure DOM is fully rendered
    requestAnimationFrame(() => {
        setTimeout(() => {
            const idInput = document.getElementById('newNodeId');
            const nameInput = document.getElementById('newNodeName');
            if (idInput) idInput.value = suggestedId || '';
            if (nameInput) nameInput.value = suggestedName || '';

            // If creating a trait and we have a layer, pre-select it
            if (action.nodeType === 'trait' && wizardConfig.layerId) {
                const layerSelect = document.getElementById('newNodeLayerId');
                if (layerSelect) {
                    layerSelect.value = wizardConfig.layerId;
                }
            }

            // Apply wizard config values to form fields
            if (action.config) {
                applyWizardNodeConfig(action.nodeType, action.config);
            }
        }, 50);  // Increased delay to ensure DOM is ready
    });
}

/**
 * Apply wizard-suggested config values to Add Node form fields
 */
function applyWizardNodeConfig(nodeType, cfg) {
    // Resolve any function values in the config
    const config = {};
    for (const key in cfg) {
        config[key] = typeof cfg[key] === 'function' ? cfg[key]() : cfg[key];
    }

    // Common fields for attribute and variable
    if (nodeType === 'attribute' || nodeType === 'variable') {
        if (config.min !== undefined) {
            const minField = document.getElementById('newNodeMin');
            if (minField) minField.value = config.min;
        }
        if (config.max !== undefined) {
            const maxField = document.getElementById('newNodeMax');
            if (maxField) maxField.value = config.max;
        }
        if (config.default !== undefined) {
            const defaultField = document.getElementById('newNodeDefault');
            if (defaultField) defaultField.value = config.default;
        }
    }

    // Variable-specific fields
    if (nodeType === 'variable') {
        // Set changeMode FIRST to make the rate section visible
        if (config.changeMode !== undefined) {
            const modeField = document.getElementById('newNodeChangeMode');
            if (modeField) {
                modeField.value = config.changeMode;
                // Trigger the toggle to show/hide rate section
                if (typeof toggleVariableRateSection === 'function') {
                    toggleVariableRateSection();
                }
            }
        }
        // Now set the rate (rate section should be visible if changeMode is 'timed')
        if (config.rate !== undefined) {
            const rateField = document.getElementById('newNodeRate');
            if (rateField) rateField.value = config.rate;
        }
    }

    // Modifier-specific fields
    if (nodeType === 'modifier') {
        if (config.trigger) {
            const triggerTypeField = document.getElementById('newNodeTriggerType');
            if (triggerTypeField && config.trigger.type) {
                triggerTypeField.value = config.trigger.type;
                if (typeof toggleModifierTriggerConfig === 'function') {
                    toggleModifierTriggerConfig();
                }
            }
            // Threshold config
            if (config.trigger.type === 'threshold') {
                setTimeout(() => {
                    if (config.trigger.variableId) {
                        const varField = document.getElementById('newNodeThresholdVariable');
                        if (varField) varField.value = typeof config.trigger.variableId === 'function' ? config.trigger.variableId() : config.trigger.variableId;
                    }
                    if (config.trigger.condition) {
                        const condField = document.getElementById('newNodeThresholdCondition');
                        if (condField) condField.value = config.trigger.condition;
                    }
                    if (config.trigger.value !== undefined) {
                        const valField = document.getElementById('newNodeThresholdValue');
                        if (valField) valField.value = config.trigger.value;
                    }
                }, 50);
            }
        }
        if (config.duration) {
            const durationTypeField = document.getElementById('newNodeDurationType');
            if (durationTypeField && config.duration.type) {
                durationTypeField.value = config.duration.type;
            }
            if (config.duration.value !== undefined) {
                const durationValueField = document.getElementById('newNodeDurationValue');
                if (durationValueField) durationValueField.value = config.duration.value;
            }
            // Tick system binding
            if (config.duration.tickSystemId) {
                const tickField = document.getElementById('newNodeTickSystemId');
                if (tickField) {
                    const tickId = typeof config.duration.tickSystemId === 'function' ? config.duration.tickSystemId() : config.duration.tickSystemId;
                    tickField.value = tickId;
                }
            }
        }
    }

    // Tick system-specific fields
    if (nodeType === 'ticksystem') {
        if (config.unit !== undefined) {
            const unitField = document.getElementById('newNodeTickUnit');
            if (unitField) unitField.value = config.unit;
        }
        if (config.interval !== undefined) {
            const intervalField = document.getElementById('newNodeTickInterval');
            if (intervalField) intervalField.value = config.interval || '';
        }
    }
}

function openWizardRelationshipModal(action) {
    const sourceId = typeof action.sourceId === 'function' ? action.sourceId() : action.sourceId;
    const targetId = typeof action.targetId === 'function' ? action.targetId() : action.targetId;

    if (!sourceId) {
        alert('Please create the source node first (check previous steps)');
        return;
    }

    // Select the source node
    selectNode(sourceId);

    // Use showAddRelationshipModal to properly populate the dropdown
    setTimeout(() => {
        showAddRelationshipModal();

        // Pre-fill values after modal is open and populated
        setTimeout(() => {
            document.getElementById('newRelType').value = action.relType;
            updateRelTypeHelp();

            if (targetId) {
                document.getElementById('newRelTarget').value = targetId;
            }
            document.getElementById('newRelOperation').value = action.operation;
            document.getElementById('newRelValue').value = action.value;

            // Update the preview to reflect the new values
            if (typeof updateRelPreview === 'function') {
                updateRelPreview();
            }
        }, 50);
    }, 100);
}

function nextWizardStep() {
    closeWizardSuccessPopup();

    // Special handling for config name step
    if (wizardSteps[wizardStep].id === 'config_name') {
        const input = document.getElementById('wizardConfigName');
        const inputValue = input ? input.value.trim() : '';

        // If no name entered, use default "My RPG System"
        const nameToUse = inputValue.length > 0 ? inputValue : 'My RPG System';
        setConfigName(nameToUse);
    }

    if (wizardStep < wizardSteps.length - 1) {
        wizardStep++;
        renderWizardStep();
    } else {
        // Final step - just close the wizard, let user continue where they are
        closeWizard();
    }
}

// Helper to set config name (used by both continue and skip)
function setConfigName(name) {
    config.name = name;
    config.id = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    wizardConfig.configName = name;

    // Update sidebar
    const sidebarNameInput = document.getElementById('configName');
    const sidebarIdInput = document.getElementById('configId');
    if (sidebarNameInput) sidebarNameInput.value = config.name;
    if (sidebarIdInput) sidebarIdInput.value = config.id;

    // Update header
    if (typeof updateHeaderTitle === 'function') {
        updateHeaderTitle();
    }

    if (typeof saveToStorage === 'function') {
        saveToStorage();
    }
}

function prevWizardStep() {
    closeWizardSuccessPopup();
    if (wizardStep > 0) {
        wizardStep--;
        renderWizardStep();
    }
}

function skipWizardStep() {
    const step = wizardSteps[wizardStep];

    // Config name step - just use default
    if (step.id === 'config_name') {
        nextWizardStep();
        return;
    }

    if (step.validate && step.validate()) {
        nextWizardStep();
    } else {
        if (confirm('Skip this step? You can always add this later.')) {
            nextWizardStep();
        }
    }
}

// Check if wizard step is complete after node/relationship creation
function checkWizardProgress() {
    if (!wizardActive) return;

    const step = wizardSteps[wizardStep];

    // For trait step, track how many traits have been created
    if (step.id === 'traits') {
        const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
        wizardConfig.traitCreationCount = traits.length;
    }

    if (step.validate && step.validate()) {
        renderWizardStep();
    }
}

// ========================================
// LINKED TUTORIALS
// ========================================

/**
 * Render linked tutorial links for a wizard step
 * @param {Array} linkedTutorials - Array of linked tutorial configs
 * @returns {string} HTML string for the links section
 */
function renderWizardLinkedTutorials(linkedTutorials) {
    if (!linkedTutorials || linkedTutorials.length === 0) {
        return '';
    }

    // Check if TutorialSystem is available
    if (typeof TutorialSystem === 'undefined') {
        return '';
    }

    // Filter by condition
    const visibleLinks = linkedTutorials.filter(link =>
        !link.condition || link.condition()
    );

    if (visibleLinks.length === 0) {
        return '';
    }

    const linksHtml = visibleLinks.map(link => `
        <div class="tutorial-link-item" onclick="navigateToLinkedTutorial('${link.moduleId}', '${link.returnLabel || 'Return to Wizard'}')">
            <span class="link-icon">&#128214;</span>
            <span class="link-text">${link.label}</span>
            <span class="link-arrow">&rarr;</span>
        </div>
    `).join('');

    return `
        <div class="tutorial-system-links" style="margin-top: 1.25rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
            <div class="links-title" style="font-size: 0.8rem; text-transform: uppercase; color: var(--text-muted); margin-bottom: 0.75rem; letter-spacing: 0.05em;">Learn More</div>
            ${linksHtml}
        </div>
    `;
}

/**
 * Navigate to a linked tutorial from the wizard
 * Saves wizard state and opens the tutorial
 */
function navigateToLinkedTutorial(moduleId, returnLabel) {
    if (typeof TutorialSystem === 'undefined') {
        console.warn('TutorialSystem not available');
        return;
    }

    // Close wizard panel (tutorial will take over)
    closeWizard();

    // Start the linked tutorial with return info
    TutorialSystem.start(moduleId, {
        pushToStack: false,  // We're not coming from another tutorial
        returnLabel: returnLabel
    });

    // Store wizard state so we can resume
    try {
        localStorage.setItem('spawnEditor_wizardReturnStep', String(wizardStep));
    } catch (e) {
        console.warn('Failed to save wizard return state', e);
    }
}

/**
 * Resume wizard from where we left off (called when returning from tutorial)
 */
function resumeWizardFromTutorial() {
    try {
        const savedStep = localStorage.getItem('spawnEditor_wizardReturnStep');
        if (savedStep !== null) {
            wizardStep = parseInt(savedStep, 10);
            localStorage.removeItem('spawnEditor_wizardReturnStep');
            initWizardContinue();
        }
    } catch (e) {
        console.warn('Failed to resume wizard', e);
    }
}

// ========================================
// EXPORTS
// ========================================

if (typeof window !== 'undefined') {
    window.startWizard = startWizard;
    window.closeWizard = closeWizard;
    window.nextWizardStep = nextWizardStep;
    window.prevWizardStep = prevWizardStep;
    window.skipWizardStep = skipWizardStep;
    window.doWizardAction = doWizardAction;
    window.checkWizardProgress = checkWizardProgress;
    window.wizardActive = () => wizardActive;
    window.initWizardFresh = initWizardFresh;
    window.initWizardContinue = initWizardContinue;
    window.closeWizardStartModal = closeWizardStartModal;
    window.updateWizardConfigName = updateWizardConfigName;
    window.updateWizardButtons = updateWizardButtons;
    window.setConfigName = setConfigName;
    window.exportAndStartWizard = exportAndStartWizard;
    window.navigateToLinkedTutorial = navigateToLinkedTutorial;
    window.resumeWizardFromTutorial = resumeWizardFromTutorial;
}

</script>
    <script>
// ============================================================================
// TUTORIAL SYSTEM
// ============================================================================

/**
 * Spawn Editor - Modular Tutorial System
 * Centralized registry for linked tutorial modules with navigation stack
 */

const TutorialSystem = (function() {
    // ========================================
    // PRIVATE STATE
    // ========================================

    const modules = new Map();
    let navigationStack = [];
    let activeModuleId = null;
    let activeStepIndex = 0;
    let completedModules = new Set();
    let returnLabel = null;

    // ========================================
    // STORAGE
    // ========================================

    const STORAGE_KEYS = {
        COMPLETED: 'spawnEditor_tutorialsCompleted',
        PROGRESS: 'spawnEditor_tutorialProgress',
        STACK: 'spawnEditor_tutorialStack'
    };

    function loadState() {
        try {
            const completed = localStorage.getItem(STORAGE_KEYS.COMPLETED);
            if (completed) completedModules = new Set(JSON.parse(completed));
        } catch (e) {
            console.warn('Failed to load tutorial state:', e);
        }
    }

    function saveState() {
        try {
            localStorage.setItem(STORAGE_KEYS.COMPLETED,
                JSON.stringify([...completedModules]));
        } catch (e) {
            console.warn('Failed to save tutorial state:', e);
        }
    }

    // ========================================
    // REGISTRATION
    // ========================================

    function register(moduleConfig) {
        if (!moduleConfig.id) {
            throw new Error('Tutorial module must have an id');
        }
        if (!moduleConfig.steps || !Array.isArray(moduleConfig.steps)) {
            throw new Error('Tutorial module must have a steps array');
        }
        modules.set(moduleConfig.id, {
            displayStyle: 'overlay',
            ...moduleConfig
        });
    }

    // ========================================
    // NAVIGATION
    // ========================================

    function start(moduleId, options = {}) {
        const module = modules.get(moduleId);
        if (!module) {
            console.error(`Tutorial module not found: ${moduleId}`);
            return;
        }

        // If coming from another tutorial, push current state to stack
        if (activeModuleId && options.pushToStack !== false) {
            navigationStack.push({
                moduleId: activeModuleId,
                stepIndex: activeStepIndex
            });
        }

        activeModuleId = moduleId;
        activeStepIndex = options.stepIndex || 0;
        returnLabel = options.returnLabel || null;

        // Lifecycle hook
        if (module.onStart) module.onStart();

        render();
    }

    function goToStep(stepIndex) {
        const module = modules.get(activeModuleId);
        if (!module) return;

        if (stepIndex >= 0 && stepIndex < module.steps.length) {
            activeStepIndex = stepIndex;
            render();
        }
    }

    function next() {
        const module = modules.get(activeModuleId);
        if (!module) return;

        // Check if current step has validation that passes
        const step = module.steps[activeStepIndex];
        if (step.validate && !step.validate()) {
            // Validation failed, don't proceed
            return;
        }

        if (activeStepIndex < module.steps.length - 1) {
            activeStepIndex++;
            render();
        } else {
            complete();
        }
    }

    function prev() {
        if (activeStepIndex > 0) {
            activeStepIndex--;
            render();
        }
    }

    function complete() {
        const module = modules.get(activeModuleId);
        if (module) {
            completedModules.add(activeModuleId);
            if (module.onComplete) module.onComplete();
        }

        saveState();

        // Check if we should return to a previous tutorial
        if (navigationStack.length > 0) {
            returnToPrevious();
        } else {
            close();
        }
    }

    function returnToPrevious() {
        if (navigationStack.length === 0) {
            close();
            return;
        }

        const previous = navigationStack.pop();
        const module = modules.get(previous.moduleId);

        // Show completion toast before returning
        const currentModule = modules.get(activeModuleId);
        if (currentModule && typeof showToast === 'function') {
            showToast(`${currentModule.name || 'Tutorial'} completed!`, 'success');
        }

        activeModuleId = previous.moduleId;
        activeStepIndex = previous.stepIndex;
        returnLabel = null;

        if (module && module.onReturn) module.onReturn();

        render();
    }

    function close() {
        activeModuleId = null;
        activeStepIndex = 0;
        navigationStack = [];
        returnLabel = null;

        hideAllContainers();
    }

    // ========================================
    // LINKED NAVIGATION
    // ========================================

    function navigateToLinked(targetModuleId, label) {
        start(targetModuleId, {
            pushToStack: true,
            returnLabel: label || 'Return'
        });
    }

    // ========================================
    // RENDERING
    // ========================================

    function getOrCreateContainer(displayStyle) {
        const containerId = `tutorialSystem-${displayStyle}`;
        let container = document.getElementById(containerId);

        if (!container) {
            container = document.createElement('div');
            container.id = containerId;
            container.className = `tutorial-system-container tutorial-system-${displayStyle}`;

            if (displayStyle === 'overlay') {
                container.innerHTML = `
                    <div class="tutorial-system-backdrop" onclick="TutorialSystem.close()"></div>
                    <div class="tutorial-system-card">
                        <div class="tutorial-system-breadcrumb" id="${containerId}-breadcrumb"></div>
                        <div class="tutorial-system-header">
                            <div class="tutorial-system-steps" id="${containerId}-steps"></div>
                        </div>
                        <div class="tutorial-system-body" id="${containerId}-body"></div>
                        <div class="tutorial-system-footer">
                            <span class="tutorial-system-skip" onclick="TutorialSystem.close()">Close</span>
                            <div class="tutorial-system-nav">
                                <button class="btn btn-secondary" id="${containerId}-return" onclick="TutorialSystem.returnToPrevious()" style="display: none;">Return</button>
                                <button class="btn btn-secondary" id="${containerId}-prev" onclick="TutorialSystem.prev()">Back</button>
                                <button class="btn btn-primary" id="${containerId}-next" onclick="TutorialSystem.next()">Next</button>
                            </div>
                        </div>
                    </div>
                `;
            } else if (displayStyle === 'panel') {
                container.innerHTML = `
                    <div class="tutorial-system-panel">
                        <div class="tutorial-system-panel-header">
                            <div class="tutorial-system-breadcrumb" id="${containerId}-breadcrumb"></div>
                            <span class="tutorial-system-title" id="${containerId}-title"></span>
                            <span class="tutorial-system-progress" id="${containerId}-progress"></span>
                        </div>
                        <div class="tutorial-system-body" id="${containerId}-body"></div>
                        <div class="tutorial-system-footer">
                            <div class="tutorial-system-nav">
                                <button class="btn btn-secondary" id="${containerId}-return" onclick="TutorialSystem.returnToPrevious()" style="display: none;">Return</button>
                                <button class="btn btn-secondary" id="${containerId}-prev" onclick="TutorialSystem.prev()">Back</button>
                                <button class="btn btn-primary" id="${containerId}-next" onclick="TutorialSystem.next()">Next</button>
                            </div>
                            <button class="btn btn-icon" onclick="TutorialSystem.close()" title="Close">&#10005;</button>
                        </div>
                    </div>
                `;
            }

            document.body.appendChild(container);
        }

        return container;
    }

    function hideAllContainers() {
        document.querySelectorAll('.tutorial-system-container').forEach(el => {
            el.classList.remove('active');
        });
    }

    function render() {
        const module = modules.get(activeModuleId);
        if (!module) return;

        const step = module.steps[activeStepIndex];
        const displayStyle = module.displayStyle || 'overlay';
        const containerId = `tutorialSystem-${displayStyle}`;

        // Hide other containers, show this one
        hideAllContainers();
        const container = getOrCreateContainer(displayStyle);
        container.classList.add('active');

        // Render breadcrumb if we have a navigation stack
        const breadcrumbEl = document.getElementById(`${containerId}-breadcrumb`);
        if (breadcrumbEl) {
            if (navigationStack.length > 0) {
                const crumbs = navigationStack.map(item => {
                    const m = modules.get(item.moduleId);
                    return `<span class="breadcrumb-item">${m?.name || item.moduleId}</span>`;
                }).join('<span class="breadcrumb-sep"> &rsaquo; </span>');

                breadcrumbEl.innerHTML = crumbs +
                    `<span class="breadcrumb-sep"> &rsaquo; </span>` +
                    `<span class="breadcrumb-current">${module.name || activeModuleId}</span>`;
                breadcrumbEl.style.display = 'flex';
            } else {
                breadcrumbEl.style.display = 'none';
            }
        }

        // Render step indicators
        const stepsEl = document.getElementById(`${containerId}-steps`);
        if (stepsEl) {
            stepsEl.innerHTML = module.steps.map((_, i) => `
                <span class="tutorial-system-step-dot ${i === activeStepIndex ? 'active' : ''} ${i < activeStepIndex ? 'completed' : ''}"></span>
            `).join('');
        }

        // Render title/progress for panel style
        const titleEl = document.getElementById(`${containerId}-title`);
        if (titleEl) titleEl.textContent = module.name || 'Tutorial';

        const progressEl = document.getElementById(`${containerId}-progress`);
        if (progressEl) progressEl.textContent = `Step ${activeStepIndex + 1} of ${module.steps.length}`;

        // Render body content
        const bodyEl = document.getElementById(`${containerId}-body`);
        if (bodyEl) {
            bodyEl.scrollTop = 0;
            bodyEl.innerHTML = buildStepHTML(module, step);
        }

        // Update navigation buttons
        updateNavigation(containerId, module, step);
    }

    function buildStepHTML(module, step) {
        let html = `
            <div class="tutorial-system-step-title">
                ${step.icon ? `<span class="tutorial-icon" style="background: ${step.icon}"></span>` : ''}
                ${step.title}
            </div>
            <div class="tutorial-system-description">${step.description}</div>
        `;

        // Tip
        if (step.tip) {
            html += `
                <div class="tutorial-system-tip">
                    <span class="tip-icon">&#128161;</span>
                    <span class="tip-text">${step.tip}</span>
                </div>
            `;
        }

        // Examples
        if (step.examples && step.examples.length > 0) {
            html += `
                <div class="tutorial-system-examples">
                    <div class="examples-title">Examples in Different Games</div>
                    ${step.examples.map(ex => `
                        <div class="tutorial-example-item">
                            <span class="example-icon">${ex.icon}</span>
                            <div class="example-content">
                                <span class="example-game">${ex.game}:</span>
                                <span class="example-desc">${ex.desc}</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Linked tutorials
        if (step.linkedTutorials && step.linkedTutorials.length > 0) {
            const visibleLinks = step.linkedTutorials.filter(link =>
                !link.condition || link.condition()
            );

            if (visibleLinks.length > 0) {
                html += `
                    <div class="tutorial-system-links">
                        <div class="links-title">Learn More</div>
                        ${visibleLinks.map(link => `
                            <div class="tutorial-link-item" onclick="TutorialSystem.navigateToLinked('${link.moduleId}', '${link.returnLabel || 'Return'}')">
                                <span class="link-icon">&#128214;</span>
                                <span class="link-text">${link.label}</span>
                                <span class="link-arrow">&rarr;</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        }

        return html;
    }

    function updateNavigation(containerId, module, step) {
        const prevBtn = document.getElementById(`${containerId}-prev`);
        const nextBtn = document.getElementById(`${containerId}-next`);
        const returnBtn = document.getElementById(`${containerId}-return`);

        // Previous button
        if (prevBtn) {
            prevBtn.style.display = activeStepIndex === 0 ? 'none' : 'inline-block';
        }

        // Return button (only show if we have a stack)
        if (returnBtn) {
            if (navigationStack.length > 0) {
                returnBtn.style.display = 'inline-block';
                returnBtn.textContent = returnLabel || 'Return';
            } else {
                returnBtn.style.display = 'none';
            }
        }

        // Next button
        if (nextBtn) {
            const isLastStep = activeStepIndex === module.steps.length - 1;
            const hasValidation = step.validate;
            const isComplete = hasValidation ? step.validate() : true;

            if (isLastStep) {
                if (navigationStack.length > 0) {
                    nextBtn.textContent = 'Complete & Return';
                } else {
                    nextBtn.textContent = 'Finish';
                }
            } else if (step.id === 'intro' || activeStepIndex === 0) {
                nextBtn.textContent = 'Get Started';
            } else {
                nextBtn.textContent = 'Next';
            }
        }
    }

    // ========================================
    // PUBLIC API
    // ========================================

    return {
        // Core methods
        register,
        start,
        goToStep,
        next,
        prev,
        complete,
        close,
        returnToPrevious,
        navigateToLinked,

        // Getters
        getActiveModule: () => modules.get(activeModuleId),
        getActiveModuleId: () => activeModuleId,
        getActiveStep: () => modules.get(activeModuleId)?.steps[activeStepIndex],
        getActiveStepIndex: () => activeStepIndex,
        getNavigationStack: () => [...navigationStack],
        isCompleted: (moduleId) => completedModules.has(moduleId),
        isActive: () => activeModuleId !== null,
        getModules: () => [...modules.keys()],

        // Initialization
        init: loadState
    };
})();

// Initialize on load
if (typeof window !== 'undefined') {
    window.TutorialSystem = TutorialSystem;
    document.addEventListener('DOMContentLoaded', () => TutorialSystem.init());
}

</script>
    <script>
// ============================================================================
// TUTORIAL: TICK SYSTEM
// ============================================================================

/**
 * Tick System Tutorial
 * Teaches users about time/turn-based systems for modifier durations and variable rates
 */

(function() {
    if (typeof TutorialSystem === 'undefined') {
        console.warn('TutorialSystem not loaded, tick-system tutorial cannot register');
        return;
    }

    TutorialSystem.register({
        id: 'tick-system',
        name: 'Tick System Tutorial',
        displayStyle: 'overlay',

        steps: [
            {
                id: 'intro',
                title: 'Understanding Tick Systems',
                description: `
                    <p><strong>Tick Systems</strong> define how time passes in your game. They control when variables change and how long modifiers last.</p>
                    <p style="margin-top: 0.75rem;">There are two main approaches:</p>
                    <div style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                        <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-ticksystem);">
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Real-Time</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Ticks happen automatically (e.g., every second)</div>
                        </div>
                        <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-ticksystem);">
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Turn-Based</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Your code triggers ticks (e.g., "end turn")</div>
                        </div>
                    </div>
                `,
                tip: 'You can have multiple tick systems! Combat turns, day/night cycles, and real-time effects can all coexist.',
                examples: [
                    { icon: '&#9876;', game: 'RPG Combat', desc: 'Turn-based: poison lasts 3 turns, stun lasts 1 turn' },
                    { icon: '&#127866;', game: 'Tavern Sim', desc: 'Real-time: hunger depletes every 5 seconds' },
                    { icon: '&#127968;', game: 'Colony Sim', desc: 'Mixed: day/night cycles (turns) + stamina drain (real-time)' }
                ]
            },
            {
                id: 'when-needed',
                title: 'When Do You Need a Tick System?',
                description: `
                    <p>You need a tick system when you have:</p>
                    <ul style="margin: 0.75rem 0; padding-left: 1.5rem;">
                        <li><strong>Variables with rates</strong> - Hunger depleting, rage building, mana regenerating</li>
                        <li><strong>Modifiers with durations</strong> - "Stunned for 2 turns", "Blessed for 30 seconds"</li>
                        <li><strong>Threshold triggers</strong> - Check if hunger hit 0, if rage exceeded 80</li>
                    </ul>
                    <p style="margin-top: 0.75rem; color: var(--text-muted);">If your entities are static (no changing values over time), you may not need a tick system at all!</p>
                `,
                tip: 'The engine can work without tick systems. Attributes and spawn-time traits work fine without ticks.'
            },
            {
                id: 'creating',
                title: 'Creating a Tick System',
                description: `
                    <p>To add a tick system to your config:</p>
                    <ol style="margin: 0.75rem 0; padding-left: 1.5rem;">
                        <li>Click <strong>Add Node</strong> in the sidebar</li>
                        <li>Select <strong>Tick System</strong> type</li>
                        <li>Configure the settings:
                            <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.9rem;">
                                <li><strong>Name</strong>: "Combat Turns" or "Real-Time"</li>
                                <li><strong>Unit</strong>: "turns", "seconds", "ticks"</li>
                                <li><strong>Interval</strong>: Auto-tick rate (leave empty for manual)</li>
                            </ul>
                        </li>
                    </ol>
                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem; font-family: monospace; font-size: 0.8rem; border-left: 3px solid var(--accent-secondary);">
                        <div style="color: var(--text-muted); margin-bottom: 0.25rem;">// Example: Turn-based combat</div>
                        <div>Name: "Combat Turns"</div>
                        <div>Unit: "turns"</div>
                        <div>Interval: (empty - you call tick manually)</div>
                    </div>
                `,
                tip: 'Turn-based games typically have manual ticks. Real-time games have interval-based auto-ticks.'
            },
            {
                id: 'binding',
                title: 'Binding Modifiers to Ticks',
                description: `
                    <p>Modifiers with durations need to know <em>which</em> tick system decrements them.</p>
                    <p style="margin-top: 0.75rem;">When creating or editing a modifier:</p>
                    <ol style="margin: 0.75rem 0; padding-left: 1.5rem;">
                        <li>Set <strong>Duration Type</strong> to "Ticks" or "Timed"</li>
                        <li>Enter a <strong>Duration Value</strong> (e.g., 3 turns)</li>
                        <li>Select which <strong>Tick System</strong> to bind to</li>
                    </ol>
                    <p style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(74, 124, 89, 0.15); border-radius: 4px; font-size: 0.85rem;">
                        <strong>Result:</strong> When "Combat Turns" advances, the modifier's duration decreases by 1. At 0, it's removed.
                    </p>
                `,
                tip: 'A modifier can only be bound to one tick system. Choose the one that makes sense for that effect.'
            },
            {
                id: 'advancing',
                title: 'Advancing Ticks in Your Game',
                description: `
                    <p>In your game code, you control when ticks happen:</p>
                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem; font-family: monospace; font-size: 0.8rem;">
                        <div style="color: var(--accent-secondary);">// Turn-based: call when player ends turn</div>
                        <div>engine.tick('tick_combat');</div>
                        <div style="margin-top: 0.75rem; color: var(--accent-secondary);">// Real-time: engine auto-ticks, or:</div>
                        <div>setInterval(() => engine.tick('tick_realtime'), 1000);</div>
                    </div>
                    <p style="margin-top: 0.75rem;">Each tick:</p>
                    <ul style="padding-left: 1.5rem; font-size: 0.9rem;">
                        <li>Variables with rates update (hunger -= rate)</li>
                        <li>Modifier durations decrement</li>
                        <li>Threshold triggers are checked</li>
                        <li>Compounds re-evaluate</li>
                    </ul>
                `,
                tip: 'The Preview tab has manual tick buttons for testing your system without writing code!'
            },
            {
                id: 'complete',
                title: 'Tick Systems Complete!',
                description: `
                    <p style="color: var(--accent-success); font-weight: 600;">You now understand time-based mechanics!</p>
                    <p style="margin-top: 0.75rem;">Quick reference:</p>
                    <table style="width: 100%; font-size: 0.85rem; margin-top: 0.5rem; border-collapse: collapse;">
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 0.5rem; color: var(--text-muted);">Turn-based</td>
                            <td style="padding: 0.5rem;">Call <code>engine.tick()</code> manually</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 0.5rem; color: var(--text-muted);">Real-time</td>
                            <td style="padding: 0.5rem;">Set interval in config, auto-ticks</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.5rem; color: var(--text-muted);">Preview</td>
                            <td style="padding: 0.5rem;">Use tick buttons to test</td>
                        </tr>
                    </table>
                `,
                linkedTutorials: [
                    {
                        moduleId: 'entity-management',
                        label: 'Learn about Entity Pools & Management',
                        returnLabel: 'Return to Tick System'
                    }
                ]
            }
        ],

        onComplete: () => {
            if (typeof showToast === 'function') {
                showToast('Tick System tutorial completed!', 'success');
            }
        }
    });
})();

</script>
    <script>
// ============================================================================
// TUTORIAL: ENTITY MANAGEMENT
// ============================================================================

/**
 * Entity Management Tutorial
 * Teaches users about entity pools, promotion from preview, and lifecycle management
 */

(function() {
    if (typeof TutorialSystem === 'undefined') {
        console.warn('TutorialSystem not loaded, entity-management tutorial cannot register');
        return;
    }

    TutorialSystem.register({
        id: 'entity-management',
        name: 'Entity Management Tutorial',
        displayStyle: 'overlay',

        steps: [
            {
                id: 'intro',
                title: 'Managing Spawned Entities',
                description: `
                    <p>Once you've designed your entity system, you need to manage the <strong>actual entities</strong> that get spawned during gameplay.</p>
                    <p style="margin-top: 0.75rem;">The Spawn Engine provides two ways to work with entities:</p>
                    <div style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                        <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-attribute);">
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Preview Mode</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Quick testing - entities exist only in the editor</div>
                        </div>
                        <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-variable);">
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">Entity Manager</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Full tracking with pools, state, and lifecycle</div>
                        </div>
                    </div>
                `,
                tip: 'Preview is great for testing your config. Entity Manager is what your game will actually use.'
            },
            {
                id: 'preview',
                title: 'Preview Tab: Quick Testing',
                description: `
                    <p>The <strong>Preview</strong> tab lets you test your config without writing code:</p>
                    <ul style="margin: 0.75rem 0; padding-left: 1.5rem;">
                        <li><strong>Spawn</strong> - Create an entity with rolled attributes/traits</li>
                        <li><strong>Edit values</strong> - Manually adjust variables to test thresholds</li>
                        <li><strong>Toggle traits</strong> - Activate/deactivate to test compounds</li>
                        <li><strong>Advance ticks</strong> - Watch modifiers expire, variables change</li>
                    </ul>
                    <p style="margin-top: 0.75rem; padding: 0.5rem; background: var(--bg-card); border-radius: 4px; font-size: 0.85rem;">
                        Preview entities are temporary - they disappear when you refresh. To keep entities, promote them to the Entity Manager.
                    </p>
                `,
                tip: 'Double-click any value in Preview to edit it directly!'
            },
            {
                id: 'pools',
                title: 'Entity Pools',
                description: `
                    <p><strong>Pools</strong> organize your entities into logical groups:</p>
                    <ul style="margin: 0.75rem 0; padding-left: 1.5rem;">
                        <li><strong>Enemies Pool</strong> - All hostile creatures</li>
                        <li><strong>Party Pool</strong> - Player's companions</li>
                        <li><strong>NPC Pool</strong> - Friendly townspeople</li>
                    </ul>
                    <p style="margin-top: 0.75rem;">Each pool can have its own settings:</p>
                    <table style="width: 100%; font-size: 0.85rem; margin-top: 0.5rem; border-collapse: collapse;">
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 0.5rem; color: var(--text-muted);">Max Size</td>
                            <td style="padding: 0.5rem;">Limit entities (e.g., max 50 enemies)</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 0.5rem; color: var(--text-muted);">Pre-warm</td>
                            <td style="padding: 0.5rem;">Pre-spawn entities for performance</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.5rem; color: var(--text-muted);">Auto-shrink</td>
                            <td style="padding: 0.5rem;">Release inactive entities</td>
                        </tr>
                    </table>
                `,
                tip: 'Use pools to manage memory - release entities back to pools instead of destroying them.'
            },
            {
                id: 'assignment',
                title: 'Pool Assignment Rules',
                description: `
                    <p>Entities can be <strong>automatically assigned</strong> to pools based on rules:</p>
                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem; font-size: 0.85rem;">
                        <div style="font-weight: 500; margin-bottom: 0.5rem;">Example Rules:</div>
                        <ul style="padding-left: 1.25rem; margin: 0;">
                            <li style="margin-bottom: 0.35rem;">Preset matches <code>enemy_*</code> &rarr; Enemies Pool</li>
                            <li style="margin-bottom: 0.35rem;">Has trait <code>hostile</code> &rarr; Enemies Pool</li>
                            <li style="margin-bottom: 0.35rem;">Attribute <code>strength &gt; 15</code> &rarr; Elite Pool</li>
                        </ul>
                    </div>
                    <p style="margin-top: 0.75rem;">In code:</p>
                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; font-family: monospace; font-size: 0.8rem;">
                        <div style="color: var(--accent-secondary);">// Spawn goes to appropriate pool automatically</div>
                        <div>const goblin = engine.spawn('enemy_goblin');</div>
                        <div style="color: var(--text-muted);">// &rarr; Assigned to 'enemies' pool</div>
                    </div>
                `,
                tip: 'Rules are checked in order. First matching rule wins.'
            },
            {
                id: 'promotion',
                title: 'Promoting Preview Entities',
                description: `
                    <p>Found an interesting entity in Preview? <strong>Promote</strong> it to the Entity Manager:</p>
                    <ol style="margin: 0.75rem 0; padding-left: 1.5rem;">
                        <li>Spawn an entity in Preview</li>
                        <li>Click the <strong>&#9733; Star</strong> or <strong>Promote</strong> button</li>
                        <li>Choose a pool (or let rules decide)</li>
                        <li>Entity is now tracked in Entity Manager!</li>
                    </ol>
                    <p style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(74, 124, 89, 0.15); border-radius: 4px; font-size: 0.85rem;">
                        <strong>Use case:</strong> Testing found a perfect "boss" roll? Promote it and export the entity data for your game.
                    </p>
                `,
                tip: 'Promoted entities keep their current state - useful for saving specific configurations.'
            },
            {
                id: 'lifecycle',
                title: 'Entity Lifecycle',
                description: `
                    <p>Entities have a lifecycle managed by the engine:</p>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 1rem 0; font-size: 0.85rem;">
                        <div style="text-align: center; padding: 0.5rem;">
                            <div style="background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem 0.75rem; margin-bottom: 0.25rem;">Spawn</div>
                            <div style="color: var(--text-muted);">Created</div>
                        </div>
                        <div style="color: var(--border-ornate);">&rarr;</div>
                        <div style="text-align: center; padding: 0.5rem;">
                            <div style="background: var(--bg-card); border: 1px solid var(--accent-success); border-radius: 4px; padding: 0.5rem 0.75rem; margin-bottom: 0.25rem;">Active</div>
                            <div style="color: var(--text-muted);">In game</div>
                        </div>
                        <div style="color: var(--border-ornate);">&rarr;</div>
                        <div style="text-align: center; padding: 0.5rem;">
                            <div style="background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem 0.75rem; margin-bottom: 0.25rem;">Stored</div>
                            <div style="color: var(--text-muted);">In pool</div>
                        </div>
                        <div style="color: var(--border-ornate);">&rarr;</div>
                        <div style="text-align: center; padding: 0.5rem;">
                            <div style="background: var(--bg-card); border: 1px solid var(--accent-error); border-radius: 4px; padding: 0.5rem 0.75rem; margin-bottom: 0.25rem;">Released</div>
                            <div style="color: var(--text-muted);">Recycled</div>
                        </div>
                    </div>
                    <p style="font-size: 0.85rem; color: var(--text-secondary);">
                        Pool-based recycling is more efficient than creating/destroying entities repeatedly.
                    </p>
                `,
                tip: 'Use acquire/release pattern for frequently spawned entities like projectiles or particles.'
            },
            {
                id: 'complete',
                title: 'Entity Management Complete!',
                description: `
                    <p style="color: var(--accent-success); font-weight: 600;">You can now manage entities like a pro!</p>
                    <p style="margin-top: 0.75rem;">Key takeaways:</p>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.9rem;">
                        <li><strong>Preview</strong> for testing, <strong>Entity Manager</strong> for real tracking</li>
                        <li><strong>Pools</strong> organize and optimize entity management</li>
                        <li><strong>Rules</strong> auto-assign entities to the right pools</li>
                        <li><strong>Promote</strong> interesting test entities for safekeeping</li>
                    </ul>
                `,
                linkedTutorials: [
                    {
                        moduleId: 'presets',
                        label: 'Learn about Spawn Presets',
                        returnLabel: 'Return to Entity Management'
                    }
                ]
            }
        ],

        onComplete: () => {
            if (typeof showToast === 'function') {
                showToast('Entity Management tutorial completed!', 'success');
            }
        }
    });
})();

</script>
    <script>
// ============================================================================
// TUTORIAL: PRESETS
// ============================================================================

/**
 * Presets Tutorial
 * Teaches users about spawn presets - predefined entity configurations
 */

(function() {
    if (typeof TutorialSystem === 'undefined') {
        console.warn('TutorialSystem not loaded, presets tutorial cannot register');
        return;
    }

    TutorialSystem.register({
        id: 'presets',
        name: 'Spawn Presets Tutorial',
        displayStyle: 'overlay',

        steps: [
            {
                id: 'intro',
                title: 'What Are Spawn Presets?',
                description: `
                    <p><strong>Presets</strong> are predefined entity configurations that make spawning specific entity types easy and consistent.</p>
                    <p style="margin-top: 0.75rem;">Instead of random generation, presets let you define:</p>
                    <div style="margin-top: 0.75rem; display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem;">
                        <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-layer);">
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">"Goblin"</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Low HP, high speed, aggressive behavior</div>
                        </div>
                        <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; border-left: 3px solid var(--node-compound);">
                            <div style="font-weight: 600; margin-bottom: 0.25rem;">"Dragon Boss"</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">High stats, fire resistance, tactical AI</div>
                        </div>
                    </div>
                `,
                tip: 'Think of presets as "character templates" - they ensure specific entity types are consistent.',
                examples: [
                    { icon: '&#9876;', game: 'RPG', desc: 'Presets for each monster: "goblin", "orc_warrior", "skeleton_archer"' },
                    { icon: '&#127866;', game: 'Tavern Sim', desc: 'Presets for patron types: "regular", "noble", "troublemaker"' },
                    { icon: '&#127183;', game: 'Card Game', desc: 'Presets for card rarities: "common", "rare", "legendary"' }
                ]
            },
            {
                id: 'anatomy',
                title: 'Anatomy of a Preset',
                description: `
                    <p>A preset can specify any combination of:</p>
                    <table style="width: 100%; font-size: 0.85rem; margin-top: 0.75rem; border-collapse: collapse;">
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 0.5rem; color: var(--accent-secondary); font-weight: 500;">Fixed Attributes</td>
                            <td style="padding: 0.5rem;">Exact values (strength: 15) instead of random range</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 0.5rem; color: var(--accent-secondary); font-weight: 500;">Forced Traits</td>
                            <td style="padding: 0.5rem;">Always have these traits, skip random selection</td>
                        </tr>
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 0.5rem; color: var(--accent-secondary); font-weight: 500;">Variable Overrides</td>
                            <td style="padding: 0.5rem;">Start with specific values (health: 50)</td>
                        </tr>
                        <tr>
                            <td style="padding: 0.5rem; color: var(--accent-secondary); font-weight: 500;">Tags</td>
                            <td style="padding: 0.5rem;">Metadata for filtering ("boss", "undead", "flying")</td>
                        </tr>
                    </table>
                    <p style="margin-top: 0.75rem; color: var(--text-muted); font-size: 0.85rem;">
                        Anything not specified falls back to normal random generation.
                    </p>
                `,
                tip: 'You can partially define a preset - fix what matters, randomize the rest!'
            },
            {
                id: 'creating',
                title: 'Creating a Preset',
                description: `
                    <p>There are two ways to create presets:</p>

                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem; margin-bottom: 0.75rem;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Method 1: From Scratch</div>
                        <ol style="padding-left: 1.25rem; margin: 0; font-size: 0.85rem;">
                            <li>Go to <strong>Entities</strong> tab</li>
                            <li>Click <strong>Add Preset</strong></li>
                            <li>Fill in name, attributes, forced traits</li>
                            <li>Save</li>
                        </ol>
                    </div>

                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px;">
                        <div style="font-weight: 600; margin-bottom: 0.5rem;">Method 2: From Entity</div>
                        <ol style="padding-left: 1.25rem; margin: 0; font-size: 0.85rem;">
                            <li>Spawn an entity in Preview</li>
                            <li>Tweak it until it's perfect</li>
                            <li>Click <strong>Save as Preset</strong></li>
                            <li>Current state becomes the preset!</li>
                        </ol>
                    </div>
                `,
                tip: 'Method 2 is great for discovering interesting combinations through experimentation.'
            },
            {
                id: 'groups',
                title: 'Preset Groups',
                description: `
                    <p><strong>Groups</strong> organize presets into categories:</p>
                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem; font-family: monospace; font-size: 0.8rem;">
                        <div style="color: var(--accent-secondary);">Enemies/</div>
                        <div style="padding-left: 1rem;">goblin, orc, skeleton, dragon_boss</div>
                        <div style="color: var(--accent-secondary); margin-top: 0.5rem;">Allies/</div>
                        <div style="padding-left: 1rem;">warrior, mage, healer, rogue</div>
                        <div style="color: var(--accent-secondary); margin-top: 0.5rem;">NPCs/</div>
                        <div style="padding-left: 1rem;">shopkeeper, guard, villager</div>
                    </div>
                    <p style="margin-top: 0.75rem;">Groups help you:</p>
                    <ul style="padding-left: 1.5rem; font-size: 0.9rem;">
                        <li>Keep presets organized</li>
                        <li>Filter in the editor UI</li>
                        <li>Spawn random from group in code</li>
                    </ul>
                `,
                tip: 'Groups also help with pool assignment rules - "preset in enemies/*" goes to enemies pool.'
            },
            {
                id: 'using',
                title: 'Using Presets in Your Game',
                description: `
                    <p>In your game code, spawn by preset ID:</p>
                    <div style="background: var(--bg-card); padding: 0.75rem; border-radius: 6px; margin-top: 0.75rem; font-family: monospace; font-size: 0.8rem;">
                        <div style="color: var(--accent-secondary);">// Spawn specific preset</div>
                        <div>const goblin = engine.spawn('goblin');</div>
                        <div style="margin-top: 0.75rem; color: var(--accent-secondary);">// Spawn random from group</div>
                        <div>const enemy = engine.spawnFromGroup('enemies');</div>
                        <div style="margin-top: 0.75rem; color: var(--accent-secondary);">// Spawn with overrides</div>
                        <div>const boss = engine.spawn('dragon', {</div>
                        <div style="padding-left: 1rem;">attributes: { maxHealth: 500 },</div>
                        <div style="padding-left: 1rem;">name: 'Alduin the Destroyer'</div>
                        <div>});</div>
                    </div>
                `,
                tip: 'Override parameters merge with preset defaults - perfect for boss variants!'
            },
            {
                id: 'complete',
                title: 'Presets Complete!',
                description: `
                    <p style="color: var(--accent-success); font-weight: 600;">You've mastered spawn presets!</p>
                    <p style="margin-top: 0.75rem;">The complete workflow:</p>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 1rem 0; font-size: 0.8rem;">
                        <div style="text-align: center; flex: 1;">
                            <div style="background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; margin-bottom: 0.25rem;">Design</div>
                            <div style="color: var(--text-muted);">Config nodes</div>
                        </div>
                        <div style="color: var(--border-ornate);">&rarr;</div>
                        <div style="text-align: center; flex: 1;">
                            <div style="background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; margin-bottom: 0.25rem;">Test</div>
                            <div style="color: var(--text-muted);">Preview tab</div>
                        </div>
                        <div style="color: var(--border-ornate);">&rarr;</div>
                        <div style="text-align: center; flex: 1;">
                            <div style="background: var(--bg-card); border: 1px solid var(--accent-primary); border-radius: 4px; padding: 0.5rem; margin-bottom: 0.25rem;">Save</div>
                            <div style="color: var(--text-muted);">Presets</div>
                        </div>
                        <div style="color: var(--border-ornate);">&rarr;</div>
                        <div style="text-align: center; flex: 1;">
                            <div style="background: var(--bg-card); border: 1px solid var(--accent-success); border-radius: 4px; padding: 0.5rem; margin-bottom: 0.25rem;">Use</div>
                            <div style="color: var(--text-muted);">In game</div>
                        </div>
                    </div>
                    <p style="font-size: 0.9rem; color: var(--text-secondary);">
                        Your config + presets can be exported as JSON and loaded into any game engine!
                    </p>
                `
            }
        ],

        onComplete: () => {
            if (typeof showToast === 'function') {
                showToast('Presets tutorial completed!', 'success');
            }
        }
    });
})();

</script>
    <script>
        // ========================================
        // STATE
        // ========================================
        let config = {
            id: 'new-config',
            name: 'New Config',
            version: '3.0',
            tier: 'free',
            nodes: [],
            relationships: [],
            presetGroups: [],
            presets: [],
            engineConfig: {
                tickRate: 1000,
                maxSpawns: null
            }
        };

        let engine = new SpawnEngine(config);
        // TIER LIMITS
        const TIER_LIMITS = {"maxNodes":15,"maxRelationships":20,"maxEntities":5};
        const TIER_TOAST_DURATION = 4000; // 4 seconds â€” long enough to read

        function checkNodeLimit() {
            if (!TIER_LIMITS) return { allowed: true };
            if (config.nodes.length >= TIER_LIMITS.maxNodes) {
                return { allowed: false, reason: `Free tier limited to ${TIER_LIMITS.maxNodes} nodes. Upgrade for unlimited!` };
            }
            return { allowed: true };
        }

        function checkRelationshipLimit() {
            if (!TIER_LIMITS) return { allowed: true };
            if (config.relationships.length >= TIER_LIMITS.maxRelationships) {
                return { allowed: false, reason: `Free tier limited to ${TIER_LIMITS.maxRelationships} connections. Upgrade for unlimited!` };
            }
            return { allowed: true };
        }

        function checkEntityLimit() {
            if (!TIER_LIMITS || !TIER_LIMITS.maxEntities) return { allowed: true };
            if (engine.getAllEntities().length >= TIER_LIMITS.maxEntities) {
                return { allowed: false, reason: `Free tier limited to ${TIER_LIMITS.maxEntities} entities. Upgrade for unlimited!` };
            }
            return { allowed: true };
        }
        
        let selectedNodeId = null;
        let currentView = 'overview';
        let overviewMode = 'graph'; // 'tree' or 'graph' toggle within Overview tab
        let newNodeType = 'attribute';
        let showJumpInMessage = false; // Show "Add your first node" message after blank config + Jump In

        // Tutorial state now managed by tutorial.js
        // Initialize tutorial on load
        initTutorial();

// PRESETS_START
        // Bundled presets
        const PRESETS = {
                "blank": {
                        "id": "blank-config",
                        "name": "Blank Config",
                        "version": "3.0",
                        "tier": "free",
                        "nodes": [],
                        "relationships": [],
                        "engineConfig": {
                                "tickRate": 1000,
                                "maxSpawns": null
                        }
                },
                "tavern-basic": {
                        "id": "tavern-basic",
                        "name": "Tavern Patron (Basic)",
                        "version": "3.1",
                        "tier": "free",
                        "description": "Simplified tavern patron system. Great for learning the engine basics.",
                        "nodes": [
                                {
                                        "id": "attr_patience",
                                        "name": "Patience",
                                        "description": "How long they'll wait before getting upset",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        3,
                                                        8
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_generosity",
                                        "name": "Generosity",
                                        "description": "How much they tip and spend",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        2,
                                                        9
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "var_hunger",
                                        "name": "Hunger",
                                        "description": "Depletes over time, affects mood",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 100,
                                                "initial": 80,
                                                "baseRate": -5,
                                                "changeMode": "timed",
                                                "direction": "deplete"
                                        }
                                },
                                {
                                        "id": "var_boredom",
                                        "name": "Boredom",
                                        "description": "Increases over time if not entertained",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 100,
                                                "initial": 20,
                                                "baseRate": 3,
                                                "changeMode": "timed",
                                                "direction": "accumulate"
                                        }
                                },
                                {
                                        "id": "layer_personality",
                                        "name": "Personality",
                                        "description": "Core personality traits",
                                        "type": "layer",
                                        "config": {
                                                "order": 1,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 2,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "traitIds": [
                                                        "item_optimist",
                                                        "item_pessimist",
                                                        "item_hothead"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_optimist",
                                        "name": "Optimist",
                                        "description": "Sees the bright side",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_personality",
                                                "selection": {
                                                        "baseWeight": 30
                                                },
                                                "incompatibleWith": [
                                                        "item_pessimist"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_pessimist",
                                        "name": "Pessimist",
                                        "description": "Expects the worst",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_personality",
                                                "selection": {
                                                        "baseWeight": 25
                                                },
                                                "incompatibleWith": [
                                                        "item_optimist"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_hothead",
                                        "name": "Hothead",
                                        "description": "Quick to anger",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_personality",
                                                "selection": {
                                                        "baseWeight": 20
                                                }
                                        }
                                },
                                {
                                        "id": "layer_mood",
                                        "name": "Current Mood",
                                        "description": "How they're feeling right now",
                                        "type": "layer",
                                        "config": {
                                                "order": 2,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "traitIds": [
                                                        "item_cheerful",
                                                        "item_grumpy"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_cheerful",
                                        "name": "Cheerful",
                                        "description": "In a good mood",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_mood",
                                                "selection": {
                                                        "baseWeight": 40
                                                },
                                                "incompatibleWith": [
                                                        "item_grumpy"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_grumpy",
                                        "name": "Grumpy",
                                        "description": "In a bad mood",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_mood",
                                                "selection": {
                                                        "baseWeight": 25
                                                },
                                                "incompatibleWith": [
                                                        "item_cheerful"
                                                ]
                                        }
                                },
                                {
                                        "id": "mod_hungry",
                                        "name": "Hungry",
                                        "description": "Applied when hunger is low",
                                        "type": "modifier",
                                        "config": {
                                                "durationType": "permanent",
                                                "stacking": "none"
                                        }
                                },
                                {
                                        "id": "comp_hangry",
                                        "name": "Hangry",
                                        "description": "Hungry + Grumpy = trouble",
                                        "type": "compound",
                                        "config": {
                                                "requires": [
                                                        {
                                                                "modifier": "mod_hungry"
                                                        },
                                                        {
                                                                "item": "item_grumpy"
                                                        }
                                                ],
                                                "requirementLogic": "all"
                                        }
                                }
                        ],
                        "relationships": [
                                {
                                        "id": "rel_patience_boredom",
                                        "sourceId": "attr_patience",
                                        "targetId": "var_boredom",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 0.85,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_patience"
                                        }
                                },
                                {
                                        "id": "rel_optimist_cheerful",
                                        "sourceId": "item_optimist",
                                        "targetId": "item_cheerful",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 25
                                        }
                                },
                                {
                                        "id": "rel_pessimist_grumpy",
                                        "sourceId": "item_pessimist",
                                        "targetId": "item_grumpy",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 25
                                        }
                                },
                                {
                                        "id": "rel_hothead_grumpy",
                                        "sourceId": "item_hothead",
                                        "targetId": "item_grumpy",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 15
                                        }
                                },
                                {
                                        "id": "rel_hungry_grumpy",
                                        "sourceId": "mod_hungry",
                                        "targetId": "item_grumpy",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 30
                                        }
                                }
                        ],
                        "engineConfig": {
                                "tickRate": 1000,
                                "maxEntities": null
                        }
                },
                "brawlifier-basic": {
                        "id": "brawlifier-basic",
                        "name": "SlopMopBob's Brawlifier (Basic)",
                        "version": "3.0",
                        "description": "Basic RPG combat entities. Includes types, behaviors, and core stats. Upgrade for full system with resistances, weaknesses, modifiers, and emergent compounds.",
                        "nodes": [
                                {
                                        "id": "attr_attack",
                                        "name": "Attack",
                                        "description": "Base attack power for damage dealing",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 20,
                                                "defaultRange": [
                                                        4,
                                                        14
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_defense",
                                        "name": "Defense",
                                        "description": "Base defense for damage reduction",
                                        "type": "attribute",
                                        "config": {
                                                "min": 0,
                                                "max": 20,
                                                "defaultRange": [
                                                        2,
                                                        12
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_max_health",
                                        "name": "Max Health",
                                        "description": "Maximum hit points",
                                        "type": "attribute",
                                        "config": {
                                                "min": 10,
                                                "max": 200,
                                                "defaultRange": [
                                                        30,
                                                        120
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "var_health",
                                        "name": "Health",
                                        "description": "Current HP (0 = defeated)",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 200,
                                                "initial": 100,
                                                "baseRate": 0,
                                                "changeMode": "manual",
                                                "direction": "none"
                                        }
                                },
                                {
                                        "id": "var_stamina",
                                        "name": "Stamina",
                                        "description": "Current stamina, depletes on actions",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 100,
                                                "initial": 100,
                                                "baseRate": 5,
                                                "changeMode": "timed",
                                                "direction": "accumulate"
                                        }
                                },
                                {
                                        "id": "layer_type",
                                        "name": "Entity Type",
                                        "description": "Primary classification of the combatant",
                                        "type": "layer",
                                        "config": {
                                                "order": 1,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_humanoid",
                                                        "item_beast",
                                                        "item_undead",
                                                        "item_elemental"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_humanoid",
                                        "name": "Humanoid",
                                        "description": "Humans, elves, orcs, goblins - bipedal intelligent beings",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_type",
                                                "selection": {
                                                        "baseWeight": 40
                                                }
                                        }
                                },
                                {
                                        "id": "item_beast",
                                        "name": "Beast",
                                        "description": "Wolves, bears, spiders - natural creatures",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_type",
                                                "selection": {
                                                        "baseWeight": 30
                                                }
                                        }
                                },
                                {
                                        "id": "item_undead",
                                        "name": "Undead",
                                        "description": "Skeletons, zombies, ghosts - the risen dead",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_type",
                                                "selection": {
                                                        "baseWeight": 20
                                                }
                                        }
                                },
                                {
                                        "id": "item_elemental",
                                        "name": "Elemental",
                                        "description": "Fire, water, earth, air - embodied elements",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_type",
                                                "selection": {
                                                        "baseWeight": 10
                                                }
                                        }
                                },
                                {
                                        "id": "layer_behavior",
                                        "name": "Behavior",
                                        "description": "AI/action priority pattern",
                                        "type": "layer",
                                        "config": {
                                                "order": 2,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_aggressive",
                                                        "item_defensive",
                                                        "item_tactical"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_aggressive",
                                        "name": "Aggressive",
                                        "description": "Attacks relentlessly, prioritizes damage",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_behavior",
                                                "selection": {
                                                        "baseWeight": 40
                                                },
                                                "incompatibleWith": [
                                                        "item_defensive"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_defensive",
                                        "name": "Defensive",
                                        "description": "Prioritizes survival and counterattacks",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_behavior",
                                                "selection": {
                                                        "baseWeight": 30
                                                },
                                                "incompatibleWith": [
                                                        "item_aggressive"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_tactical",
                                        "name": "Tactical",
                                        "description": "Uses abilities strategically, targets weak points",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_behavior",
                                                "selection": {
                                                        "baseWeight": 30
                                                }
                                        }
                                }
                        ],
                        "relationships": [
                                {
                                        "id": "rel_maxhp_health",
                                        "sourceId": "attr_max_health",
                                        "targetId": "var_health",
                                        "type": "value_modifier",
                                        "config": {
                                                "operation": "set",
                                                "value": 1,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_max_health",
                                                "applyAt": "spawn"
                                        }
                                },
                                {
                                        "id": "rel_attack_aggressive",
                                        "sourceId": "attr_attack",
                                        "targetId": "item_aggressive",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 2,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_attack"
                                        }
                                },
                                {
                                        "id": "rel_defense_defensive",
                                        "sourceId": "attr_defense",
                                        "targetId": "item_defensive",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_defense"
                                        }
                                },
                                {
                                        "id": "rel_humanoid_tactical",
                                        "sourceId": "item_humanoid",
                                        "targetId": "item_tactical",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 20
                                        }
                                },
                                {
                                        "id": "rel_beast_aggressive",
                                        "sourceId": "item_beast",
                                        "targetId": "item_aggressive",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 25
                                        }
                                },
                                {
                                        "id": "rel_undead_aggressive",
                                        "sourceId": "item_undead",
                                        "targetId": "item_aggressive",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 20
                                        }
                                },
                                {
                                        "id": "rel_aggressive_stamina",
                                        "sourceId": "item_aggressive",
                                        "targetId": "var_stamina",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 0.7
                                        }
                                },
                                {
                                        "id": "rel_defensive_stamina",
                                        "sourceId": "item_defensive",
                                        "targetId": "var_stamina",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 1.3
                                        }
                                }
                        ],
                        "engineConfig": {
                                "tickRate": 1000,
                                "maxSpawns": null
                        }
                },
                "card-basic": {
                        "id": "card-basic",
                        "name": "Card Game (Basic)",
                        "version": "3.0",
                        "description": "Basic cards for a deckbuilder. Includes types, rarities, and core stats. Upgrade for full system with elements, keywords, modifiers, and emergent compounds.",
                        "nodes": [
                                {
                                        "id": "attr_base_power",
                                        "name": "Base Power",
                                        "description": "Attack strength before modifiers",
                                        "type": "attribute",
                                        "config": {
                                                "min": 0,
                                                "max": 10,
                                                "defaultRange": [
                                                        1,
                                                        6
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_base_defense",
                                        "name": "Base Defense",
                                        "description": "Defense before modifiers",
                                        "type": "attribute",
                                        "config": {
                                                "min": 0,
                                                "max": 10,
                                                "defaultRange": [
                                                        0,
                                                        5
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_mana_cost",
                                        "name": "Mana Cost",
                                        "description": "Cost to play this card",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        1,
                                                        5
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "var_current_power",
                                        "name": "Current Power",
                                        "description": "Power after in-game buffs/debuffs",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 50,
                                                "initial": 0,
                                                "baseRate": 0,
                                                "changeMode": "manual",
                                                "direction": "none"
                                        }
                                },
                                {
                                        "id": "var_current_defense",
                                        "name": "Current Defense",
                                        "description": "Defense after in-game buffs/debuffs",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 50,
                                                "initial": 0,
                                                "baseRate": 0,
                                                "changeMode": "manual",
                                                "direction": "none"
                                        }
                                },
                                {
                                        "id": "layer_card_type",
                                        "name": "Card Type",
                                        "description": "The category of card",
                                        "type": "layer",
                                        "config": {
                                                "order": 1,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_creature",
                                                        "item_spell"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_creature",
                                        "name": "Creature",
                                        "description": "Stays on field, can attack and block",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_card_type",
                                                "selection": {
                                                        "baseWeight": 60
                                                }
                                        }
                                },
                                {
                                        "id": "item_spell",
                                        "name": "Spell",
                                        "description": "Instant effect, then discarded",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_card_type",
                                                "selection": {
                                                        "baseWeight": 40
                                                }
                                        }
                                },
                                {
                                        "id": "layer_rarity",
                                        "name": "Rarity",
                                        "description": "How rare/powerful this card is",
                                        "type": "layer",
                                        "config": {
                                                "order": 2,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_common",
                                                        "item_uncommon",
                                                        "item_rare",
                                                        "item_legendary"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_common",
                                        "name": "Common",
                                        "description": "Basic card, plentiful",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_rarity",
                                                "selection": {
                                                        "baseWeight": 50
                                                }
                                        }
                                },
                                {
                                        "id": "item_uncommon",
                                        "name": "Uncommon",
                                        "description": "Better than common, some synergy",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_rarity",
                                                "selection": {
                                                        "baseWeight": 30
                                                }
                                        }
                                },
                                {
                                        "id": "item_rare",
                                        "name": "Rare",
                                        "description": "Powerful, build-around potential",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_rarity",
                                                "selection": {
                                                        "baseWeight": 15
                                                }
                                        }
                                },
                                {
                                        "id": "item_legendary",
                                        "name": "Legendary",
                                        "description": "Unique, game-changing effect",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_rarity",
                                                "selection": {
                                                        "baseWeight": 5
                                                }
                                        }
                                }
                        ],
                        "relationships": [
                                {
                                        "id": "rel_power_creature",
                                        "sourceId": "attr_base_power",
                                        "targetId": "item_creature",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_base_power"
                                        }
                                },
                                {
                                        "id": "rel_power_rare",
                                        "sourceId": "attr_base_power",
                                        "targetId": "item_rare",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 2,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_base_power"
                                        }
                                },
                                {
                                        "id": "rel_power_legendary",
                                        "sourceId": "attr_base_power",
                                        "targetId": "item_legendary",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_base_power"
                                        }
                                },
                                {
                                        "id": "rel_defense_uncommon",
                                        "sourceId": "attr_base_defense",
                                        "targetId": "item_uncommon",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 2,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_base_defense"
                                        }
                                },
                                {
                                        "id": "rel_cost_spell",
                                        "sourceId": "attr_mana_cost",
                                        "targetId": "item_spell",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": -3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_mana_cost"
                                        }
                                },
                                {
                                        "id": "rel_cost_rare",
                                        "sourceId": "attr_mana_cost",
                                        "targetId": "item_rare",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_mana_cost"
                                        }
                                },
                                {
                                        "id": "rel_creature_common",
                                        "sourceId": "item_creature",
                                        "targetId": "item_common",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 15
                                        }
                                },
                                {
                                        "id": "rel_spell_uncommon",
                                        "sourceId": "item_spell",
                                        "targetId": "item_uncommon",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 10
                                        }
                                }
                        ],
                        "engineConfig": {
                                "tickRate": 1000,
                                "maxSpawns": null
                        }
                },
                "city-basic": {
                        "id": "city-basic",
                        "name": "City Citizen (Basic)",
                        "version": "3.0",
                        "description": "Basic citizens for a city builder. Includes professions, personality, and core needs. Upgrade for full system with stress, loyalty, experience, and emergent compounds.",
                        "nodes": [
                                {
                                        "id": "attr_skill",
                                        "name": "Skill",
                                        "description": "Natural aptitude for work",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        2,
                                                        7
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_social",
                                        "name": "Social",
                                        "description": "Ability to work with others",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        2,
                                                        8
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_constitution",
                                        "name": "Constitution",
                                        "description": "Physical resilience",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        3,
                                                        9
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "var_energy",
                                        "name": "Energy",
                                        "description": "Depletes during work, restores with rest",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 100,
                                                "initial": 100,
                                                "baseRate": -3,
                                                "changeMode": "timed",
                                                "direction": "deplete"
                                        }
                                },
                                {
                                        "id": "var_happiness",
                                        "name": "Happiness",
                                        "description": "General contentment, affected by events",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 100,
                                                "initial": 70,
                                                "baseRate": -1,
                                                "changeMode": "timed",
                                                "direction": "deplete"
                                        }
                                },
                                {
                                        "id": "layer_profession",
                                        "name": "Profession",
                                        "description": "Primary job role",
                                        "type": "layer",
                                        "config": {
                                                "order": 1,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_farmer",
                                                        "item_builder",
                                                        "item_guard",
                                                        "item_merchant"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_farmer",
                                        "name": "Farmer",
                                        "description": "Grows food, tends livestock",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_profession",
                                                "selection": {
                                                        "baseWeight": 30
                                                }
                                        }
                                },
                                {
                                        "id": "item_builder",
                                        "name": "Builder",
                                        "description": "Constructs and repairs buildings",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_profession",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                },
                                {
                                        "id": "item_guard",
                                        "name": "Guard",
                                        "description": "Protects the settlement",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_profession",
                                                "selection": {
                                                        "baseWeight": 20
                                                }
                                        }
                                },
                                {
                                        "id": "item_merchant",
                                        "name": "Merchant",
                                        "description": "Trades goods, manages economy",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_profession",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                },
                                {
                                        "id": "layer_personality",
                                        "name": "Personality",
                                        "description": "Character traits",
                                        "type": "layer",
                                        "config": {
                                                "order": 2,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_hardworking",
                                                        "item_lazy",
                                                        "item_cheerful",
                                                        "item_pessimist"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_hardworking",
                                        "name": "Hardworking",
                                        "description": "Works faster but tires quickly",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_personality",
                                                "selection": {
                                                        "baseWeight": 30
                                                },
                                                "incompatibleWith": [
                                                        "item_lazy"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_lazy",
                                        "name": "Lazy",
                                        "description": "Works slowly but conserves energy",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_personality",
                                                "selection": {
                                                        "baseWeight": 20
                                                },
                                                "incompatibleWith": [
                                                        "item_hardworking"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_cheerful",
                                        "name": "Cheerful",
                                        "description": "Stays happier longer",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_personality",
                                                "selection": {
                                                        "baseWeight": 25
                                                },
                                                "incompatibleWith": [
                                                        "item_pessimist"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_pessimist",
                                        "name": "Pessimist",
                                        "description": "Loses happiness faster",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_personality",
                                                "selection": {
                                                        "baseWeight": 25
                                                },
                                                "incompatibleWith": [
                                                        "item_cheerful"
                                                ]
                                        }
                                }
                        ],
                        "relationships": [
                                {
                                        "id": "rel_skill_merchant",
                                        "sourceId": "attr_skill",
                                        "targetId": "item_merchant",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_skill"
                                        }
                                },
                                {
                                        "id": "rel_constitution_guard",
                                        "sourceId": "attr_constitution",
                                        "targetId": "item_guard",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_constitution"
                                        }
                                },
                                {
                                        "id": "rel_constitution_builder",
                                        "sourceId": "attr_constitution",
                                        "targetId": "item_builder",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 2,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_constitution"
                                        }
                                },
                                {
                                        "id": "rel_social_merchant",
                                        "sourceId": "attr_social",
                                        "targetId": "item_merchant",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 4,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_social"
                                        }
                                },
                                {
                                        "id": "rel_hardworking_energy",
                                        "sourceId": "item_hardworking",
                                        "targetId": "var_energy",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 1.5
                                        }
                                },
                                {
                                        "id": "rel_lazy_energy",
                                        "sourceId": "item_lazy",
                                        "targetId": "var_energy",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 0.5
                                        }
                                },
                                {
                                        "id": "rel_cheerful_happiness",
                                        "sourceId": "item_cheerful",
                                        "targetId": "var_happiness",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 0.6
                                        }
                                },
                                {
                                        "id": "rel_pessimist_happiness",
                                        "sourceId": "item_pessimist",
                                        "targetId": "var_happiness",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 1.5
                                        }
                                },
                                {
                                        "id": "rel_farmer_energy",
                                        "sourceId": "item_farmer",
                                        "targetId": "var_energy",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 1.2
                                        }
                                },
                                {
                                        "id": "rel_builder_energy",
                                        "sourceId": "item_builder",
                                        "targetId": "var_energy",
                                        "type": "rate_modifier",
                                        "config": {
                                                "operation": "multiply",
                                                "value": 1.3
                                        }
                                }
                        ],
                        "engineConfig": {
                                "tickRate": 1000,
                                "maxSpawns": null
                        }
                },
                "relationship-basic": {
                        "id": "relationship-basic",
                        "name": "Relationship Sim (Basic)",
                        "version": "3.0",
                        "description": "Basic characters for a dating sim. Includes archetypes, interests, and core relationship stats. Upgrade for full system with tension, compounds like Crushing and Heartbroken.",
                        "nodes": [
                                {
                                        "id": "attr_charm",
                                        "name": "Charm",
                                        "description": "Natural attractiveness and charisma",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        3,
                                                        9
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "attr_kindness",
                                        "name": "Kindness",
                                        "description": "Compassion and empathy",
                                        "type": "attribute",
                                        "config": {
                                                "min": 1,
                                                "max": 10,
                                                "defaultRange": [
                                                        3,
                                                        10
                                                ],
                                                "precision": 0
                                        }
                                },
                                {
                                        "id": "var_affection",
                                        "name": "Affection",
                                        "description": "Romantic interest level toward player",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 100,
                                                "initial": 20,
                                                "baseRate": 0,
                                                "changeMode": "manual",
                                                "direction": "none"
                                        }
                                },
                                {
                                        "id": "var_trust",
                                        "name": "Trust",
                                        "description": "How much they trust the player",
                                        "type": "variable",
                                        "config": {
                                                "min": 0,
                                                "max": 100,
                                                "initial": 30,
                                                "baseRate": 0,
                                                "changeMode": "manual",
                                                "direction": "none"
                                        }
                                },
                                {
                                        "id": "layer_archetype",
                                        "name": "Archetype",
                                        "description": "Core personality archetype",
                                        "type": "layer",
                                        "config": {
                                                "order": 1,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 1,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_shy",
                                                        "item_outgoing",
                                                        "item_mysterious",
                                                        "item_sweethart"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_shy",
                                        "name": "Shy",
                                        "description": "Quiet, easily flustered, slow to open up",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_archetype",
                                                "selection": {
                                                        "baseWeight": 25
                                                },
                                                "incompatibleWith": [
                                                        "item_outgoing"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_outgoing",
                                        "name": "Outgoing",
                                        "description": "Social, energetic, easy to talk to",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_archetype",
                                                "selection": {
                                                        "baseWeight": 25
                                                },
                                                "incompatibleWith": [
                                                        "item_shy"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_mysterious",
                                        "name": "Mysterious",
                                        "description": "Enigmatic, hard to read, intriguing",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_archetype",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                },
                                {
                                        "id": "item_sweethart",
                                        "name": "Sweetheart",
                                        "description": "Genuinely kind, supportive, warm",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_archetype",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                },
                                {
                                        "id": "layer_interests",
                                        "name": "Interests",
                                        "description": "Hobbies and passions",
                                        "type": "layer",
                                        "config": {
                                                "order": 2,
                                                "selection": {
                                                        "mode": "weighted",
                                                        "maxItems": 2,
                                                        "initialRolls": 1
                                                },
                                                "timing": {
                                                        "rollAt": "spawn"
                                                },
                                                "itemIds": [
                                                        "item_art",
                                                        "item_music",
                                                        "item_books",
                                                        "item_gaming"
                                                ]
                                        }
                                },
                                {
                                        "id": "item_art",
                                        "name": "Art",
                                        "description": "Painting, drawing, visual arts",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_interests",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                },
                                {
                                        "id": "item_music",
                                        "name": "Music",
                                        "description": "Playing instruments, concerts",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_interests",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                },
                                {
                                        "id": "item_books",
                                        "name": "Books",
                                        "description": "Reading and literature",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_interests",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                },
                                {
                                        "id": "item_gaming",
                                        "name": "Gaming",
                                        "description": "Video games and board games",
                                        "type": "item",
                                        "config": {
                                                "layerId": "layer_interests",
                                                "selection": {
                                                        "baseWeight": 25
                                                }
                                        }
                                }
                        ],
                        "relationships": [
                                {
                                        "id": "rel_charm_outgoing",
                                        "sourceId": "attr_charm",
                                        "targetId": "item_outgoing",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_charm"
                                        }
                                },
                                {
                                        "id": "rel_charm_sweethart",
                                        "sourceId": "attr_charm",
                                        "targetId": "item_sweethart",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 2,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_charm"
                                        }
                                },
                                {
                                        "id": "rel_charm_affection",
                                        "sourceId": "attr_charm",
                                        "targetId": "var_affection",
                                        "type": "value_modifier",
                                        "config": {
                                                "operation": "add",
                                                "value": 2,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_charm",
                                                "applyAt": "spawn"
                                        }
                                },
                                {
                                        "id": "rel_kindness_sweethart",
                                        "sourceId": "attr_kindness",
                                        "targetId": "item_sweethart",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 4,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_kindness"
                                        }
                                },
                                {
                                        "id": "rel_kindness_trust",
                                        "sourceId": "attr_kindness",
                                        "targetId": "var_trust",
                                        "type": "value_modifier",
                                        "config": {
                                                "operation": "add",
                                                "value": 3,
                                                "scaling": "perPoint",
                                                "perPointSource": "attr_kindness",
                                                "applyAt": "spawn"
                                        }
                                },
                                {
                                        "id": "rel_shy_books",
                                        "sourceId": "item_shy",
                                        "targetId": "item_books",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 20
                                        }
                                },
                                {
                                        "id": "rel_shy_art",
                                        "sourceId": "item_shy",
                                        "targetId": "item_art",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 15
                                        }
                                },
                                {
                                        "id": "rel_outgoing_music",
                                        "sourceId": "item_outgoing",
                                        "targetId": "item_music",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 20
                                        }
                                },
                                {
                                        "id": "rel_mysterious_art",
                                        "sourceId": "item_mysterious",
                                        "targetId": "item_art",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 15
                                        }
                                },
                                {
                                        "id": "rel_sweethart_books",
                                        "sourceId": "item_sweethart",
                                        "targetId": "item_books",
                                        "type": "weight_influence",
                                        "config": {
                                                "operation": "add",
                                                "value": 15
                                        }
                                }
                        ],
                        "engineConfig": {
                                "tickRate": 1000,
                                "maxSpawns": null
                        }
                }
        };
        // PRESETS_END

        // Handler for the New System dropdown - routes to blank, wizard, or preset
        function loadPresetOrNew(value) {
            if (!value) return;

            document.getElementById('presetSelector').value = '';

            if (value === '__blank__') {
                // Create blank config
                if (config.nodes.length > 0) {
                    const choice = confirm('This will replace your current config with a blank one.\n\nClick OK to continue, or Cancel to go back.\n\n(Tip: Use Export to save your current work first)');
                    if (!choice) return;
                }
                createBlankConfig();
            } else {
                // Load a preset/template
                loadPreset(value);
            }
        }

        function createBlankConfig() {
            // Close wizard if open
            if (typeof closeWizard === 'function') {
                closeWizard();
            }

            // Clean up
            stopAutoTick();
            autoTickEnabled = false;
            previewEntities = [];
            selectedEntityId = null;

            // Create fresh config
            config = {
                id: 'new-config',
                name: 'New Config',
                version: '3.0',
                tier: 'free',
                nodes: [],
                relationships: [],
                presetGroups: [],
                presets: [],
                engineConfig: {
                    tickRate: 1000,
                    maxSpawns: null
                }
            };

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        async function loadPreset(presetName) {
            if (!presetName) return;

            // Confirm if there's existing work
            if (config.nodes.length > 0) {
                const choice = confirm('Loading a template will replace your current config.\n\nClick OK to continue, or Cancel to go back.\n\n(Tip: Use Export to save your current work first)');
                if (!choice) {
                    return;
                }
            }

            // Close wizard if open
            if (typeof closeWizard === 'function') {
                closeWizard();
            }

            // Clean up when switching configs
            stopAutoTick();
            autoTickEnabled = false;
            previewEntities = [];
            selectedEntityId = null;

            // Check embedded presets first
            if (PRESETS[presetName] && !PRESETS[presetName]._stub) {
                config = JSON.parse(JSON.stringify(PRESETS[presetName]));
                // Clear any cached positions so layout recalculates
                config.nodes.forEach(node => delete node.position);
                engine.loadConfig(config);
                saveToStorage();
                needsFitToView = true;
                render();
                // Auto-equalize weights for layers that have the setting enabled (default: on)
                autoEqualizeAllLayers();
                return;
            }

            // Try loading from file (works if running on a server)
            try {
                const response = await fetch(`presets/${presetName}.json`);
                if (!response.ok) throw new Error('Preset not found');
                const presetConfig = await response.json();
                config = presetConfig;
                // Clear any cached positions so layout recalculates
                config.nodes.forEach(node => delete node.position);
                engine.loadConfig(config);
                saveToStorage();
                needsFitToView = true;
                render();
                // Auto-equalize weights for layers that have the setting enabled (default: on)
                autoEqualizeAllLayers();
            } catch (e) {
                // CORS error likely - provide helpful message
                if (window.location.protocol === 'file:') {
                    alert(`Cannot load templates when opening directly as a file due to browser security (CORS).\n\nTo load templates:\n1. Run a local server: npx serve .\n2. Or: python -m http.server\n3. Then open http://localhost:3000\n\nAlternatively, use Import to load a config JSON file manually.`);
                } else {
                    alert(`Could not load template "${presetName}". Make sure the file exists in the presets/ folder.`);
                }
            }
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        function populatePresetDropdown() {
            const selector = document.getElementById('presetSelector');
            if (!selector) return;

            // Reset to base structure
            selector.innerHTML = `
                <option value="">Load Config...</option>
                <option value="__blank__">Blank Config</option>
                <option disabled>â”€â”€ Templates â”€â”€</option>
            `;

            // Add options from PRESETS object (dynamically populated by bundler)
            if (typeof PRESETS !== 'undefined') {
                for (const [key, preset] of Object.entries(PRESETS)) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = preset.name || key;
                    selector.appendChild(option);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            populatePresetDropdown();
            loadFromStorage();
            loadEntitiesFromStorage();
            render();
            // Only show tutorial if config has no nodes
            checkFirstTimeUser(() => config.nodes.length === 0);
        });

        function loadFromStorage() {
            const saved = localStorage.getItem('spawnEditorConfig');
            if (saved) {
                try {
                    config = JSON.parse(saved);
                    engine.loadConfig(config);
                    // Use normalized config from engine for consistency
                    config = engine.spawnManager.config;
                    // Auto-equalize weights for layers that have the setting enabled
                    autoEqualizeAllLayers();
                } catch (e) {
                    console.error('Failed to load saved config:', e);
                }
            }
        }

        // Track whether config has been exported since last change
        let configExportedSinceChange = true;
        let configHasNodes = false;

        function saveToStorage() {
            localStorage.setItem('spawnEditorConfig', JSON.stringify(config));
            // Mark as having unsaved changes (not exported)
            if (config.nodes.length > 0) {
                configExportedSinceChange = false;
                configHasNodes = true;
            }
        }

        // Warn user if leaving with unexported changes
        window.addEventListener('beforeunload', (e) => {
            if (!configExportedSinceChange && configHasNodes && config.nodes.length > 0) {
                e.preventDefault();
                e.returnValue = 'You have unexported changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        // ========================================
        // RENDERING
        // ========================================
        function render() {
            renderOverview();
            renderTree();
            renderMainView();
            renderDetailPanel();
            updateStatusBar();
            document.getElementById('configName').value = config.name;
            document.getElementById('configId').value = config.id;
            updateHeaderTitle();
        }

        let overviewCollapsed = false;
        let currentHealthIssues = []; // Store for click handling
        let treeSortMode = 'type'; // 'type' or 'spawnOrder'

        function toggleTreeSortMode() {
            treeSortMode = treeSortMode === 'type' ? 'spawnOrder' : 'type';
            renderTree();
        }

        function toggleOverview() {
            overviewCollapsed = !overviewCollapsed;
            renderOverview();
        }

        function handleHealthAction(issueIdx) {
            const issue = currentHealthIssues[issueIdx];
            if (!issue) return;

            if (issue.action === 'highlight' && issue.nodeIds) {
                // Switch to graph view and highlight the nodes
                switchView('graph');
                setTimeout(() => {
                    highlightProblemNodes(issue.nodeIds, issue.type);
                }, 100);
            } else if (issue.action === 'clean' && issue.relIds) {
                // Remove broken relationships
                if (confirm(`Remove ${issue.relIds.length} broken relationship(s)?`)) {
                    config.relationships = config.relationships.filter(r => !issue.relIds.includes(r.id));
                    render();
                }
            }
        }

        function highlightProblemNodes(nodeIds, severity) {
            const svg = document.querySelector('.graph-svg');
            if (!svg) return;

            // Clear any existing problem highlights
            clearProblemHighlights();

            const allNodes = svg.querySelectorAll('.graph-node');
            const allEdges = svg.querySelectorAll('.graph-edge');

            // Dim everything
            allNodes.forEach(nodeEl => {
                if (!nodeIds.includes(nodeEl.dataset.id)) {
                    nodeEl.classList.add('dimmed');
                } else {
                    nodeEl.classList.add('problem-highlight');
                    nodeEl.classList.add(`problem-${severity}`);
                }
            });

            allEdges.forEach(edge => {
                edge.classList.add('dimmed');
            });

            // Update context window
            const body = document.getElementById('graphContextBody');
            if (body) {
                const nodes = nodeIds.map(id => config.nodes.find(n => n.id === id)).filter(Boolean);
                body.innerHTML = `
                    <div class="graph-context-problem">
                        <div class="problem-title">${severity === 'error' ? 'âš ï¸ Problem Nodes' : 'âš¡ Needs Attention'}</div>
                        <div class="problem-list">
                            ${nodes.map(n => `
                                <div class="problem-node" onclick="selectNode('${n.id}')">
                                    <span class="problem-node-name">${n.name}</span>
                                    <span class="problem-node-type">${n.type}</span>
                                </div>
                            `).join('')}
                        </div>
                        <button class="btn btn-small" onclick="clearProblemHighlights()" style="margin-top: 0.5rem; width: 100%;">
                            Clear Highlight
                        </button>
                    </div>
                `;
            }
        }

        function clearProblemHighlights() {
            const svg = document.querySelector('.graph-svg');
            if (!svg) return;

            svg.querySelectorAll('.graph-node').forEach(node => {
                node.classList.remove('dimmed', 'problem-highlight', 'problem-warning', 'problem-error');
            });
            svg.querySelectorAll('.graph-edge').forEach(edge => {
                edge.classList.remove('dimmed');
            });

            // Reset context window
            updateGraphContextWindow(null);
        }

        function renderOverview() {
            const container = document.getElementById('sidebarOverview');
            if (!container) return;

            // Calculate stats
            const nodeCount = config.nodes.length;
            const relCount = config.relationships.length;
            const layerCount = config.nodes.filter(n => n.type === 'layer').length;

            // Helper: Extract node ID from compound requirement (handles both string IDs and object format)
            function getRequiredNodeId(req) {
                if (typeof req === 'string') return req;
                if (typeof req === 'object') {
                    // Handle { item: "id" }, { modifier: "id" }, { trait: "id" }, etc.
                    return req.item || req.modifier || req.trait || req.attribute || req.variable || req.id || null;
                }
                return null;
            }

            // Helper: Check if a compound requirement is valid
            function isRequirementValid(req) {
                // Condition-based requirements are always "valid" (we can't easily check them)
                if (typeof req === 'object' && req.condition) return true;
                const nodeId = getRequiredNodeId(req);
                if (!nodeId) return false;
                return config.nodes.some(node => node.id === nodeId);
            }

            // Health checks
            const healthIssues = [];

            // Check for orphan items (items/traits not in any layer)
            // Note: config.layerId is where layer assignment is stored
            const orphanItems = config.nodes.filter(n =>
                (n.type === 'item' || n.type === 'trait') && !n.config?.layerId
            );
            if (orphanItems.length > 0) {
                healthIssues.push({
                    type: 'warning',
                    icon: 'âš ',
                    message: `${orphanItems.length} unassigned item${orphanItems.length > 1 ? 's' : ''}`,
                    nodeIds: orphanItems.map(n => n.id),
                    action: 'highlight'
                });
            }

            // Check for broken relationships
            const brokenRels = config.relationships.filter(r => {
                const hasSource = config.nodes.some(n => n.id === r.sourceId);
                const hasTarget = config.nodes.some(n => n.id === r.targetId);
                return !hasSource || !hasTarget;
            });
            if (brokenRels.length > 0) {
                healthIssues.push({
                    type: 'error',
                    icon: 'âœ•',
                    message: `${brokenRels.length} broken relationship${brokenRels.length > 1 ? 's' : ''}`,
                    relIds: brokenRels.map(r => r.id),
                    action: 'clean'
                });
            }

            // Check for unconnected nodes (no relationships at all - but consider layer membership & compound requires)
            const unconnectedNodes = config.nodes.filter(n => {
                // Skip layers, contexts, derived values (derived are computed, not connected)
                if (n.type === 'layer' || n.type === 'context' || n.type === 'derived') return false;

                // Check if it has any explicit relationships
                const hasRelationship = config.relationships.some(r =>
                    r.sourceId === n.id || r.targetId === n.id
                );
                if (hasRelationship) return false;

                // Check if it belongs to a layer (items/traits)
                if (n.config?.layerId) return false;

                // Check if it's a compound with valid requires (connected to those nodes)
                if (n.type === 'compound' && n.config?.requires?.length > 0) return false;

                // Check if it's required by any compound
                const requiredByCompound = config.nodes.some(c => {
                    if (c.type !== 'compound' || !c.config?.requires) return false;
                    return c.config.requires.some(req => getRequiredNodeId(req) === n.id);
                });
                if (requiredByCompound) return false;

                // Check if it's listed in a layer's itemIds
                const inLayerItemIds = config.nodes.some(layer =>
                    layer.type === 'layer' && layer.config?.itemIds?.includes(n.id)
                );
                if (inLayerItemIds) return false;

                return true;
            });
            if (unconnectedNodes.length > 0 && nodeCount > 3) {
                healthIssues.push({
                    type: 'warning',
                    icon: 'â—‡',
                    message: `${unconnectedNodes.length} node${unconnectedNodes.length > 1 ? 's' : ''} with no connections`,
                    nodeIds: unconnectedNodes.map(n => n.id),
                    action: 'highlight'
                });
            }

            // Check for compounds with missing requirements
            const invalidCompounds = config.nodes.filter(n => {
                if (n.type !== 'compound') return false;
                const requires = n.config?.requires || [];
                if (requires.length === 0) return true; // Compound with no requires is invalid
                return requires.some(req => !isRequirementValid(req));
            });
            if (invalidCompounds.length > 0) {
                healthIssues.push({
                    type: 'error',
                    icon: '!',
                    message: `${invalidCompounds.length} compound${invalidCompounds.length > 1 ? 's' : ''} with invalid requires`,
                    nodeIds: invalidCompounds.map(n => n.id),
                    action: 'highlight'
                });
            }

            // Check for traits/items with broken threshold triggers (referencing deleted nodes)
            const brokenThresholds = config.nodes.filter(n => {
                if (n.type !== 'trait' && n.type !== 'item') return false;
                const trigger = n.config?.selection?.trigger;
                const autoRemove = n.config?.selection?.autoRemove;

                // Check trigger target
                if (trigger?.target) {
                    const targetExists = config.nodes.some(node => node.id === trigger.target);
                    if (!targetExists) return true;
                }
                // Check autoRemove target
                if (autoRemove?.target) {
                    const targetExists = config.nodes.some(node => node.id === autoRemove.target);
                    if (!targetExists) return true;
                }
                return false;
            });
            if (brokenThresholds.length > 0) {
                healthIssues.push({
                    type: 'error',
                    icon: 'âš¡',
                    message: `${brokenThresholds.length} trait${brokenThresholds.length > 1 ? 's' : ''} with broken trigger`,
                    nodeIds: brokenThresholds.map(n => n.id),
                    action: 'highlight'
                });
            }

            // If all good
            if (healthIssues.length === 0 && nodeCount > 0) {
                healthIssues.push({
                    type: 'success',
                    icon: 'âœ“',
                    message: 'Config looks healthy',
                    action: null
                });
            }

            // Store for click handling
            currentHealthIssues = healthIssues;

            // Relationship type distribution for density bar
            const relTypes = {
                rate: config.relationships.filter(r => r.type === 'rate_modifier').length,
                weight: config.relationships.filter(r => r.type === 'weight_influence').length,
                value: config.relationships.filter(r => r.type === 'value_modifier').length
            };
            const totalRels = relCount || 1;

            // Calculate complexity score (improved heuristic)
            // Based on: interconnectedness (avg rels), node types diversity, and total scale
            const avgRelsPerNode = nodeCount > 0 ? (relCount / nodeCount).toFixed(2) : 0;
            const avgRelsNum = parseFloat(avgRelsPerNode);

            // Count unique node types
            const nodeTypes = new Set(config.nodes.map(n => n.type));
            const typeCount = nodeTypes.size;

            // Calculate a composite complexity score
            // - Low interconnection (< 0.5 rel/node) = simpler even with many nodes
            // - High interconnection (> 2 rel/node) = complex system
            // - Many node types = more feature-rich
            let complexityLevel = 'Simple';
            let complexityColor = 'var(--accent-success)';

            if (nodeCount <= 5 && relCount <= 3) {
                complexityLevel = 'Minimal';
                complexityColor = 'var(--text-muted)';
            } else if (avgRelsNum < 0.5 && nodeCount <= 15) {
                complexityLevel = 'Simple';
                complexityColor = 'var(--accent-success)';
            } else if (avgRelsNum >= 0.5 && avgRelsNum < 1.5 && nodeCount <= 30) {
                complexityLevel = 'Moderate';
                complexityColor = 'var(--accent-secondary)';
            } else if (avgRelsNum >= 1.5 || nodeCount > 30 || (typeCount >= 5 && relCount > 20)) {
                complexityLevel = 'Complex';
                complexityColor = 'var(--accent-warning)';
            }

            // Very complex requires both scale AND interconnection
            if (nodeCount > 50 && avgRelsNum >= 1.0) {
                complexityLevel = 'Very Complex';
                complexityColor = 'var(--accent-danger)';
            }

            container.innerHTML = `
                <div class="overview-header" onclick="toggleOverview()">
                    <span>System Overview</span>
                    <span class="overview-toggle">${overviewCollapsed ? 'â–¶' : 'â–¼'}</span>
                </div>
                <div class="overview-content ${overviewCollapsed ? 'collapsed' : ''}">
                    <div class="overview-stats">
                        <div class="overview-stat">
                            <div class="overview-stat-value">${nodeCount}</div>
                            <div class="overview-stat-label">Nodes</div>
                        </div>
                        <div class="overview-stat">
                            <div class="overview-stat-value">${relCount}</div>
                            <div class="overview-stat-label">Relations</div>
                        </div>
                        <div class="overview-stat">
                            <div class="overview-stat-value" style="color: ${complexityColor}; font-size: 0.75rem;">${complexityLevel}</div>
                            <div class="overview-stat-label">${avgRelsPerNode} rel/node</div>
                        </div>
                    </div>

                    <div class="overview-health">
                        ${healthIssues.map((issue, idx) => `
                            <div class="health-item ${issue.type} ${issue.action ? 'clickable' : ''}"
                                 ${issue.action ? `onclick="handleHealthAction(${idx})"` : ''}>
                                <span class="health-icon">${issue.icon}</span>
                                <span>${issue.message}</span>
                                ${issue.action === 'highlight' ? '<span class="health-action">ðŸ‘ show</span>' : ''}
                                ${issue.action === 'clean' ? '<span class="health-action">ðŸ§¹ clean</span>' : ''}
                            </div>
                        `).join('')}
                    </div>

                    ${relCount > 0 ? `
                        <div class="overview-density">
                            <div class="density-bar">
                                <div class="density-segment" style="width: ${relTypes.rate / totalRels * 100}%; background: #c9a86c;"></div>
                                <div class="density-segment" style="width: ${relTypes.weight / totalRels * 100}%; background: #a87bc9;"></div>
                                <div class="density-segment" style="width: ${relTypes.value / totalRels * 100}%; background: #6db385;"></div>
                            </div>
                            <div class="density-legend">
                                <div class="density-legend-item">
                                    <span class="density-legend-dot" style="background: #c9a86c;"></span>
                                    Rate ${relTypes.rate}
                                </div>
                                <div class="density-legend-item">
                                    <span class="density-legend-dot" style="background: #a87bc9;"></span>
                                    Weight ${relTypes.weight}
                                </div>
                                <div class="density-legend-item">
                                    <span class="density-legend-dot" style="background: #6db385;"></span>
                                    Value ${relTypes.value}
                                </div>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderTree() {
            const container = document.getElementById('treeContainer');

            // Render based on sort mode
            if (treeSortMode === 'spawnOrder') {
                renderTreeBySpawnOrder(container);
                return;
            }

            // === TYPE-BASED VIEW (default) ===
            // Build hierarchical layer structure
            // Everything is organized under layers - layers ARE the organizational structure

            // Get all layers and sort by their order/priority if available
            const layers = config.nodes.filter(n => n.type === 'layer');

            // Group non-layer nodes by their layer assignment or create virtual layers
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const contexts = config.nodes.filter(n => n.type === 'context');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const compounds = config.nodes.filter(n => n.type === 'compound');
            const derived = config.nodes.filter(n => n.type === 'derived');
            const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');
            const allItems = config.nodes.filter(n => n.type === 'item' || n.type === 'trait');

            // Build the tree structure - everything as collapsible folders
            let html = '<div class="layer-tree">';

            // Helper to count relationships for a node
            const getRelCount = (nodeId) => {
                return config.relationships.filter(r =>
                    r.sourceId === nodeId || r.targetId === nodeId
                ).length;
            };

            // Helper to render relationship badge
            const renderRelBadge = (count) => {
                if (count === 0) return '';
                const color = count > 3 ? 'var(--accent-warning)' : 'var(--text-muted)';
                return `<span class="tree-item-rel-count" style="color: ${color};" title="${count} relationship${count !== 1 ? 's' : ''}">${count}â†”</span>`;
            };

            // Helper to render spawn order badge
            const renderOrderBadge = (node) => {
                const order = node.type === 'attribute' ? node.config?.spawnOrder :
                             node.type === 'layer' ? node.config?.order : null;
                if (order === null || order === undefined) return '';
                return `<span class="tree-item-order" title="Spawn order: ${order}">#${order}</span>`;
            };

            // Helper to render a folder with items
            const renderFolder = (name, color, nodes, type, level = 0, layerId = null, subtitle = '') => {

                const folderId = `folder-${type}-${layerId || 'root'}`;
                const indent = level * 0.75;
                // Determine the actual node type to create (trait/item folders map to 'trait')
                const addType = type === 'item' ? 'trait' : type;

                return `
                    <div class="tree-folder" style="margin-left: ${indent}rem;" data-folder-id="${folderId}">
                        <div class="tree-folder-header" onclick="toggleTreeFolder('${folderId}')">
                            <span class="folder-toggle">â–¼</span>
                            <span class="folder-icon" style="background: ${color};"></span>
                            <span class="folder-name">${name}</span>
                            ${subtitle ? `<span class="folder-subtitle">${subtitle}</span>` : ''}
                            <span class="folder-count">${nodes.length}</span>
                            <button class="folder-add-btn" onclick="event.stopPropagation(); openAddNodeOfType('${addType}'${layerId ? `, '${layerId}'` : ''})" title="Add ${name.replace(/s$/, '')}">+</button>
                        </div>
                        <div class="tree-folder-contents" id="${folderId}">
                            ${nodes.map(node => {
                                const relCount = getRelCount(node.id);
                                const isDraggable = node.type === 'attribute';
                                return `
                                <div class="tree-item ${selectedNodeId === node.id ? 'selected' : ''} ${isDraggable ? 'draggable' : ''}"
                                     onclick="selectNode('${node.id}')"
                                     ${isDraggable ? `draggable="true"
                                     ondragstart="handleDragStart(event, '${node.id}', 'attribute')"
                                     ondragend="handleDragEnd(event)"
                                     ondragover="handleDragOver(event, '${node.id}', 'attribute')"
                                     ondragleave="handleDragLeave(event)"
                                     ondrop="handleDrop(event, '${node.id}', 'attribute')"` : ''}
                                     style="margin-left: ${indent + 0.5}rem;">
                                    <span class="dot ${node.type}"></span>
                                    <span class="tree-item-name">${node.name}</span>
                                    ${renderOrderBadge(node)}
                                    ${renderRelBadge(relCount)}
                                    <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${node.id}')" title="Delete ${node.name}">âœ•</button>
                                </div>
                            `}).join('')}
                        </div>
                    </div>
                `;
            };

            // Helper to render tick systems with bound modifiers
            const renderTickSystemsFolder = (tickSystems, allModifiers) => {
                const folderId = 'folder-ticksystems-root';

                // Get bound modifiers for a tick system
                const getBoundModifiers = (tsId) => {
                    return allModifiers.filter(mod => {
                        const bindings = mod.config?.tickBindings || [];
                        return bindings.some(b => b.tickSystemId === tsId);
                    });
                };

                return `
                    <div class="tree-folder" data-folder-id="${folderId}">
                        <div class="tree-folder-header" onclick="toggleTreeFolder('${folderId}')">
                            <span class="folder-toggle">â–¼</span>
                            <span class="folder-icon" style="background: var(--node-ticksystem);"></span>
                            <span class="folder-name">Tick Systems</span>
                            <span class="folder-subtitle">timing</span>
                            <span class="folder-count">${tickSystems.length}</span>
                        </div>
                        <div class="tree-folder-contents" id="${folderId}">
                            ${tickSystems.map(ts => {
                                const boundMods = getBoundModifiers(ts.id);
                                const tickLabel = ts.config?.tickUnit?.label || 'tick';
                                const subFolderId = `folder-ticksystem-${ts.id}`;

                                if (boundMods.length === 0) {
                                    // No bound modifiers - render as simple item
                                    return `
                                        <div class="tree-item ${selectedNodeId === ts.id ? 'selected' : ''}"
                                             onclick="selectNode('${ts.id}')"
                                             style="margin-left: 0.5rem;">
                                            <span class="dot ticksystem"></span>
                                            <span class="tree-item-name">${ts.name}</span>
                                            <span class="tree-item-hint" style="color: var(--text-muted); font-size: 0.75rem; margin-left: 0.5rem;">(${tickLabel})</span>
                                            <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${ts.id}')" title="Delete ${ts.name}">âœ•</button>
                                        </div>
                                    `;
                                }

                                // Has bound modifiers - render as sub-folder
                                return `
                                    <div class="tree-folder tree-folder-nested" style="margin-left: 0.5rem;" data-folder-id="${subFolderId}">
                                        <div class="tree-folder-header ${selectedNodeId === ts.id ? 'selected' : ''}"
                                             onclick="event.ctrlKey ? selectNode('${ts.id}') : toggleTreeFolder('${subFolderId}')">
                                            <span class="folder-toggle">â–¼</span>
                                            <span class="dot ticksystem" style="margin-right: 0.4rem;"></span>
                                            <span class="folder-name" onclick="event.stopPropagation(); selectNode('${ts.id}')">${ts.name}</span>
                                            <span class="folder-subtitle">${tickLabel}</span>
                                            <span class="folder-count">${boundMods.length} bound</span>
                                            <button class="folder-add-btn" onclick="event.stopPropagation(); deleteNodeById('${ts.id}')" title="Delete ${ts.name}" style="color: var(--text-muted);">âœ•</button>
                                        </div>
                                        <div class="tree-folder-contents" id="${subFolderId}">
                                            ${boundMods.map(mod => {
                                                const binding = mod.config.tickBindings.find(b => b.tickSystemId === ts.id);
                                                const duration = binding?.duration || '?';
                                                return `
                                                    <div class="tree-item tree-item-bound ${selectedNodeId === mod.id ? 'selected' : ''}"
                                                         onclick="selectNode('${mod.id}')"
                                                         style="margin-left: 1rem;">
                                                        <span class="dot modifier"></span>
                                                        <span class="tree-item-name">${mod.name}</span>
                                                        <span class="tree-item-duration" style="color: var(--node-ticksystem); font-size: 0.75rem; margin-left: auto;">${duration} ${tickLabel}${duration !== 1 ? 's' : ''}</span>
                                                        <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${mod.id}')" title="Delete ${mod.name}">âœ•</button>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            };

            // Helper to render a layer with its contents
            const renderLayerFolder = (layer, layerItems, level = 0) => {
                const folderId = `folder-layer-${layer.id}`;
                const indent = level * 0.75;
                const selectionMode = layer.config?.selection || 'weighted';
                const subtitle = selectionMode === 'threshold' ? 'threshold' : 'weighted';
                const layerOrder = layer.config?.order ?? 0;

                return `
                    <div class="tree-folder tree-folder-layer" style="margin-left: ${indent}rem;" data-folder-id="${folderId}">
                        <div class="tree-folder-header draggable ${selectedNodeId === layer.id ? 'selected' : ''}"
                             draggable="true"
                             ondragstart="handleDragStart(event, '${layer.id}', 'layer')"
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event, '${layer.id}', 'layer')"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, '${layer.id}', 'layer')"
                             onclick="event.ctrlKey ? selectNode('${layer.id}') : toggleTreeFolder('${folderId}')">
                            <span class="folder-toggle">â–¼</span>
                            <span class="folder-icon" style="background: var(--node-layer);"></span>
                            <span class="folder-name" onclick="event.stopPropagation(); selectNode('${layer.id}')">${layer.name}</span>
                            <span class="folder-subtitle">${subtitle}</span>
                            <span class="folder-count">${layerItems.length}</span>
                            <button class="folder-add-btn" onclick="event.stopPropagation(); openAddTraitToLayer('${layer.id}')" title="Add trait to ${layer.name}">+</button>
                        </div>
                        <div class="tree-folder-contents" id="${folderId}">
                            ${layerItems.map(item => {
                                const relCount = getRelCount(item.id);
                                return `
                                <div class="tree-item ${selectedNodeId === item.id ? 'selected' : ''}"
                                     onclick="selectNode('${item.id}')"
                                     style="margin-left: ${indent + 0.5}rem;">
                                    <span class="dot ${item.type}"></span>
                                    <span class="tree-item-name">${item.name}</span>
                                    ${renderRelBadge(relCount)}
                                    <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${item.id}')" title="Delete ${item.name}">âœ•</button>
                                </div>
                            `}).join('')}
                        </div>
                    </div>
                `;
            };

            // Helper to render entity pools folder
            const renderPoolsFolder = (pools) => {
                const folderId = 'folder-pools-root';

                return `
                    <div class="tree-folder" data-folder-id="${folderId}">
                        <div class="tree-folder-header" onclick="toggleTreeFolder('${folderId}')">
                            <span class="folder-toggle">â–¼</span>
                            <span class="folder-icon" style="background: var(--accent-gold);"></span>
                            <span class="folder-name">Entity Pools</span>
                            <span class="folder-subtitle">runtime</span>
                            <span class="folder-count">${pools.length}</span>
                            <button class="folder-add-btn" onclick="event.stopPropagation(); showPoolManagementModal()" title="Manage pools">âš™</button>
                        </div>
                        <div class="tree-folder-contents" id="${folderId}">
                            ${pools.map(pool => {
                                const stats = getPoolStats(pool.id);
                                const hasRules = pool.rules && pool.rules.conditions && pool.rules.conditions.length > 0;
                                return `
                                    <div class="tree-item tree-item-pool"
                                         onclick="showPoolManagementModal()"
                                         style="cursor: pointer;">
                                        <span class="dot" style="background: ${pool.id === 'default' ? 'var(--accent-tertiary)' : 'var(--accent-gold)'};"></span>
                                        <span class="tree-item-name">${pool.name}</span>
                                        <span class="tree-item-pool-stats" style="color: var(--text-muted); font-size: 0.7rem; margin-left: auto;">
                                            ${stats.total} entities
                                            ${hasRules ? '<span title="Has assignment rules">âš¡</span>' : ''}
                                        </span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            };

            // === STATIC VALUES SECTION ===
            html += `
                <div class="tree-section-divider">
                    <span class="divider-label">Static Values</span>
                </div>
            `;
            // Sort attributes by spawn order
            const sortedAttributes = [...attributes].sort((a, b) => {
                const orderA = a.config?.spawnOrder ?? 0;
                const orderB = b.config?.spawnOrder ?? 0;
                return orderA - orderB;
            });
            html += renderFolder('Attributes', 'var(--node-attribute)', sortedAttributes, 'attribute', 0, null, 'static');
            html += renderFolder('Contexts', 'var(--node-context)', contexts, 'context', 0, null, 'external');

            // === DYNAMIC SECTION (Variables) ===
            html += `
                <div class="tree-section-divider">
                    <span class="divider-label">Dynamic State</span>
                </div>
            `;
            html += renderFolder('Variables', 'var(--node-variable)', variables, 'variable', 0, null, 'tick-based');

            // === TRAIT LAYERS ===
            html += `
                <div class="tree-section-divider">
                    <span class="divider-label">Trait Layers</span>
                    <button class="folder-add-btn" onclick="event.stopPropagation(); openAddNodeOfType('layer')" title="Add Layer" style="margin-left: auto;">+</button>
                </div>
            `;

            // Sort layers by their config.order if available, or by name
            const sortedLayers = [...layers].sort((a, b) => {
                const orderA = a.config?.order ?? 999;
                const orderB = b.config?.order ?? 999;
                return orderA - orderB;
            });

            sortedLayers.forEach(layer => {
                const layerItems = allItems.filter(item => item.config?.layerId === layer.id);
                html += renderLayerFolder(layer, layerItems, 0);
            });

            // Orphan items (traits not in any layer)
            const orphanItems = allItems.filter(item => !item.config?.layerId);
            if (orphanItems.length > 0) {
                html += `
                    <div class="tree-folder tree-folder-orphan" data-folder-id="folder-orphan">
                        <div class="tree-folder-header" onclick="toggleTreeFolder('folder-orphan')">
                            <span class="folder-toggle">â–¼</span>
                            <span class="folder-icon" style="background: var(--border-color);"></span>
                            <span class="folder-name" style="font-style: italic; color: var(--text-muted);">Unassigned Items</span>
                            <span class="folder-count">${orphanItems.length}</span>
                        </div>
                        <div class="tree-folder-contents" id="folder-orphan">
                            ${orphanItems.map(item => `
                                <div class="tree-item ${selectedNodeId === item.id ? 'selected' : ''}"
                                     onclick="selectNode('${item.id}')">
                                    <span class="dot ${item.type}"></span>
                                    <span class="tree-item-name">${item.name}</span>
                                    <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${item.id}')" title="Delete ${item.name}">âœ•</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            // === MODIFIERS SECTION ===
            html += `
                <div class="tree-section-divider">
                    <span class="divider-label">Modifiers</span>
                </div>
            `;
            html += renderFolder('Modifiers', 'var(--node-modifier)', modifiers, 'modifier', 0, null, 'temporary');

            // === ACTIONS SECTION ===
            const actions = config.nodes.filter(n => n.type === 'action');
            html += `
                <div class="tree-section-divider">
                    <span class="divider-label">Actions</span>
                </div>
            `;
            html += renderFolder('Actions', 'var(--node-action)', actions, 'action', 0, null, 'behaviors');

            // === ENTITY POOLS SECTION ===
            const pools = Array.from(poolConfigs.values());
            if (pools.length > 0) {
                html += `
                    <div class="tree-section-divider">
                        <span class="divider-label">Entity Pools</span>
                    </div>
                `;
                html += renderPoolsFolder(pools);
            }

            // === EMERGENT SECTION ===
            html += `
                <div class="tree-section-divider">
                    <span class="divider-label">Emergent / Computed</span>
                </div>
            `;
            html += renderFolder('Compounds', 'var(--node-compound)', compounds, 'compound', 0, null, 'requires');
            html += renderFolder('Derived', 'var(--node-derived)', derived, 'derived', 0, null, 'formula');

            // === TICK SYSTEMS SECTION ===
            html += `
                <div class="tree-section-divider">
                    <span class="divider-label">Tick Systems</span>
                </div>
            `;
            if (tickSystems.length > 0) {
                // Custom render for tick systems to show bound modifiers
                html += renderTickSystemsFolder(tickSystems, modifiers);
            } else {
                html += renderFolder('Tick Systems', 'var(--node-ticksystem)', tickSystems, 'ticksystem', 0, null, 'timing');
            }

            // === CONNECTIONS SECTION ===
            if (config.relationships.length > 0) {
                const relFolderId = 'folder-connections-root';
                html += `
                    <div class="tree-section-divider">
                        <span class="divider-label">Connections</span>
                        <button class="folder-add-btn" onclick="event.stopPropagation(); openAddConnectionFromToolbar()" title="Define connection" style="margin-left: auto;">+</button>
                    </div>
                    <div class="tree-folder" data-folder-id="${relFolderId}">
                        <div class="tree-folder-header" onclick="toggleTreeFolder('${relFolderId}')">
                            <span class="folder-toggle">â–¼</span>
                            <span class="folder-icon" style="background: var(--accent-secondary);"></span>
                            <span class="folder-name">All Connections</span>
                            <span class="folder-count">${config.relationships.length}</span>
                        </div>
                        <div class="tree-folder-contents" id="${relFolderId}">
                            ${config.relationships.map(rel => {
                                const source = config.nodes.find(n => n.id === rel.sourceId);
                                const target = config.nodes.find(n => n.id === rel.targetId);
                                const color = getRelationshipColor(rel.type);
                                const typeLabel = rel.type.replace(/_/g, ' ');
                                const valueStr = rel.config?.value != null ? ` ${rel.config.operation || ''} ${rel.config.value}` : '';
                                return `
                                    <div class="tree-item tree-item-connection" onclick="selectNode('${rel.sourceId}')" title="${typeLabel}: ${source?.name || rel.sourceId} â†’ ${target?.name || rel.targetId}${valueStr}">
                                        <span class="dot" style="background: ${color};"></span>
                                        <span class="tree-item-name" style="font-size: 0.75rem;">${source?.name || rel.sourceId} <span style="color: var(--text-muted);">â†’</span> ${target?.name || rel.targetId}</span>
                                        <span style="font-size: 0.6rem; color: ${color}; margin-left: auto; white-space: nowrap;">${typeLabel.split(' ')[0]}</span>
                                        <button class="tree-item-delete" onclick="event.stopPropagation(); deleteRelationship('${rel.id}')" title="Delete connection">âœ•</button>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            html += '</div>';

            // Add sort toggle at the top
            const toggleHtml = `
                <div class="tree-sort-toggle">
                    <span style="color: var(--text-muted);">Sort:</span>
                    <button class="tree-sort-btn ${treeSortMode === 'type' ? 'active' : ''}" onclick="treeSortMode='type'; renderTree();">By Type</button>
                    <button class="tree-sort-btn ${treeSortMode === 'spawnOrder' ? 'active' : ''}" onclick="treeSortMode='spawnOrder'; renderTree();">Spawn Order</button>
                </div>
            `;

            container.innerHTML = toggleHtml + html;
        }

        function renderTreeBySpawnOrder(container) {
            const getRelCount = (nodeId) => config.relationships.filter(r => r.sourceId === nodeId || r.targetId === nodeId).length;

            // Get spawn order for any node
            const getOrder = (node) => {
                if (node.type === 'attribute') return node.config?.spawnOrder ?? 0;
                if (node.type === 'layer') return node.config?.order ?? 0;
                if (node.type === 'trait' || node.type === 'item') {
                    const layer = config.nodes.find(n => n.id === node.config?.layerId);
                    return layer ? (layer.config?.order ?? 0) : 999;
                }
                return 999; // Variables, modifiers, etc. don't have spawn order
            };

            // Collect all spawnable nodes with their orders
            const spawnableNodes = [];

            // Add attributes
            for (const attr of config.nodes.filter(n => n.type === 'attribute')) {
                spawnableNodes.push({ node: attr, order: getOrder(attr), phase: 'spawn' });
            }

            // Add layers (and their traits as children)
            for (const layer of config.nodes.filter(n => n.type === 'layer')) {
                const timing = layer.config.timing || {};
                if (timing.rollAt === 'create' || timing.rollAt === 'spawn') {
                    spawnableNodes.push({ node: layer, order: getOrder(layer), phase: 'spawn', isLayer: true });
                }
            }

            // Sort by order
            spawnableNodes.sort((a, b) => a.order - b.order);

            // Build HTML
            let html = `
                <div class="tree-sort-toggle">
                    <span style="color: var(--text-muted);">Sort:</span>
                    <button class="tree-sort-btn ${treeSortMode === 'type' ? 'active' : ''}" onclick="treeSortMode='type'; renderTree();">By Type</button>
                    <button class="tree-sort-btn ${treeSortMode === 'spawnOrder' ? 'active' : ''}" onclick="treeSortMode='spawnOrder'; renderTree();">Spawn Order</button>
                </div>
                <div class="layer-tree">
                    <div class="tree-section-divider">
                        <span class="divider-label">Spawn Processing Order</span>
                    </div>
            `;

            for (const item of spawnableNodes) {
                const node = item.node;
                const relCount = getRelCount(node.id);

                if (item.isLayer) {
                    // Render layer with its traits
                    const traitIds = node.config?.traitIds || node.config?.itemIds || [];
                    const layerTraits = traitIds.map(id => config.nodes.find(n => n.id === id)).filter(Boolean);

                    html += `
                        <div class="tree-folder tree-folder-layer" data-folder-id="spawn-${node.id}">
                            <div class="tree-folder-header draggable ${selectedNodeId === node.id ? 'selected' : ''}"
                                 draggable="true"
                                 ondragstart="handleDragStart(event, '${node.id}', 'layer')"
                                 ondragend="handleDragEnd(event)"
                                 ondragover="handleDragOver(event, '${node.id}', 'layer')"
                                 ondragleave="handleDragLeave(event)"
                                 ondrop="handleDrop(event, '${node.id}', 'layer')"
                                 onclick="event.ctrlKey ? selectNode('${node.id}') : toggleTreeFolder('spawn-${node.id}')">
                                <span class="folder-toggle">â–¼</span>
                                <span class="dot layer"></span>
                                <span class="folder-name" onclick="event.stopPropagation(); selectNode('${node.id}')">${node.name}</span>
                                <span class="tree-item-order" title="Spawn order: ${item.order}">#${item.order}</span>
                                <span class="folder-count">${layerTraits.length}</span>
                            </div>
                            <div class="tree-folder-contents" id="spawn-${node.id}">
                                ${layerTraits.map(trait => {
                                    const tRelCount = getRelCount(trait.id);
                                    return `
                                        <div class="tree-item ${selectedNodeId === trait.id ? 'selected' : ''}"
                                             onclick="selectNode('${trait.id}')"
                                             style="margin-left: 0.5rem;">
                                            <span class="dot ${trait.type}"></span>
                                            <span class="tree-item-name">${trait.name}</span>
                                            ${tRelCount > 0 ? `<span class="tree-item-rel-count" title="${tRelCount} relationships">${tRelCount}â†”</span>` : ''}
                                            <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${trait.id}')" title="Delete">âœ•</button>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                } else {
                    // Render attribute as draggable item
                    html += `
                        <div class="tree-item draggable ${selectedNodeId === node.id ? 'selected' : ''}"
                             draggable="true"
                             ondragstart="handleDragStart(event, '${node.id}', 'attribute')"
                             ondragend="handleDragEnd(event)"
                             ondragover="handleDragOver(event, '${node.id}', 'attribute')"
                             ondragleave="handleDragLeave(event)"
                             ondrop="handleDrop(event, '${node.id}', 'attribute')"
                             onclick="selectNode('${node.id}')"
                             style="margin: 0.1rem 0;">
                            <span class="dot ${node.type}"></span>
                            <span class="tree-item-name">${node.name}</span>
                            <span class="tree-item-order" title="Spawn order: ${item.order}">#${item.order}</span>
                            ${relCount > 0 ? `<span class="tree-item-rel-count" title="${relCount} relationships">${relCount}â†”</span>` : ''}
                            <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${node.id}')" title="Delete">âœ•</button>
                        </div>
                    `;
                }
            }

            // Show non-spawnable nodes at the bottom
            const nonSpawnable = config.nodes.filter(n =>
                !['attribute', 'layer', 'trait', 'item'].includes(n.type)
            );

            if (nonSpawnable.length > 0) {
                html += `
                    <div class="tree-section-divider" style="margin-top: 1rem;">
                        <span class="divider-label">Runtime / Computed</span>
                    </div>
                `;

                for (const node of nonSpawnable) {
                    const relCount = getRelCount(node.id);
                    html += `
                        <div class="tree-item ${selectedNodeId === node.id ? 'selected' : ''}"
                             onclick="selectNode('${node.id}')"
                             style="margin: 0.1rem 0;">
                            <span class="dot ${node.type}"></span>
                            <span class="tree-item-name">${node.name}</span>
                            ${relCount > 0 ? `<span class="tree-item-rel-count" title="${relCount} relationships">${relCount}â†”</span>` : ''}
                            <button class="tree-item-delete" onclick="event.stopPropagation(); deleteNodeById('${node.id}')" title="Delete">âœ•</button>
                        </div>
                    `;
                }
            }

            html += '</div>';

            container.innerHTML = html;
        }

        function toggleTreeFolder(folderId) {
            const contents = document.getElementById(folderId);
            const folder = contents?.closest('.tree-folder');
            const toggle = folder?.querySelector('.folder-toggle');

            if (contents && toggle) {
                const isCollapsed = contents.style.display === 'none';
                contents.style.display = isCollapsed ? 'block' : 'none';
                toggle.textContent = isCollapsed ? 'â–¼' : 'â–¶';
            }
        }

        // ========================================
        // DRAG-TO-REORDER SPAWN ORDER
        // ========================================

        let draggedNodeId = null;
        let draggedNodeType = null; // 'attribute' or 'layer'

        function handleDragStart(event, nodeId, nodeType) {
            draggedNodeId = nodeId;
            draggedNodeType = nodeType;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', nodeId);
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            draggedNodeId = null;
            draggedNodeType = null;

            // Clean up all drag-over classes
            document.querySelectorAll('.drag-over, .drag-over-below').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-below');
            });
        }

        function handleDragOver(event, targetNodeId, targetNodeType) {
            event.preventDefault();

            // Only allow reordering within same type (attributes with attributes, layers with layers)
            if (draggedNodeType !== targetNodeType) return;
            if (draggedNodeId === targetNodeId) return;

            event.dataTransfer.dropEffect = 'move';

            // Determine if dropping above or below based on mouse position
            const rect = event.target.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const isAbove = event.clientY < midY;

            // Clean up previous drag-over classes
            document.querySelectorAll('.drag-over, .drag-over-below').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-below');
            });

            // Add appropriate class
            const targetEl = event.target.closest('.tree-item, .tree-folder-header');
            if (targetEl) {
                targetEl.classList.add(isAbove ? 'drag-over' : 'drag-over-below');
            }
        }

        function handleDragLeave(event) {
            const targetEl = event.target.closest('.tree-item, .tree-folder-header');
            if (targetEl) {
                targetEl.classList.remove('drag-over', 'drag-over-below');
            }
        }

        function handleDrop(event, targetNodeId, targetNodeType) {
            event.preventDefault();

            // Clean up drag-over classes
            document.querySelectorAll('.drag-over, .drag-over-below').forEach(el => {
                el.classList.remove('drag-over', 'drag-over-below');
            });

            // Only allow reordering within same type
            if (draggedNodeType !== targetNodeType) return;
            if (!draggedNodeId || draggedNodeId === targetNodeId) return;

            // Get all nodes of this type and their current orders
            const orderField = draggedNodeType === 'attribute' ? 'spawnOrder' : 'order';
            const nodes = config.nodes
                .filter(n => n.type === draggedNodeType)
                .sort((a, b) => (a.config[orderField] ?? 0) - (b.config[orderField] ?? 0));

            const draggedIndex = nodes.findIndex(n => n.id === draggedNodeId);
            const targetIndex = nodes.findIndex(n => n.id === targetNodeId);

            if (draggedIndex === -1 || targetIndex === -1) return;

            // Determine if dropping above or below
            const rect = event.target.getBoundingClientRect();
            const midY = rect.top + rect.height / 2;
            const dropAbove = event.clientY < midY;

            // Remove dragged from its position and insert at new position
            const [draggedNode] = nodes.splice(draggedIndex, 1);
            const insertIndex = dropAbove ? targetIndex : targetIndex + 1;
            nodes.splice(draggedIndex < targetIndex ? insertIndex - 1 : insertIndex, 0, draggedNode);

            // Reassign order values to all nodes of this type
            nodes.forEach((node, index) => {
                const configNode = config.nodes.find(n => n.id === node.id);
                if (configNode) {
                    configNode.config[orderField] = index;
                }
            });

            // Save and re-render
            engine.loadConfig(config);
            saveToStorage();
            render();

            showToast(`Reordered ${draggedNodeType}s`, 'success');
        }

        function renderMainView() {
            const content = document.getElementById('viewContent');

            if (config.nodes.length === 0) {
                // Show jump-in message if user clicked "Jump In", otherwise show welcome
                content.innerHTML = showJumpInMessage ? renderJumpInState() : renderWelcomeState();
                return;
            }

            // Clear jump-in message state once there are nodes
            if (showJumpInMessage) {
                showJumpInMessage = false;
            }

            switch (currentView) {
                case 'overview':
                    renderOverviewView(content);
                    break;
                case 'tree': // Legacy support
                    overviewMode = 'tree';
                    currentView = 'overview';
                    renderOverviewView(content);
                    break;
                case 'graph': // Legacy support
                    overviewMode = 'graph';
                    currentView = 'overview';
                    renderOverviewView(content);
                    break;
                case 'simulation':
                    renderSimulationView(content);
                    break;
                case 'spawn-logic': // Legacy
                    currentView = 'simulation';
                    renderSimulationView(content);
                    break;
                case 'preview': // Legacy
                    currentView = 'simulation';
                    renderSimulationView(content);
                    break;
                case 'ticks':
                    renderTicksView(content);
                    break;
                case 'persistence':
                    renderPersistenceView(content);
                    break;
                case 'entities': // Legacy
                    currentView = 'persistence';
                    renderPersistenceView(content);
                    break;
                case 'presets': // Legacy
                    currentView = 'persistence';
                    persistenceSection = 'presets';
                    renderPersistenceView(content);
                    break;
                case 'code':
                    renderCodeView(content);
                    break;
                case 'validate':
                    renderValidateView(content);
                    break;
            }
        }

        // ========================================
        // OVERVIEW VIEW (Tree/Graph toggle)
        // ========================================
        function renderOverviewView(container) {
            container.innerHTML = `
                <div class="overview-view">
                    <div class="overview-toggle">
                        <button class="overview-mode-btn ${overviewMode === 'tree' ? 'active' : ''}"
                                onclick="setOverviewMode('tree')">
                            <span class="mode-icon">ðŸŒ²</span> Tree
                        </button>
                        <button class="overview-mode-btn ${overviewMode === 'graph' ? 'active' : ''}"
                                onclick="setOverviewMode('graph')">
                            <span class="mode-icon">â—‡</span> Graph
                        </button>
                        <div class="overview-toggle-spacer"></div>
                        <button class="btn btn-sm" onclick="switchView('simulation')" title="Test your config in the Simulation tab" style="font-size: 0.7rem;">
                            â–¶ Test
                        </button>
                        <button class="add-connection-btn" onclick="openAddConnectionFromToolbar()" title="Define a new connection between nodes">
                            + define connection
                        </button>
                    </div>
                    <div class="overview-content" id="overviewContent"></div>
                </div>
            `;

            const contentDiv = document.getElementById('overviewContent');
            if (overviewMode === 'tree') {
                renderTreeView(contentDiv);
            } else {
                renderGraphView(contentDiv);
            }
        }

        function setOverviewMode(mode) {
            overviewMode = mode;
            renderOverviewView(document.getElementById('viewContent'));
        }

        // Alias for renamed view
        function renderSpawnLogicView(container) {
            renderSimulationView(container);
        }

        // ========================================
        // TICKS VIEW
        // ========================================
        function renderTicksView(container) {
            const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');

            container.innerHTML = `
                <div class="ticks-view">
                    <div class="ticks-sidebar">
                        <div class="ticks-header">
                            <h3>Tick Systems</h3>
                            <button class="btn btn-primary btn-sm" onclick="showAddTickSystemModal()">
                                + Add System
                            </button>
                        </div>
                        <div class="ticks-list">
                            ${tickSystems.length === 0 ? `
                                <div class="empty-state-small">
                                    <div class="empty-icon">â±ï¸</div>
                                    <div class="empty-text">No tick systems defined</div>
                                    <div class="empty-hint">Tick systems control time-based mechanics like combat turns, day/night cycles, or real-time effects.</div>
                                </div>
                            ` : tickSystems.map(ts => `
                                <div class="tick-system-item ${selectedNodeId === ts.id ? 'selected' : ''}"
                                     onclick="selectNode('${ts.id}')">
                                    <span class="tick-icon">â±ï¸</span>
                                    <span class="tick-name">${ts.name}</span>
                                    <span class="tick-unit">${ts.config?.tickUnit?.label || 'tick'}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="ticks-detail">
                        ${selectedNodeId && tickSystems.find(ts => ts.id === selectedNodeId) ?
                            renderTickSystemDetail(tickSystems.find(ts => ts.id === selectedNodeId)) :
                            renderAllDurationBindings(tickSystems)
                        }
                    </div>
                </div>
            `;
        }

        function updateTicksDetailPanel() {
            // Only update the detail panel portion to avoid scroll jump
            const detailPanel = document.querySelector('.ticks-detail');
            if (!detailPanel) return;

            const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');
            const selectedTickSystem = selectedNodeId ? tickSystems.find(ts => ts.id === selectedNodeId) : null;

            detailPanel.innerHTML = selectedTickSystem ?
                renderTickSystemDetail(selectedTickSystem) :
                renderAllDurationBindings(tickSystems);
        }

        function renderAllDurationBindings(tickSystems) {
            if (tickSystems.length === 0) {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">â±ï¸</div>
                        <div class="empty-state-text">No tick systems yet</div>
                        <div class="empty-state-hint">Create a tick system to define time-based mechanics for your modifiers</div>
                    </div>
                `;
            }

            // Gather all duration bindings
            const allBindings = [];
            config.nodes.filter(n => n.type === 'modifier').forEach(mod => {
                const bindings = mod.config?.tickBindings || [];
                bindings.forEach(binding => {
                    const ts = tickSystems.find(t => t.id === binding.tickSystemId);
                    if (ts) {
                        allBindings.push({
                            modifier: mod,
                            tickSystem: ts,
                            duration: binding.duration,
                            fallback: binding.fallbackBehavior
                        });
                    }
                });
            });

            return `
                <div class="all-bindings-view">
                    <div class="bindings-header">
                        <h3>Duration Bindings Overview</h3>
                        <p class="bindings-hint">Select a tick system on the left to configure it, or view all modifier bindings below.</p>
                    </div>

                    ${allBindings.length === 0 ? `
                        <div class="empty-state-small" style="margin-top: 2rem;">
                            <div class="empty-icon">ðŸ”—</div>
                            <div class="empty-text">No modifiers bound to tick systems</div>
                            <div class="empty-hint">Select a modifier in the Overview tab and add tick bindings in its detail panel.</div>
                        </div>
                    ` : `
                        <div class="bindings-table">
                            <div class="bindings-table-header">
                                <span class="col-modifier">Modifier</span>
                                <span class="col-arrow">â†’</span>
                                <span class="col-ticksystem">Tick System</span>
                                <span class="col-duration">Duration</span>
                                <span class="col-fallback">On Stop</span>
                            </div>
                            ${allBindings.map(b => `
                                <div class="bindings-table-row" onclick="selectNode('${b.modifier.id}')">
                                    <span class="col-modifier">
                                        <span class="dot modifier"></span>
                                        ${b.modifier.name}
                                    </span>
                                    <span class="col-arrow">â†’</span>
                                    <span class="col-ticksystem">
                                        <span class="dot ticksystem"></span>
                                        ${b.tickSystem.name}
                                    </span>
                                    <span class="col-duration">${b.duration} ${b.tickSystem.config?.tickUnit?.label || 'tick'}${b.duration !== 1 ? 's' : ''}</span>
                                    <span class="col-fallback fallback-${b.fallback}">${b.fallback}</span>
                                </div>
                            `).join('')}
                        </div>
                    `}
                </div>
            `;
        }

        function renderTickSystemDetail(tickSystem) {
            const ts = tickSystem;
            const config_ts = ts.config || {};
            const tickUnit = config_ts.tickUnit || { type: 'manual', value: 1, label: 'tick' };
            const triggers = config_ts.triggers || { start: { type: 'always' }, stop: { type: 'api' } };

            return `
                <div class="tick-system-detail">
                    <div class="detail-section">
                        <h4>Basic Info</h4>
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" value="${ts.name}"
                                   onchange="updateNode('${ts.id}', 'name', this.value)">
                        </div>
                        <div class="form-group">
                            <label>ID</label>
                            <input type="text" value="${ts.id}" disabled class="disabled-input">
                        </div>
                        <div class="form-group">
                            <label>Description</label>
                            <textarea onchange="updateNode('${ts.id}', 'description', this.value)">${ts.description || ''}</textarea>
                        </div>
                    </div>

                    <div class="detail-section">
                        <h4>Tick Unit</h4>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Type</label>
                                <select onchange="updateTickSystemConfig('${ts.id}', 'tickUnit.type', this.value)">
                                    <option value="manual" ${tickUnit.type === 'manual' ? 'selected' : ''}>Manual (API/Event)</option>
                                    <option value="timed" ${tickUnit.type === 'timed' ? 'selected' : ''}>Timed (Auto)</option>
                                </select>
                            </div>
                            <div class="form-group" ${tickUnit.type !== 'timed' ? 'style="opacity: 0.5;"' : ''}>
                                <label>Interval (ms)</label>
                                <input type="number" value="${tickUnit.value || 1000}" min="100"
                                       onchange="updateTickSystemConfig('${ts.id}', 'tickUnit.value', parseInt(this.value))"
                                       ${tickUnit.type !== 'timed' ? 'disabled' : ''}>
                            </div>
                            <div class="form-group">
                                <label>Label</label>
                                <input type="text" value="${tickUnit.label || 'tick'}"
                                       placeholder="turn, second, cycle..."
                                       onchange="updateTickSystemConfig('${ts.id}', 'tickUnit.label', this.value)">
                            </div>
                        </div>
                    </div>

                    <div class="detail-section">
                        <h4>Start Trigger</h4>
                        ${renderTriggerConfig(ts.id, 'start', triggers.start)}
                    </div>

                    <div class="detail-section">
                        <h4>Stop Trigger</h4>
                        ${renderTriggerConfig(ts.id, 'stop', triggers.stop)}
                    </div>

                    <div class="detail-section">
                        <h4>Connected Modifiers</h4>
                        ${renderConnectedModifiers(ts.id)}
                    </div>
                </div>
            `;
        }

        function renderTriggerConfig(tickSystemId, triggerType, trigger) {
            const type = trigger?.type || 'always';
            const conditions = trigger?.conditions || [];
            const conditionLogic = trigger?.conditionLogic || 'all';

            return `
                <div class="trigger-config">
                    <div class="form-group">
                        <label>Trigger Type</label>
                        <select onchange="updateTickSystemTrigger('${tickSystemId}', '${triggerType}', 'type', this.value)">
                            <option value="always" ${type === 'always' ? 'selected' : ''}>Always Active</option>
                            <option value="api" ${type === 'api' ? 'selected' : ''}>API Call (Manual)</option>
                            <option value="condition" ${type === 'condition' ? 'selected' : ''}>Conditional</option>
                        </select>
                    </div>
                    ${type === 'condition' ? `
                        <div class="condition-builder">
                            <div class="condition-logic">
                                <label>Logic:</label>
                                <select onchange="updateTickSystemTrigger('${tickSystemId}', '${triggerType}', 'conditionLogic', this.value)">
                                    <option value="all" ${conditionLogic === 'all' ? 'selected' : ''}>ALL conditions (AND)</option>
                                    <option value="any" ${conditionLogic === 'any' ? 'selected' : ''}>ANY condition (OR)</option>
                                </select>
                            </div>
                            <div class="conditions-list">
                                ${conditions.map((cond, idx) => renderConditionRow(tickSystemId, triggerType, cond, idx)).join('')}
                                ${conditions.length === 0 ? '<div class="empty-hint">No conditions defined</div>' : ''}
                            </div>
                            <button class="btn btn-sm" onclick="addTriggerCondition('${tickSystemId}', '${triggerType}')">
                                + Add Condition
                            </button>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderConditionRow(tickSystemId, triggerType, condition, index) {
            const variables = config.nodes.filter(n => n.type === 'variable' || n.type === 'attribute' || n.type === 'context');
            const traits = config.nodes.filter(n => n.type === 'trait');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const allSources = [...variables, ...traits, ...modifiers];

            return `
                <div class="condition-row">
                    <select onchange="updateTriggerCondition('${tickSystemId}', '${triggerType}', ${index}, 'sourceId', this.value)">
                        <option value="">Select source...</option>
                        <optgroup label="Variables">
                            ${variables.map(v => `<option value="${v.id}" ${condition.sourceId === v.id ? 'selected' : ''}>${v.name}</option>`).join('')}
                        </optgroup>
                        <optgroup label="Traits">
                            ${traits.map(t => `<option value="${t.id}" ${condition.sourceId === t.id ? 'selected' : ''}>${t.name} (active)</option>`).join('')}
                        </optgroup>
                        <optgroup label="Modifiers">
                            ${modifiers.map(m => `<option value="${m.id}" ${condition.sourceId === m.id ? 'selected' : ''}>${m.name} (active)</option>`).join('')}
                        </optgroup>
                    </select>
                    <select onchange="updateTriggerCondition('${tickSystemId}', '${triggerType}', ${index}, 'operator', this.value)">
                        <option value=">" ${condition.operator === '>' ? 'selected' : ''}>&gt;</option>
                        <option value=">=" ${condition.operator === '>=' ? 'selected' : ''}>&gt;=</option>
                        <option value="<" ${condition.operator === '<' ? 'selected' : ''}>&lt;</option>
                        <option value="<=" ${condition.operator === '<=' ? 'selected' : ''}>&lt;=</option>
                        <option value="==" ${condition.operator === '==' ? 'selected' : ''}>=</option>
                        <option value="!=" ${condition.operator === '!=' ? 'selected' : ''}>!=</option>
                        <option value="active" ${condition.operator === 'active' ? 'selected' : ''}>is active</option>
                        <option value="inactive" ${condition.operator === 'inactive' ? 'selected' : ''}>is inactive</option>
                    </select>
                    ${!['active', 'inactive'].includes(condition.operator) ? `
                        <input type="number" value="${condition.value || 0}"
                               onchange="updateTriggerCondition('${tickSystemId}', '${triggerType}', ${index}, 'value', parseFloat(this.value))">
                    ` : ''}
                    <button class="btn btn-icon btn-danger btn-sm" onclick="removeTriggerCondition('${tickSystemId}', '${triggerType}', ${index})">âœ•</button>
                </div>
            `;
        }

        function renderConnectedModifiers(tickSystemId) {
            // Find modifiers that have this tick system in their tickBindings
            const connectedMods = config.nodes.filter(n => {
                if (n.type !== 'modifier') return false;
                const bindings = n.config?.tickBindings || [];
                return bindings.some(b => b.tickSystemId === tickSystemId);
            });

            // Also check relationships
            const boundByRelationship = config.relationships.filter(r =>
                r.type === 'duration_binding' && r.targetId === tickSystemId
            ).map(r => config.nodes.find(n => n.id === r.sourceId)).filter(Boolean);

            const allConnected = [...new Set([...connectedMods, ...boundByRelationship])];

            if (allConnected.length === 0) {
                return '<div class="empty-hint">No modifiers connected to this tick system</div>';
            }

            return `
                <div class="connected-modifiers-list">
                    ${allConnected.map(mod => {
                        const binding = mod.config?.tickBindings?.find(b => b.tickSystemId === tickSystemId);
                        return `
                            <div class="connected-modifier-item" onclick="selectNode('${mod.id}')">
                                <span class="dot modifier"></span>
                                <span class="mod-name">${mod.name}</span>
                                ${binding ? `<span class="mod-duration">${binding.duration} ${config.nodes.find(n => n.id === tickSystemId)?.config?.tickUnit?.label || 'ticks'}</span>` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function showAddTickSystemModal() {
            // Reuse the add node modal but pre-select ticksystem type
            newNodeType = 'ticksystem';
            document.querySelectorAll('.node-type-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.type === 'ticksystem');
            });
            renderNewNodeTypeConfig();
            document.getElementById('addNodeModal').classList.add('active');
            applyModalLayoutPref('addNodeModal');
        }

        function updateTickSystemConfig(tickSystemId, path, value) {
            const node = config.nodes.find(n => n.id === tickSystemId);
            if (!node) return;

            // Handle nested path like 'tickUnit.type'
            const parts = path.split('.');
            let obj = node.config;
            for (let i = 0; i < parts.length - 1; i++) {
                if (!obj[parts[i]]) obj[parts[i]] = {};
                obj = obj[parts[i]];
            }
            obj[parts[parts.length - 1]] = value;

            saveToStorage();
            // Only update the detail panel to avoid scroll/focus jump
            if (currentView === 'ticks') {
                updateTicksDetailPanel();
            } else {
                render();
            }
        }

        function updateTickSystemTrigger(tickSystemId, triggerType, field, value) {
            const node = config.nodes.find(n => n.id === tickSystemId);
            if (!node) return;

            if (!node.config.triggers) node.config.triggers = {};
            if (!node.config.triggers[triggerType]) {
                node.config.triggers[triggerType] = { type: 'always', conditions: [], conditionLogic: 'all' };
            }

            node.config.triggers[triggerType][field] = value;

            saveToStorage();
            // Only update the detail panel to avoid scroll/focus jump
            if (currentView === 'ticks') {
                updateTicksDetailPanel();
            } else {
                render();
            }
        }

        function addTriggerCondition(tickSystemId, triggerType) {
            const node = config.nodes.find(n => n.id === tickSystemId);
            if (!node) return;

            if (!node.config.triggers) node.config.triggers = {};
            if (!node.config.triggers[triggerType]) {
                node.config.triggers[triggerType] = { type: 'condition', conditions: [], conditionLogic: 'all' };
            }
            if (!node.config.triggers[triggerType].conditions) {
                node.config.triggers[triggerType].conditions = [];
            }

            node.config.triggers[triggerType].conditions.push({
                sourceId: '',
                operator: '>',
                value: 0
            });

            saveToStorage();
            if (currentView === 'ticks') {
                updateTicksDetailPanel();
            } else {
                render();
            }
        }

        function updateTriggerCondition(tickSystemId, triggerType, index, field, value) {
            const node = config.nodes.find(n => n.id === tickSystemId);
            if (!node?.config?.triggers?.[triggerType]?.conditions?.[index]) return;

            node.config.triggers[triggerType].conditions[index][field] = value;

            saveToStorage();
            if (currentView === 'ticks') {
                updateTicksDetailPanel();
            } else {
                render();
            }
        }

        function removeTriggerCondition(tickSystemId, triggerType, index) {
            const node = config.nodes.find(n => n.id === tickSystemId);
            if (!node?.config?.triggers?.[triggerType]?.conditions) return;

            node.config.triggers[triggerType].conditions.splice(index, 1);

            saveToStorage();
            if (currentView === 'ticks') {
                updateTicksDetailPanel();
            } else {
                render();
            }
        }

        // ========================================
        // TICK BINDING HELPERS (for modifiers)
        // ========================================
        function addTickBinding(modifierId) {
            const select = document.getElementById(`tickBindingAdd_${modifierId}`);
            const tickSystemId = select?.value;
            if (!tickSystemId) return;

            const node = config.nodes.find(n => n.id === modifierId);
            if (!node) return;

            if (!node.config.tickBindings) node.config.tickBindings = [];

            // Check if already bound
            if (node.config.tickBindings.some(b => b.tickSystemId === tickSystemId)) {
                showToast('Already bound to this tick system', 'warning');
                return;
            }

            node.config.tickBindings.push({
                tickSystemId: tickSystemId,
                duration: 3,
                fallbackBehavior: 'pause'
            });

            saveToStorage();
            render();
        }

        function updateTickBinding(modifierId, index, field, value) {
            const node = config.nodes.find(n => n.id === modifierId);
            if (!node?.config?.tickBindings?.[index]) return;

            node.config.tickBindings[index][field] = value;

            saveToStorage();
            render();
        }

        function removeTickBinding(modifierId, index) {
            const node = config.nodes.find(n => n.id === modifierId);
            if (!node?.config?.tickBindings) return;

            node.config.tickBindings.splice(index, 1);

            saveToStorage();
            render();
        }

        // Track expanded/collapsed state for layer folders (default: all expanded)
        let expandedLayers = null; // Will be initialized on first render

        function initExpandedLayers() {
            if (expandedLayers === null) {
                expandedLayers = new Set();
                // Start with all layers expanded
                config.nodes.filter(n => n.type === 'layer').forEach(layer => {
                    expandedLayers.add(layer.id);
                });
            }
        }

        function toggleLayerFolder(layerId, event) {
            event.stopPropagation();
            initExpandedLayers();
            if (expandedLayers.has(layerId)) {
                expandedLayers.delete(layerId);
            } else {
                expandedLayers.add(layerId);
            }
            renderTreeView(document.getElementById('viewContent'));
        }

        function renderTreeView(container) {
            initExpandedLayers();

            // Sections BEFORE Layers & Traits
            const preSections = [
                { types: ['attribute'], label: 'Attributes', color: 'var(--node-attribute)' }
            ];

            // Sections AFTER Layers & Traits (Variables roll after traits, so they come after)
            const postSections = [
                { types: ['variable'], label: 'Variables', color: 'var(--node-variable)' },
                { types: ['context'], label: 'Contexts', color: 'var(--node-context)' },
                { types: ['modifier'], label: 'Modifiers', color: 'var(--node-modifier)' },
                { types: ['compound'], label: 'Compounds', color: 'var(--node-compound)' },
                { types: ['action'], label: 'Actions', color: 'var(--node-action)' },
                { types: ['derived'], label: 'Derived Values', color: 'var(--node-derived)' },
                { types: ['ticksystem'], label: 'Tick Systems', color: 'var(--node-ticksystem)' }
            ];

            // Get layers with their traits
            const layers = config.nodes.filter(n => n.type === 'layer')
                .sort((a, b) => (a.config?.order ?? 0) - (b.config?.order ?? 0));

            // Find orphan traits (traits without a valid layer)
            const allTraits = config.nodes.filter(n => n.type === 'item' || n.type === 'trait');
            const layerIds = new Set(layers.map(l => l.id));
            const orphanTraits = allTraits.filter(t => !layerIds.has(t.config?.layerId));

            // Helper to render a section
            const renderSection = (section) => {
                const nodes = config.nodes.filter(n => section.types.includes(n.type));

                return `
                    <div class="tree-view-section">
                        <div class="tree-view-section-title">
                            <span class="icon" style="background: ${section.color}"></span>
                            ${section.label}
                            <button class="folder-add-btn" onclick="event.stopPropagation(); openAddNodeOfType('${section.types[0]}')" title="Add ${section.label.replace(/s$/, '')}">+</button>
                        </div>
                        <div class="tree-view-nodes">
                            ${nodes.length > 0 ? nodes.map(node => `
                                <div class="tree-view-node ${selectedNodeId === node.id ? 'selected' : ''}"
                                     onclick="selectNode('${node.id}')">
                                    <span class="dot ${node.type}"></span>
                                    ${node.name}
                                </div>
                            `).join('') : '<div style="color: var(--text-muted); font-size: 0.7rem; padding: 0.25rem 0;">None</div>'}
                        </div>
                    </div>
                `;
            };

            container.innerHTML = `
                <div class="tree-view">
                    ${preSections.map(renderSection).join('')}

                    <div class="tree-view-section">
                        <div class="tree-view-section-title">
                            <span class="icon" style="background: var(--node-layer)"></span>
                            Layers & Traits
                            <button class="folder-add-btn" onclick="event.stopPropagation(); openAddNodeOfType('layer')" title="Add Layer">+</button>
                        </div>
                            <div class="tree-layer-folders">
                                ${layers.map(layer => {
                                    const layerTraits = allTraits.filter(t => t.config?.layerId === layer.id);
                                    const isExpanded = expandedLayers.has(layer.id);
                                    const rollRange = layer.config?.selection?.rollRange ||
                                        [layer.config?.selection?.initialRolls ?? 1, layer.config?.selection?.initialRolls ?? 1];
                                    const rollText = rollRange[0] === rollRange[1]
                                        ? `${rollRange[0]}`
                                        : `${rollRange[0]}-${rollRange[1]}`;

                                    return `
                                        <div class="tree-layer-folder">
                                            <div class="tree-layer-header ${selectedNodeId === layer.id ? 'selected' : ''}"
                                                 onclick="selectNode('${layer.id}')">
                                                <span class="tree-layer-toggle ${isExpanded ? 'expanded' : ''}"
                                                      onclick="toggleLayerFolder('${layer.id}', event)">â–¶</span>
                                                <span class="dot layer"></span>
                                                <span class="tree-layer-name">${layer.name}</span>
                                                <span class="tree-layer-roll-range" title="Rolls ${rollText} traits">Ã—${rollText}</span>
                                                <span class="tree-layer-count">${layerTraits.length}</span>
                                                <button class="tree-add-trait-btn" onclick="event.stopPropagation(); openAddNodeOfType('trait', '${layer.id}')" title="Add trait to ${layer.name}">+</button>
                                            </div>
                                            <div class="tree-layer-children ${isExpanded ? '' : 'collapsed'}">
                                                ${layerTraits.map(trait => {
                                                    const isThreshold = trait.config?.selection?.mode === 'threshold';
                                                    return `
                                                        <div class="tree-trait-item ${selectedNodeId === trait.id ? 'selected' : ''}"
                                                             onclick="selectNode('${trait.id}')">
                                                            <span class="dot item"></span>
                                                            <span class="tree-trait-name">${trait.name}</span>
                                                            ${isThreshold ? '<span class="trait-mode threshold">âš¡</span>' : ''}
                                                            <button class="tree-delete-trait-btn" onclick="event.stopPropagation(); deleteNodeById('${trait.id}')" title="Delete ${trait.name}">Ã—</button>
                                                        </div>
                                                    `;
                                                }).join('')}
                                                ${layerTraits.length === 0 ? '<div style="color: var(--text-muted); font-size: 0.7rem; padding: 0.25rem;">No traits</div>' : ''}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            ${layers.length === 0 ? '<div style="color: var(--text-muted); font-size: 0.7rem; padding: 0.25rem 0;">No layers defined</div>' : ''}
                            </div>
                        </div>

                    ${orphanTraits.length > 0 ? `
                        <div class="tree-view-section">
                            <div class="tree-view-section-title">
                                <span class="icon" style="background: var(--accent-danger)"></span>
                                Orphan Traits (no layer)
                            </div>
                            <div class="tree-view-nodes">
                                ${orphanTraits.map(node => `
                                    <div class="tree-view-node ${selectedNodeId === node.id ? 'selected' : ''}"
                                         onclick="selectNode('${node.id}')">
                                        <span class="dot ${node.type}"></span>
                                        ${node.name}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}

                    ${postSections.map(renderSection).join('')}

                    ${config.relationships.length > 0 ? `
                        <div class="tree-view-section">
                            <div class="tree-view-section-title">
                                <span class="icon" style="background: var(--accent-secondary)"></span>
                                Connections
                                <span style="font-size: 0.7rem; color: var(--text-muted); margin-left: 0.25rem;">(${config.relationships.length})</span>
                                <button class="folder-add-btn" onclick="event.stopPropagation(); openAddConnectionFromToolbar()" title="Define connection">+</button>
                            </div>
                            <div class="tree-view-nodes">
                                ${config.relationships.map(rel => {
                                    const source = config.nodes.find(n => n.id === rel.sourceId);
                                    const target = config.nodes.find(n => n.id === rel.targetId);
                                    const color = getRelationshipColor(rel.type);
                                    const typeLabel = rel.type.replace(/_/g, ' ');
                                    return `
                                        <div class="tree-view-node" onclick="selectNode('${rel.sourceId}')" title="${typeLabel}">
                                            <span class="dot" style="background: ${color}"></span>
                                            <span style="flex: 1; font-size: 0.8rem;">${source?.name || rel.sourceId} <span style="color: var(--text-muted);">â†’</span> ${target?.name || rel.targetId}</span>
                                            <button class="tree-delete-trait-btn" onclick="event.stopPropagation(); deleteRelationship('${rel.id}')" title="Delete">Ã—</button>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderGraphView(container) {
            // Simple SVG-based graph view with viewBox for zoom/pan
            const baseWidth = container.clientWidth;
            const baseHeight = container.clientHeight || 500;

            // Store base size for zoom calculations
            graphBaseSize = { width: baseWidth, height: baseHeight };

            // Use layout dimensions if provided (from relayoutGraph), otherwise use base
            const layoutWidth = window._layoutWidth || baseWidth;
            const layoutHeight = window._layoutHeight || baseHeight;
            const layoutOffsetX = window._layoutOffsetX || 0;
            const layoutOffsetY = window._layoutOffsetY || 0;
            // Clear the temporary layout dimensions
            delete window._layoutWidth;
            delete window._layoutHeight;
            delete window._layoutOffsetX;
            delete window._layoutOffsetY;

            // Assign positions if not set
            let needsLayout = false;
            for (const node of config.nodes) {
                if (!node.position) {
                    needsLayout = true;
                    break;
                }
            }

            if (needsLayout) {
                autoLayoutNodes(layoutWidth, layoutHeight, layoutOffsetX, layoutOffsetY);
            }

            // Calculate initial viewBox
            const viewWidth = baseWidth / graphZoom;
            const viewHeight = baseHeight / graphZoom;

            container.innerHTML = `
                <div class="graph-view" id="graphViewContainer">
                    <svg class="graph-svg" width="100%" height="100%" viewBox="${graphPan.x} ${graphPan.y} ${viewWidth} ${viewHeight}" preserveAspectRatio="xMidYMid meet">
                        <defs>
                            <marker id="arrowhead-rate" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#c9a86c"/>
                            </marker>
                            <marker id="arrowhead-weight" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#a87bc9"/>
                            </marker>
                            <marker id="arrowhead-value" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#6db385"/>
                            </marker>
                            <marker id="arrowhead-default" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#c4a67a"/>
                            </marker>
                            <marker id="arrowhead-duration" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#3a6b8b"/>
                            </marker>
                            <marker id="arrowhead-eligibility" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#e05252"/>
                            </marker>
                            <marker id="arrowhead-requires" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#5c9fd4"/>
                            </marker>
                            <marker id="arrowhead-replaces" markerWidth="12" markerHeight="10"
                                    refX="12" refY="5" orient="auto">
                                <polygon points="0 0, 12 5, 0 10" fill="#d45c8c"/>
                            </marker>
                            <marker id="arrowhead-incompat" markerWidth="14" markerHeight="14"
                                    refX="7" refY="7" orient="auto">
                                <circle cx="7" cy="7" r="6" fill="none" stroke="#c45c5c" stroke-width="1.5"/>
                                <line x1="3.5" y1="3.5" x2="10.5" y2="10.5" stroke="#c45c5c" stroke-width="1.5"/>
                            </marker>
                        </defs>
                        <g id="graphEdges">
                            ${renderGraphEdges()}
                        </g>
                        <g id="layerGroups">
                            ${renderLayerGroups()}
                        </g>
                        <g id="graphNodes">
                            ${renderGraphNodes()}
                        </g>
                        <g id="graphLabels">
                            ${renderGraphLabels()}
                        </g>
                    </svg>
                    <button class="graph-action-btn" id="relayoutBtn" onclick="relayoutGraph()" title="Re-organize nodes">
                        <span>â†» Re-layout</span>
                    </button>
                    <button class="balance-toggle" id="balanceToggle" onclick="toggleBalanceMode()">
                        <span class="balance-toggle-icon">âš–ï¸</span>
                        <span>Balance</span>
                    </button>
                    <div class="balance-legend">
                        <div class="balance-legend-title">Connection Density</div>
                        <div class="balance-legend-item">
                            <span class="balance-legend-swatch swatch-none"></span>
                            <span>Orphan (0)</span>
                        </div>
                        <div class="balance-legend-item">
                            <span class="balance-legend-swatch swatch-low"></span>
                            <span>Low (1-2)</span>
                        </div>
                        <div class="balance-legend-item">
                            <span class="balance-legend-swatch swatch-medium"></span>
                            <span>Medium (3-4)</span>
                        </div>
                        <div class="balance-legend-item">
                            <span class="balance-legend-swatch swatch-high"></span>
                            <span>High (5-6)</span>
                        </div>
                        <div class="balance-legend-item">
                            <span class="balance-legend-swatch swatch-hub"></span>
                            <span>Hub (7+)</span>
                        </div>
                    </div>
                    <div class="graph-bottom-right">
                    ${config.relationships.length > 0 ? `
                    <div class="graph-connections-panel" id="graphConnectionsPanel">
                        <div class="graph-connections-header" onclick="toggleGraphConnectionsPanel()">
                            <span class="graph-connections-title">All Connections (${config.relationships.length})</span>
                            <span class="graph-connections-toggle" id="graphConnectionsToggle">â–¼</span>
                        </div>
                        <div class="graph-connections-body" id="graphConnectionsBody">
                            ${config.relationships.map(rel => {
                                const source = config.nodes.find(n => n.id === rel.sourceId);
                                const target = config.nodes.find(n => n.id === rel.targetId);
                                const color = getRelationshipColor(rel.type);
                                const typeLabel = rel.type.replace(/_/g, ' ');
                                const valueStr = rel.config?.value != null ? ` ${rel.config.operation || ''} ${rel.config.value}` : '';
                                return `
                                    <div class="graph-connection-item" onclick="selectNode('${rel.sourceId}')" title="${typeLabel}${valueStr}">
                                        <span class="graph-connection-dot" style="background: ${color};"></span>
                                        <span class="graph-connection-label">${source?.name || rel.sourceId} â†’ ${target?.name || rel.targetId}</span>
                                        <span class="graph-connection-type" style="color: ${color};">${typeLabel.split(' ')[0]}</span>
                                        <button class="graph-connection-delete" onclick="event.stopPropagation(); deleteRelationship('${rel.id}')" title="Delete">Ã—</button>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}
                    <div class="graph-context-window" id="graphContextWindow">
                        <div class="graph-context-header" onclick="toggleGraphContext()">
                            <span class="graph-context-title">Connections</span>
                            <span class="graph-context-toggle" id="graphContextToggle">â–¼</span>
                        </div>
                        <div class="graph-context-body" id="graphContextBody">
                            <div class="graph-context-empty">Hover over a node to see connections</div>
                        </div>
                    </div>
                    <div class="rel-type-legend" id="relTypeLegend">
                        <div class="rel-type-legend-title">Connection Filters</div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('weight_influence') ? ' rel-type-hidden' : ''}" data-rel-type="weight_influence" onclick="toggleRelTypeFilter('weight_influence')">
                            <span class="rel-type-swatch" style="background: #a87bc9;"></span>
                            <span>Weight</span>
                        </div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('rate_modifier') ? ' rel-type-hidden' : ''}" data-rel-type="rate_modifier" onclick="toggleRelTypeFilter('rate_modifier')">
                            <span class="rel-type-swatch" style="background: #c9a86c;"></span>
                            <span>Rate</span>
                        </div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('value_modifier') ? ' rel-type-hidden' : ''}" data-rel-type="value_modifier" onclick="toggleRelTypeFilter('value_modifier')">
                            <span class="rel-type-swatch" style="background: #6db385;"></span>
                            <span>Value</span>
                        </div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('eligibility_gate') ? ' rel-type-hidden' : ''}" data-rel-type="eligibility_gate" onclick="toggleRelTypeFilter('eligibility_gate')">
                            <span class="rel-type-swatch" style="background: #e05252;"></span>
                            <span>Gate</span>
                        </div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('requires') ? ' rel-type-hidden' : ''}" data-rel-type="requires" onclick="toggleRelTypeFilter('requires')">
                            <span class="rel-type-swatch" style="background: #5c9fd4;"></span>
                            <span>Requires</span>
                        </div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('replaces') ? ' rel-type-hidden' : ''}" data-rel-type="replaces" onclick="toggleRelTypeFilter('replaces')">
                            <span class="rel-type-swatch" style="background: #d45c8c;"></span>
                            <span>Replaces</span>
                        </div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('duration_binding') ? ' rel-type-hidden' : ''}" data-rel-type="duration_binding" onclick="toggleRelTypeFilter('duration_binding')">
                            <span class="rel-type-swatch" style="background: #3a6b8b;"></span>
                            <span>Duration</span>
                        </div>
                        <div class="rel-type-legend-item${hiddenRelTypes.has('incompatible') ? ' rel-type-hidden' : ''}" data-rel-type="incompatible" onclick="toggleRelTypeFilter('incompatible')">
                            <span class="rel-type-swatch" style="background: #c45c5c; height: 2px; border-top: 1px dashed #c45c5c;"></span>
                            <span>Incompat</span>
                        </div>
                    </div>
                    </div><!-- .graph-bottom-right -->
                    <div class="graph-zoom-controls" id="graphZoomControls">
                        <button class="zoom-btn" onclick="zoomGraph(-0.1)" title="Zoom out">âˆ’</button>
                        <input type="range" id="graphZoomSlider" min="0.25" max="2" step="0.05" value="${graphZoom}"
                               onchange="zoomGraph(parseFloat(this.value) - graphZoom)"
                               oninput="zoomGraph(parseFloat(this.value) - graphZoom)">
                        <span id="graphZoomDisplay">${Math.round(graphZoom * 100)}%</span>
                        <button class="zoom-btn" onclick="zoomGraph(0.1)" title="Zoom in">+</button>
                        <button class="zoom-btn fit-btn" onclick="fitGraphToView()" title="Fit all nodes">âŠ¡</button>
                        <button class="zoom-btn" onclick="resetGraphView()" title="Reset view (100%)">â†º</button>
                    </div>
                </div>
            `;

            // Setup graph interactions
            setupGraphDrag();

            // Auto-relayout on first graph view (applies semi-circular layout)
            if (needsRelayout && config.nodes.length > 0) {
                needsRelayout = false;
                // Use setTimeout to ensure container dimensions are ready
                setTimeout(() => {
                    relayoutGraph();
                }, 50);
            }
            // Auto-fit to view on preset load (without full relayout)
            else if (needsFitToView) {
                needsFitToView = false;
                fitGraphToView();
            }

            // Re-apply relationship type filters
            if (hiddenRelTypes.size > 0) {
                applyRelTypeFilters();
            }
        }

        function showAddIncomingConnection(targetId) {
            const targetNode = config.nodes.find(n => n.id === targetId);
            if (!targetNode) return;

            // Find all relationship types where this node type is a valid target
            const allRelTypes = ['weight_influence', 'rate_modifier', 'value_modifier', 'eligibility_gate', 'requires', 'replaces', 'duration_binding'];
            const validRelTypes = allRelTypes.filter(rt => getValidTargetTypesForRel(rt).includes(targetNode.type));

            // Find all source types that can use those relationship types
            const validSourceTypes = new Set();
            const allSourceTypes = ['attribute', 'variable', 'trait', 'item', 'modifier', 'compound', 'action', 'derived', 'context'];
            allSourceTypes.forEach(st => {
                const sourceRelTypes = getValidRelTypesForSource(st);
                if (sourceRelTypes.some(rt => validRelTypes.includes(rt))) {
                    validSourceTypes.add(st);
                }
            });

            // Get all valid source nodes
            const validSources = config.nodes.filter(n => validSourceTypes.has(n.type) && n.id !== targetId);
            if (validSources.length === 0) {
                showToast('No valid source nodes available for this connection type', 'warning');
                return;
            }

            // Group sources by type
            const grouped = {};
            validSources.forEach(n => {
                if (!grouped[n.type]) grouped[n.type] = [];
                grouped[n.type].push(n);
            });

            // Build dropdown HTML
            let opts = '<option value="">-- Select source node --</option>';
            Object.entries(grouped).forEach(([type, nodes]) => {
                opts += `<optgroup label="${type}">`;
                nodes.forEach(n => { opts += `<option value="${n.id}">${n.name}</option>`; });
                opts += '</optgroup>';
            });

            // Replace button with inline picker
            const btn = event.target;
            const container = btn.parentElement;
            const picker = document.createElement('div');
            picker.style.cssText = 'margin-top: 0.5rem; display: flex; gap: 0.25rem; align-items: center;';
            picker.innerHTML = `
                <select style="flex: 1; font-size: 0.75rem;" onchange="if(this.value) { completeDragToConnect(this.value, '${targetId}'); this.parentElement.remove(); }">${opts}</select>
                <button class="btn btn-sm" onclick="this.parentElement.remove()" style="font-size: 0.7rem;">Cancel</button>
            `;
            btn.style.display = 'none';
            container.appendChild(picker);
            picker.querySelector('select').focus();
        }

        function toggleGraphConnectionsPanel() {
            const body = document.getElementById('graphConnectionsBody');
            const toggle = document.getElementById('graphConnectionsToggle');
            if (body && toggle) {
                body.classList.toggle('collapsed');
                toggle.textContent = body.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
            }
        }

        function toggleGraphContext() {
            const body = document.getElementById('graphContextBody');
            const toggle = document.getElementById('graphContextToggle');
            if (body && toggle) {
                body.classList.toggle('collapsed');
                toggle.textContent = body.classList.contains('collapsed') ? 'â–¶' : 'â–¼';
            }
        }

        let balanceModeActive = false;
        let graphZoom = 1;
        let graphPan = { x: 0, y: 0 };  // Pan offset in viewBox coordinates
        let graphPanDrag = { active: false, startX: 0, startY: 0 };  // Mouse-drag panning state
        let graphBaseSize = { width: 0, height: 0 };  // Original container size
        let needsFitToView = false;  // Set true on preset load to auto-fit after render
        let needsRelayout = true;    // Set true on load to trigger initial semi-circular layout
        let hiddenRelTypes = new Set();  // Relationship types hidden by filter

        function setGraphZoom(zoom, centerX, centerY) {
            const oldZoom = graphZoom;
            graphZoom = Math.max(0.25, Math.min(2, zoom));

            const svg = document.querySelector('.graph-svg');
            const container = document.getElementById('graphViewContainer');
            if (!svg || !container) return;

            // If center point provided, zoom toward that point
            if (centerX !== undefined && centerY !== undefined) {
                // Convert screen coords to viewBox coords before zoom
                const oldViewWidth = graphBaseSize.width / oldZoom;
                const oldViewHeight = graphBaseSize.height / oldZoom;

                // Point in viewBox coords
                const viewX = graphPan.x + (centerX / container.clientWidth) * oldViewWidth;
                const viewY = graphPan.y + (centerY / container.clientHeight) * oldViewHeight;

                // New view dimensions
                const newViewWidth = graphBaseSize.width / graphZoom;
                const newViewHeight = graphBaseSize.height / graphZoom;

                // Adjust pan so the point stays under the cursor
                graphPan.x = viewX - (centerX / container.clientWidth) * newViewWidth;
                graphPan.y = viewY - (centerY / container.clientHeight) * newViewHeight;
            }

            updateGraphViewBox();
            updateZoomDisplay();
        }

        function updateGraphViewBox() {
            const svg = document.querySelector('.graph-svg');
            if (!svg || graphBaseSize.width === 0) return;

            // Calculate viewBox dimensions based on zoom
            const viewWidth = graphBaseSize.width / graphZoom;
            const viewHeight = graphBaseSize.height / graphZoom;

            svg.setAttribute('viewBox', `${graphPan.x} ${graphPan.y} ${viewWidth} ${viewHeight}`);
        }

        function zoomGraph(delta) {
            // Zoom toward center of viewport
            const container = document.getElementById('graphViewContainer');
            if (container) {
                setGraphZoom(graphZoom + delta, container.clientWidth / 2, container.clientHeight / 2);
            } else {
                setGraphZoom(graphZoom + delta);
            }
        }

        function updateZoomDisplay() {
            const display = document.getElementById('graphZoomDisplay');
            if (display) {
                display.textContent = Math.round(graphZoom * 100) + '%';
            }
            const slider = document.getElementById('graphZoomSlider');
            if (slider) {
                slider.value = graphZoom;
            }
        }

        function fitGraphToView() {
            if (config.nodes.length === 0) {
                graphZoom = 1;
                graphPan = { x: 0, y: 0 };
                updateGraphViewBox();
                updateZoomDisplay();
                return;
            }

            // Calculate bounding box of all nodes
            const nodeWidth = 120;
            const nodeHeight = 40;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            config.nodes.forEach(node => {
                if (node.position) {
                    minX = Math.min(minX, node.position.x - nodeWidth/2);
                    minY = Math.min(minY, node.position.y - nodeHeight/2);
                    maxX = Math.max(maxX, node.position.x + nodeWidth/2);
                    maxY = Math.max(maxY, node.position.y + nodeHeight/2);
                }
            });

            if (minX === Infinity) {
                graphZoom = 1;
                graphPan = { x: 0, y: 0 };
                updateGraphViewBox();
                updateZoomDisplay();
                return;
            }

            const container = document.getElementById('graphViewContainer');
            if (!container) return;

            const padding = 60;
            const contentWidth = maxX - minX + padding * 2;
            const contentHeight = maxY - minY + padding * 2;

            const scaleX = graphBaseSize.width / contentWidth;
            const scaleY = graphBaseSize.height / contentHeight;
            graphZoom = Math.min(scaleX, scaleY, 1.5); // Cap at 1.5x
            graphZoom = Math.max(0.25, graphZoom); // Floor at 0.25x

            // Center the content
            const viewWidth = graphBaseSize.width / graphZoom;
            const viewHeight = graphBaseSize.height / graphZoom;
            const contentCenterX = (minX + maxX) / 2;
            const contentCenterY = (minY + maxY) / 2;

            graphPan.x = contentCenterX - viewWidth / 2;
            graphPan.y = contentCenterY - viewHeight / 2;

            updateGraphViewBox();
            updateZoomDisplay();
        }

        function toggleRelTypeFilter(type) {
            if (hiddenRelTypes.has(type)) {
                hiddenRelTypes.delete(type);
            } else {
                hiddenRelTypes.add(type);
            }
            // Update legend item appearance
            document.querySelectorAll('.rel-type-legend-item[data-rel-type]').forEach(item => {
                item.classList.toggle('rel-type-hidden', hiddenRelTypes.has(item.dataset.relType));
            });
            // Apply to edges
            applyRelTypeFilters();
        }

        function applyRelTypeFilters() {
            document.querySelectorAll('.graph-edge-group[data-rel-type]').forEach(g => {
                g.style.display = hiddenRelTypes.has(g.dataset.relType) ? 'none' : '';
            });
        }

        function relayoutGraph() {
            // Clear all node positions and re-layout
            // Use the visible area based on current zoom level to spread nodes appropriately
            const container = document.getElementById('graphViewContainer');
            const currentZoom = graphZoom;  // Preserve user's zoom level

            if (container) {
                // Calculate the visible area in graph coordinates based on zoom
                const viewWidth = graphBaseSize.width / graphZoom;
                const viewHeight = graphBaseSize.height / graphZoom;

                config.nodes.forEach(node => {
                    delete node.position;
                });

                // Store layout dimensions - layout from origin so we can center after
                window._layoutWidth = viewWidth;
                window._layoutHeight = viewHeight;
                window._layoutOffsetX = 0;
                window._layoutOffsetY = 0;
            } else {
                config.nodes.forEach(node => {
                    delete node.position;
                });
            }

            // Render first to apply new positions
            renderMainView();

            // Center the new layout while preserving zoom level
            setTimeout(() => {
                centerGraphOnNodes(currentZoom);
            }, 50);
        }

        function centerGraphOnNodes(preserveZoom = null) {
            // Center the view on all nodes without changing zoom
            if (config.nodes.length === 0) return;

            const nodeWidth = 120;
            const nodeHeight = 40;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            config.nodes.forEach(node => {
                if (node.position) {
                    minX = Math.min(minX, node.position.x - nodeWidth/2);
                    minY = Math.min(minY, node.position.y - nodeHeight/2);
                    maxX = Math.max(maxX, node.position.x + nodeWidth/2);
                    maxY = Math.max(maxY, node.position.y + nodeHeight/2);
                }
            });

            if (minX === Infinity) return;

            // Use preserved zoom or current zoom
            const zoom = preserveZoom !== null ? preserveZoom : graphZoom;
            graphZoom = zoom;

            // Calculate view dimensions at this zoom
            const viewWidth = graphBaseSize.width / graphZoom;
            const viewHeight = graphBaseSize.height / graphZoom;

            // Center on the content
            const contentCenterX = (minX + maxX) / 2;
            const contentCenterY = (minY + maxY) / 2;

            graphPan.x = contentCenterX - viewWidth / 2;
            graphPan.y = contentCenterY - viewHeight / 2;

            updateGraphViewBox();
            updateZoomDisplay();
        }

        function resetGraphView() {
            graphZoom = 1;

            // Center on nodes instead of resetting to origin
            if (config.nodes.length > 0) {
                const nodeWidth = 120;
                const nodeHeight = 40;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                config.nodes.forEach(node => {
                    if (node.position) {
                        minX = Math.min(minX, node.position.x - nodeWidth/2);
                        minY = Math.min(minY, node.position.y - nodeHeight/2);
                        maxX = Math.max(maxX, node.position.x + nodeWidth/2);
                        maxY = Math.max(maxY, node.position.y + nodeHeight/2);
                    }
                });

                if (minX !== Infinity) {
                    const viewWidth = graphBaseSize.width / graphZoom;
                    const viewHeight = graphBaseSize.height / graphZoom;
                    const contentCenterX = (minX + maxX) / 2;
                    const contentCenterY = (minY + maxY) / 2;
                    graphPan.x = contentCenterX - viewWidth / 2;
                    graphPan.y = contentCenterY - viewHeight / 2;
                } else {
                    graphPan = { x: 0, y: 0 };
                }
            } else {
                graphPan = { x: 0, y: 0 };
            }

            updateGraphViewBox();
            updateZoomDisplay();
        }

        function toggleBalanceMode() {
            balanceModeActive = !balanceModeActive;
            const container = document.getElementById('graphViewContainer');
            const toggle = document.getElementById('balanceToggle');

            if (container) {
                if (balanceModeActive) {
                    container.classList.add('balance-mode');
                } else {
                    container.classList.remove('balance-mode');
                }
            }

            if (toggle) {
                if (balanceModeActive) {
                    toggle.classList.add('active');
                } else {
                    toggle.classList.remove('active');
                }
            }
        }

        function updateGraphContextWindow(nodeId) {
            const body = document.getElementById('graphContextBody');
            if (!body) return;

            if (!nodeId) {
                body.innerHTML = '<div class="graph-context-empty">Hover over a node to see connections</div>';
                return;
            }

            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Get relationships involving this node
            const outgoing = config.relationships.filter(r => r.sourceId === nodeId);
            const incoming = config.relationships.filter(r => r.targetId === nodeId);

            let html = `
                <div class="graph-context-node">
                    <div class="graph-context-node-name">${node.name}</div>
                    <div class="graph-context-node-type">${node.type}</div>
            `;

            // Show compound requirements if applicable
            if (node.type === 'compound' && node.config?.requires) {
                const logic = node.config.requirementLogic || 'all';
                const requiredNodes = node.config.requires.map(req => {
                    const nodeId = getRequiredNodeId(req);
                    const reqNode = config.nodes.find(n => n.id === nodeId);
                    return reqNode ? reqNode.name : nodeId;
                });
                html += `
                    <div class="graph-context-compound">
                        <div class="graph-context-compound-label">Requires ${logic === 'any' ? 'any of' : 'all of'}:</div>
                        <div class="graph-context-compound-items">
                            ${requiredNodes.map(name => `<span class="graph-context-compound-item">${name}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            // Show outgoing relationships
            if (outgoing.length > 0) {
                html += '<div style="margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">Affects:</div>';
                outgoing.forEach(rel => {
                    const target = config.nodes.find(n => n.id === rel.targetId);
                    const typeClass = rel.type === 'rate_modifier' ? 'rate' : (rel.type === 'weight_influence' ? 'weight' : (rel.type === 'duration_binding' ? 'duration' : 'value'));
                    const opSymbol = rel.config?.operation === 'multiply' ? 'Ã—' : (rel.config?.value >= 0 ? '+' : '');
                    html += `
                        <div class="graph-context-rel">
                            <span class="graph-context-rel-type ${typeClass}">${rel.type.replace('_', ' ')}</span>
                            â†’ ${target?.name || rel.targetId} (${opSymbol}${rel.config?.value || 0})
                        </div>
                    `;
                });
            }

            // Show incoming relationships
            if (incoming.length > 0) {
                html += '<div style="margin-top: 0.5rem; font-size: 0.7rem; color: var(--text-muted); margin-bottom: 0.25rem;">Affected by:</div>';
                incoming.forEach(rel => {
                    const source = config.nodes.find(n => n.id === rel.sourceId);
                    const typeClass = rel.type === 'rate_modifier' ? 'rate' : (rel.type === 'weight_influence' ? 'weight' : (rel.type === 'duration_binding' ? 'duration' : 'value'));
                    const opSymbol = rel.config?.operation === 'multiply' ? 'Ã—' : (rel.config?.value >= 0 ? '+' : '');
                    html += `
                        <div class="graph-context-rel">
                            <span class="graph-context-rel-type ${typeClass}">${rel.type.replace('_', ' ')}</span>
                            â† ${source?.name || rel.sourceId} (${opSymbol}${rel.config?.value || 0})
                        </div>
                    `;
                });
            }

            // Show incompatibilities
            const incompatibles = node.config?.incompatibleWith || [];
            if (incompatibles.length > 0) {
                html += '<div style="margin-top: 0.5rem; font-size: 0.7rem; color: #c45c5c; margin-bottom: 0.25rem;">âŠ˜ Incompatible with:</div>';
                incompatibles.forEach(incompId => {
                    const incompNode = config.nodes.find(n => n.id === incompId);
                    html += `
                        <div class="graph-context-rel graph-context-incompat">
                            <span class="graph-context-rel-type incompat">mutual exclusion</span>
                            â†” ${incompNode?.name || incompId}
                        </div>
                    `;
                });
            }

            if (outgoing.length === 0 && incoming.length === 0 && incompatibles.length === 0 && node.type !== 'compound') {
                html += '<div class="graph-context-empty">No connections</div>';
            }

            html += '</div>';
            body.innerHTML = html;
        }

        function getNodeConnectionCount(nodeId) {
            // Count all relationships where this node is source or target
            let count = 0;
            config.relationships.forEach(rel => {
                if (rel.sourceId === nodeId || rel.targetId === nodeId) {
                    count++;
                }
            });

            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return count;

            // For layers: count items that belong to this layer (via config.layerId or layer.config.itemIds)
            if (node.type === 'layer') {
                config.nodes.forEach(n => {
                    if (n.config?.layerId === nodeId) {
                        count++;
                    }
                });
                // Also count items in itemIds array
                if (node.config?.itemIds) {
                    count += node.config.itemIds.length;
                }
            }

            // For items/traits: count connection to parent layer
            if (node.config?.layerId) {
                count++;
            }

            // Check if this node is in any layer's itemIds
            config.nodes.forEach(layer => {
                if (layer.type === 'layer' && layer.config?.itemIds?.includes(nodeId)) {
                    count++;
                }
            });

            // For compounds: count required nodes (handling object format)
            if (node.type === 'compound' && node.config?.requires) {
                node.config.requires.forEach(req => {
                    // Count valid requirements (not condition-based)
                    if (typeof req === 'string') {
                        count++;
                    } else if (typeof req === 'object' && !req.condition) {
                        count++;
                    }
                });
            }

            // Check if this node is required by any compounds (handling object format)
            config.nodes.forEach(n => {
                if (n.type === 'compound' && n.config?.requires) {
                    n.config.requires.forEach(req => {
                        const reqId = typeof req === 'string' ? req :
                            (req.item || req.modifier || req.trait || req.attribute || req.variable || req.id);
                        if (reqId === nodeId) {
                            count++;
                        }
                    });
                }
            });

            return count;
        }

        function getDensityClass(count) {
            if (count === 0) return 'density-none';
            if (count <= 2) return 'density-low';
            if (count <= 4) return 'density-medium';
            if (count <= 6) return 'density-high';
            return 'density-hub';
        }

        function renderLayerGroups() {
            const layers = config.nodes.filter(n => n.type === 'layer');
            if (layers.length === 0) return '';

            const padding = 20;
            const nodeHalfW = 50;
            const nodeHalfH = 15;

            return layers.map(layer => {
                // Find traits belonging to this layer
                const traits = config.nodes.filter(n =>
                    (n.type === 'trait' || n.type === 'item') && n.config?.layerId === layer.id
                );

                // Collect all nodes in this group (layer + its traits)
                const groupNodes = [layer, ...traits].filter(n => n.position);
                if (groupNodes.length < 2) return ''; // need layer + at least 1 trait

                // Calculate bounding box
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                groupNodes.forEach(n => {
                    const x = n.position.x;
                    const y = n.position.y;
                    minX = Math.min(minX, x - nodeHalfW);
                    minY = Math.min(minY, y - nodeHalfH);
                    maxX = Math.max(maxX, x + nodeHalfW);
                    maxY = Math.max(maxY, y + nodeHalfH);
                });

                // Add padding
                minX -= padding;
                minY -= padding - 4; // extra top space for label
                maxX += padding;
                maxY += padding;

                const color = getNodeColor('layer');
                const width = maxX - minX;
                const height = maxY - minY;

                return `
                    <g class="layer-group" data-layer-id="${layer.id}">
                        <rect x="${minX}" y="${minY}" width="${width}" height="${height}"
                              rx="8" ry="8"
                              fill="${color}" fill-opacity="0.08"
                              stroke="${color}" stroke-opacity="0.25"
                              stroke-width="1" stroke-dasharray="6 3"/>
                        <text x="${minX + 8}" y="${minY + 12}"
                              font-size="9" fill="${color}" fill-opacity="0.5"
                              font-family="Raleway, sans-serif">${layer.name}</text>
                    </g>
                `;
            }).join('');
        }

        function renderGraphNodes() {
            return config.nodes.map(node => {
                const x = node.position?.x || 100;
                const y = node.position?.y || 100;
                const color = getNodeColor(node.type);
                const connectionCount = getNodeConnectionCount(node.id);
                const densityClass = getDensityClass(connectionCount);

                // Check for incompatibilities
                const incompatCount = (node.config?.incompatibleWith || []).length;
                const hasIncompat = incompatCount > 0;

                return `
                    <g class="graph-node ${selectedNodeId === node.id ? 'selected' : ''} ${hasIncompat ? 'has-incompat' : ''}"
                       data-id="${node.id}"
                       data-connections="${connectionCount}"
                       data-incompats="${incompatCount}"
                       transform="translate(${x}, ${y})"
                       onclick="handleGraphNodeClick('${node.id}', event)">
                        <rect class="density-ring ${densityClass}" x="-54" y="-19" width="108" height="38" rx="6"/>
                        <rect x="-50" y="-15" width="100" height="30"
                              style="stroke: ${color}"/>
                        <text x="0" y="4" text-anchor="middle">${node.name}</text>
                        <g class="connection-badge" transform="translate(42, -12)">
                            <circle r="8"/>
                            <text x="0" y="3" text-anchor="middle">${connectionCount}</text>
                        </g>
                    </g>
                `;
            }).join('');
        }

        // Helper to calculate edge endpoint at node boundary
        function getEdgeEndpoint(centerX, centerY, targetX, targetY, nodeWidth, nodeHeight) {
            const dx = targetX - centerX;
            const dy = targetY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return { x: centerX, y: centerY };

            // Calculate intersection with node rectangle
            const halfW = nodeWidth / 2;
            const halfH = nodeHeight / 2;

            // Find t where the line crosses the rectangle boundary
            const tX = halfW / Math.abs(dx);
            const tY = halfH / Math.abs(dy);
            const t = Math.min(tX, tY);

            return {
                x: centerX + dx * t,
                y: centerY + dy * t
            };
        }

        function renderGraphLabels() {
            // Render white text labels above node type columns
            // Skip layer-group columns (layers/items/traits) - they're self-descriptive
            const labelMap = {
                'attribute': 'ATTRIBUTES',
                'variable': 'VARIABLES',
                'modifier': 'MODIFIERS',
                'compound': 'COMPOUNDS',
                'derived': 'DERIVED VALUES',
                'ticksystem': 'TICK SYSTEMS',
                'context': 'CONTEXT',
                'action': 'ACTIONS'
            };

            const labels = [];
            for (const [type, label] of Object.entries(labelMap)) {
                const nodesOfType = config.nodes.filter(n => n.type === type && n.position);
                if (nodesOfType.length === 0) continue;

                // Find center X and min Y of nodes of this type
                let minX = Infinity, maxX = -Infinity, minY = Infinity;
                nodesOfType.forEach(n => {
                    minX = Math.min(minX, n.position.x);
                    maxX = Math.max(maxX, n.position.x);
                    minY = Math.min(minY, n.position.y);
                });

                const centerX = (minX + maxX) / 2;
                const labelY = minY - 30;

                labels.push(`<text x="${centerX}" y="${labelY}" text-anchor="middle"
                    fill="rgba(255,255,255,0.45)" font-size="11" font-family="Raleway, sans-serif"
                    font-weight="600" letter-spacing="1.5">${label}</text>`);
            }
            return labels.join('\n');
        }

        function renderGraphEdges() {
            const nodeWidth = 120;  // Approximate node width
            const nodeHeight = 36;  // Approximate node height

            // Build index of edges per source for delete button offset
            const edgesBySource = {};
            config.relationships.forEach(rel => {
                if (!edgesBySource[rel.sourceId]) edgesBySource[rel.sourceId] = [];
                edgesBySource[rel.sourceId].push(rel.id);
            });

            // Render regular relationship edges
            const relationshipEdges = config.relationships.map(rel => {
                const source = config.nodes.find(n => n.id === rel.sourceId);
                const target = config.nodes.find(n => n.id === rel.targetId);
                if (!source || !target) return '';

                const srcX = source.position?.x || 100;
                const srcY = source.position?.y || 100;
                const tgtX = target.position?.x || 200;
                const tgtY = target.position?.y || 200;

                // Calculate endpoints at node boundaries (not centers)
                const startPt = getEdgeEndpoint(srcX, srcY, tgtX, tgtY, nodeWidth, nodeHeight);
                const rawEndPt = getEdgeEndpoint(tgtX, tgtY, srcX, srcY, nodeWidth, nodeHeight);

                // Pull the end point back by arrow length so arrow tip touches node edge
                const arrowLength = 12;
                const edgeDx = rawEndPt.x - startPt.x;
                const edgeDy = rawEndPt.y - startPt.y;
                const edgeLen = Math.sqrt(edgeDx * edgeDx + edgeDy * edgeDy);
                const endPt = edgeLen > arrowLength ? {
                    x: rawEndPt.x - (edgeDx / edgeLen) * arrowLength,
                    y: rawEndPt.y - (edgeDy / edgeLen) * arrowLength
                } : rawEndPt;

                // Color and arrowhead based on relationship type
                const edgeColor = getRelationshipColor(rel.type);
                const arrowheadId = getArrowheadId(rel.type);

                // Calculate delete button position (30% along edge, with perpendicular offset for shared-source edges)
                const btnT = 0.3;
                let btnX = startPt.x + (endPt.x - startPt.x) * btnT;
                let btnY = startPt.y + (endPt.y - startPt.y) * btnT;
                const siblingEdges = edgesBySource[rel.sourceId] || [];
                if (siblingEdges.length > 1 && edgeLen > 0) {
                    const edgeIdx = siblingEdges.indexOf(rel.id);
                    const perpOffset = (edgeIdx - (siblingEdges.length - 1) / 2) * 12;
                    btnX += (-edgeDy / edgeLen) * perpOffset;
                    btnY += (edgeDx / edgeLen) * perpOffset;
                }

                return `
                    <g class="graph-edge-group" data-rel-id="${rel.id}" data-rel-type="${rel.type}">
                        <line class="graph-edge-hitarea"
                              data-source="${rel.sourceId}"
                              data-target="${rel.targetId}"
                              data-rel-id="${rel.id}"
                              x1="${startPt.x}" y1="${startPt.y}"
                              x2="${endPt.x}" y2="${endPt.y}"/>
                        <line class="graph-edge"
                              data-source="${rel.sourceId}"
                              data-target="${rel.targetId}"
                              data-rel-id="${rel.id}"
                              x1="${startPt.x}" y1="${startPt.y}"
                              x2="${endPt.x}" y2="${endPt.y}"
                              style="stroke: ${edgeColor}; marker-end: url(#${arrowheadId})"/>
                        <line class="edge-flow-path"
                              x1="${startPt.x}" y1="${startPt.y}"
                              x2="${endPt.x}" y2="${endPt.y}"
                              style="stroke: ${edgeColor};"/>
                        <g class="edge-delete-btn" transform="translate(${btnX}, ${btnY})" onclick="event.stopPropagation(); deleteRelationshipFromGraph('${rel.id}')">
                            <circle r="10" fill="#1a1a1a" stroke="var(--accent-error)" stroke-width="1.5"/>
                            <text x="0" y="4" text-anchor="middle" fill="var(--accent-error)" font-size="12" font-weight="bold">Ã—</text>
                        </g>
                    </g>
                `;
            }).join('');

            // Render incompatibility edges (dashed red lines, no duplicates)
            const incompatEdges = [];
            const renderedPairs = new Set();

            config.nodes.forEach(node => {
                const incompatList = node.config?.incompatibleWith || [];
                incompatList.forEach(targetId => {
                    // Create a consistent key to avoid rendering both directions
                    const pairKey = [node.id, targetId].sort().join('|');
                    if (renderedPairs.has(pairKey)) return;
                    renderedPairs.add(pairKey);

                    const target = config.nodes.find(n => n.id === targetId);
                    if (!target) return;

                    const srcX = node.position?.x || 100;
                    const srcY = node.position?.y || 100;
                    const tgtX = target.position?.x || 200;
                    const tgtY = target.position?.y || 200;

                    const startPt = getEdgeEndpoint(srcX, srcY, tgtX, tgtY, nodeWidth, nodeHeight);
                    const endPt = getEdgeEndpoint(tgtX, tgtY, srcX, srcY, nodeWidth, nodeHeight);

                    incompatEdges.push(`
                        <g class="graph-edge-group graph-incompat-group" data-incompat="${node.id}|${targetId}" data-rel-type="incompatible">
                            <line class="graph-edge-hitarea graph-incompat-hitarea"
                                  data-source="${node.id}"
                                  data-target="${targetId}"
                                  data-incompat="true"
                                  x1="${startPt.x}" y1="${startPt.y}"
                                  x2="${endPt.x}" y2="${endPt.y}"/>
                            <line class="graph-edge graph-incompat-edge"
                                  data-source="${node.id}"
                                  data-target="${targetId}"
                                  data-incompat="true"
                                  x1="${startPt.x}" y1="${startPt.y}"
                                  x2="${endPt.x}" y2="${endPt.y}"/>
                        </g>
                    `);
                });
            });

            // Render duration binding edges (dashed blue lines)
            const durationEdges = [];
            config.nodes.filter(n => n.type === 'modifier').forEach(modifier => {
                const tickBindings = modifier.config?.tickBindings || [];
                tickBindings.forEach(binding => {
                    const tickSystem = config.nodes.find(n => n.id === binding.tickSystemId);
                    if (!tickSystem) return;

                    const srcX = modifier.position?.x || 100;
                    const srcY = modifier.position?.y || 100;
                    const tgtX = tickSystem.position?.x || 200;
                    const tgtY = tickSystem.position?.y || 200;

                    const startPt = getEdgeEndpoint(srcX, srcY, tgtX, tgtY, nodeWidth, nodeHeight);
                    const endPt = getEdgeEndpoint(tgtX, tgtY, srcX, srcY, nodeWidth, nodeHeight);

                    // Calculate midpoint for label
                    const midX = (startPt.x + endPt.x) / 2;
                    const midY = (startPt.y + endPt.y) / 2;

                    const tickLabel = tickSystem.config?.tickUnit?.label || 'tick';

                    durationEdges.push(`
                        <g class="graph-edge-group graph-duration-group" data-duration="${modifier.id}|${binding.tickSystemId}" data-rel-type="duration_binding">
                            <line class="graph-edge-hitarea"
                                  data-source="${modifier.id}"
                                  data-target="${binding.tickSystemId}"
                                  data-duration="true"
                                  x1="${startPt.x}" y1="${startPt.y}"
                                  x2="${endPt.x}" y2="${endPt.y}"/>
                            <line class="graph-edge graph-duration-edge"
                                  data-source="${modifier.id}"
                                  data-target="${binding.tickSystemId}"
                                  data-duration="true"
                                  x1="${startPt.x}" y1="${startPt.y}"
                                  x2="${endPt.x}" y2="${endPt.y}"/>
                            <text class="graph-duration-label" x="${midX}" y="${midY - 5}">
                                ${binding.duration} ${tickLabel}${binding.duration !== 1 ? 's' : ''}
                            </text>
                        </g>
                    `);
                });
            });

            return relationshipEdges + incompatEdges.join('') + durationEdges.join('');
        }

        function getArrowheadId(type) {
            switch (type) {
                case 'weight_influence': return 'arrowhead-weight';
                case 'rate_modifier': return 'arrowhead-rate';
                case 'value_modifier': return 'arrowhead-value';
                case 'eligibility_gate': return 'arrowhead-eligibility';
                case 'requires': return 'arrowhead-requires';
                case 'replaces': return 'arrowhead-replaces';
                case 'duration_binding': return 'arrowhead-duration';
                default: return 'arrowhead-default';
            }
        }

        function getRelationshipColor(type) {
            switch (type) {
                case 'weight_influence': return '#a87bc9';   // purple - affects selection weights
                case 'rate_modifier': return '#c9a86c';      // orange - affects variable rates
                case 'value_modifier': return '#6db385';     // green - directly modifies values
                case 'eligibility_gate': return '#e05252';   // red - blocks selection
                case 'requires': return '#5c9fd4';           // light blue - compound requirements
                case 'replaces': return '#d45c8c';           // pink - state replacement
                case 'duration_binding': return '#3a6b8b';   // dark blue - tick system binding
                default: return '#c4a67a';                   // fallback warm tan
            }
        }

        // Relationship type legend for reference
        const RELATIONSHIP_TYPE_INFO = {
            weight_influence: { color: '#a87bc9', label: 'Weight', desc: 'Affects selection probability' },
            rate_modifier: { color: '#c9a86c', label: 'Rate', desc: 'Affects variable change speed' },
            value_modifier: { color: '#6db385', label: 'Value', desc: 'Modifies numeric values' },
            eligibility_gate: { color: '#e05252', label: 'Gate', desc: 'Blocks selection' },
            requires: { color: '#5c9fd4', label: 'Requires', desc: 'Compound requirement' },
            replaces: { color: '#d45c8c', label: 'Replaces', desc: 'Deactivates target' },
            duration_binding: { color: '#3a6b8b', label: 'Duration', desc: 'Tick system binding' }
        };

        // ========================================
        // PREVIEW / SIMULATION
        // ========================================
        let previewEntities = [];
        let previewHistory = [];
        let previewTickStates = {}; // { tickSystemId: { active: bool, currentTick: number } }
        let previewTickIntervals = {}; // For timed tick systems

        // Attribute simulator state (for "what-if" probability preview)
        let simulatorValues = {}; // { attrId: value }
        let simulatorExpanded = true; // Default expanded so users see the interactive features

        // Spawn Simulator state - represents a "preview entity" that isn't actually spawned
        let spawnSimState = {
            dirty: false,           // True when settings changed since last refresh
            traits: [],             // Manually added/rolled traits: [{ id, name, layerName, locked }]
            modifiers: [],          // Active modifiers: [{ id, name, locked }]
            variables: {},          // Rolled variable values: { varId: { value, locked } }
            presetId: '',           // Selected preset
            lastRefreshed: null     // Timestamp of last refresh
        };

        // Spawned entities in Spawn Logic tab (separate from previewEntities in Entities tab)
        let spawnLogicEntities = [];

        // Tab state for spawn logic right panel
        let spawnLogicActiveTab = 'probabilities'; // 'probabilities' | 'entities' (kept for spawn mode sub-tabs)
        let simulationMode = 'spawn'; // 'spawn' | 'state'
        let selectedSpawnEntityId = null;
        let savedNewSpawnValues = null; // Saved simulatorValues when switching to entity/state view

        function markSpawnSimDirty() {
            spawnSimState.dirty = true;
            updateSpawnSimWarning();
        }

        function updateSpawnSimWarning() {
            const warning = document.getElementById('spawnSimWarning');
            if (warning) {
                warning.style.display = spawnSimState.dirty ? 'flex' : 'none';
            }
        }

        function refreshSpawnSim() {
            // Re-roll in hierarchical order: attributes â†’ variables â†’ modifiers â†’ traits
            spawnSimState.dirty = false;
            spawnSimState.lastRefreshed = Date.now();

            // Keep locked items
            const lockedTraits = spawnSimState.traits.filter(t => t.locked);
            const lockedModifiers = spawnSimState.modifiers.filter(m => m.locked);
            const lockedVarIds = Object.keys(spawnSimState.variables).filter(
                vId => spawnSimState.variables[vId]?.locked
            );

            // 1. Roll variables (use initialRange if available)
            const variables = config.nodes.filter(n => n.type === 'variable');
            const newVariables = {};
            variables.forEach(v => {
                if (lockedVarIds.includes(v.id)) {
                    // Keep locked variable value
                    newVariables[v.id] = spawnSimState.variables[v.id];
                } else {
                    // Roll from initialRange or fall back to initial/startValue
                    const cfg = v.config || {};
                    let value;
                    if (cfg.initialRange && Array.isArray(cfg.initialRange) && cfg.initialRange.length === 2) {
                        const [minR, maxR] = cfg.initialRange;
                        value = minR + Math.floor(Math.random() * (maxR - minR + 1));
                    } else {
                        value = cfg.initial ?? cfg.startValue ?? cfg.max ?? 100;
                    }
                    newVariables[v.id] = { value, locked: false };
                }
            });
            spawnSimState.variables = newVariables;

            // 2. Get probabilities with current simulator values (attributes)
            const probabilities = calculateSpawnProbabilities(spawnSimState.presetId);

            // 3. Roll new traits for each layer
            const newTraits = [...lockedTraits];
            probabilities.forEach(layer => {
                // Skip if we have a locked trait from this layer
                if (lockedTraits.some(t => layer.traits.find(lt => lt.id === t.id))) {
                    return;
                }

                // Roll based on probabilities
                const rolled = rollFromProbabilities(layer.traits, layer.rollRange);
                rolled.forEach(t => {
                    newTraits.push({
                        id: t.id,
                        name: t.name,
                        layerName: layer.layer,
                        locked: false
                    });
                });
            });

            spawnSimState.traits = newTraits;
            spawnSimState.modifiers = lockedModifiers;

            // Actually update the DOM
            const body = document.getElementById('spawnSimBody');
            if (body) {
                body.innerHTML = renderSpawnSimBody();
            }
            updateSpawnSimWarning();
        }

        function rollFromProbabilities(traits, rollRange) {
            if (traits.length === 0) return [];

            const numRolls = rollRange[0] === rollRange[1] ?
                rollRange[0] :
                rollRange[0] + Math.floor(Math.random() * (rollRange[1] - rollRange[0] + 1));

            const results = [];
            const available = [...traits];

            for (let i = 0; i < numRolls && available.length > 0; i++) {
                const totalWeight = available.reduce((sum, t) => sum + (t.weight || 1), 0);
                let roll = Math.random() * totalWeight;

                for (let j = 0; j < available.length; j++) {
                    roll -= available[j].weight || 1;
                    if (roll <= 0) {
                        results.push(available[j]);
                        available.splice(j, 1);
                        break;
                    }
                }
            }

            return results;
        }

        function toggleTraitLock(traitId) {
            const trait = spawnSimState.traits.find(t => t.id === traitId);
            if (trait) {
                trait.locked = !trait.locked;
                updateSpawnSimDOM();
            }
        }

        // Helper to update spawn sim DOM
        function updateSpawnSimDOM() {
            const body = document.getElementById('spawnSimBody');
            if (body) {
                body.innerHTML = renderSpawnSimBody();
            }
        }

        function removeSimTrait(traitId) {
            spawnSimState.traits = spawnSimState.traits.filter(t => t.id !== traitId);
            markSpawnSimDirty();
            updateSpawnSimDOM();
        }

        function addSimTrait(traitId) {
            const trait = config.nodes.find(n => n.id === traitId);
            if (!trait) return;

            const layer = config.nodes.find(n => n.id === trait.config?.layerId);

            // Check if already has trait from same layer (if layer is single-select)
            // For now, just add it
            if (!spawnSimState.traits.some(t => t.id === traitId)) {
                spawnSimState.traits.push({
                    id: traitId,
                    name: trait.name,
                    layerName: layer?.name || 'Unknown',
                    locked: true // Manually added = locked
                });
                updateSpawnSimDOM();
            }
        }

        function removeSimModifier(modId) {
            spawnSimState.modifiers = spawnSimState.modifiers.filter(m => m.id !== modId);
            updateSpawnSimDOM();
        }

        function addSimModifier(modId) {
            const mod = config.nodes.find(n => n.id === modId);
            if (!mod) return;

            if (!spawnSimState.modifiers.some(m => m.id === modId)) {
                spawnSimState.modifiers.push({
                    id: modId,
                    name: mod.name,
                    locked: true
                });
                updateSpawnSimDOM();
            }
        }

        function toggleVariableLock(varId) {
            if (spawnSimState.variables[varId]) {
                spawnSimState.variables[varId].locked = !spawnSimState.variables[varId].locked;
                updateSpawnSimDOM();
            }
        }

        function updateSimVariable(varId, value) {
            if (!spawnSimState.variables[varId]) {
                spawnSimState.variables[varId] = { value: parseInt(value), locked: false };
            } else {
                spawnSimState.variables[varId].value = parseInt(value);
            }
            // Update simulator values cache so probabilities recalculate
            simulatorValues[varId] = parseInt(value);
            // Update threshold-triggered modifiers display
            updateSpawnSimDOM();
            // Update probability panel to reflect variable influence on weights
            updateProbabilityPanel();
        }

        function setSpawnSimPreset(presetId) {
            spawnSimState.presetId = presetId;
            markSpawnSimDirty();
            updateProbabilityPanel();
        }

        function getSimulatorValues() {
            // Initialize simulator values from attributes if not set
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            attributes.forEach(attr => {
                if (simulatorValues[attr.id] === undefined) {
                    const min = attr.config?.min ?? 1;
                    const max = attr.config?.max ?? 10;
                    simulatorValues[attr.id] = Math.round((min + max) / 2);
                }
            });

            // Also include variable values from spawn sim state
            const variables = config.nodes.filter(n => n.type === 'variable');
            variables.forEach(v => {
                if (spawnSimState.variables[v.id] !== undefined) {
                    simulatorValues[v.id] = spawnSimState.variables[v.id].value;
                } else if (simulatorValues[v.id] === undefined) {
                    // Use default/initial value
                    const defaultVal = v.config?.default ?? v.config?.defaultValue ??
                        v.config?.initialRange?.[0] ?? v.config?.min ?? 0;
                    simulatorValues[v.id] = defaultVal;
                }
            });

            return simulatorValues;
        }

        // Track which attribute is being actively adjusted
        window._activeSimulatorAttr = null;

        function updateSimulatorValue(attrId, value) {
            window._activeSimulatorAttr = attrId;
            simulatorValues[attrId] = parseFloat(value);

            // Update the slider display value
            const row = document.querySelector(`.preview-slider-row[data-attr-id="${attrId}"]`);
            if (row) {
                const valueSpan = row.querySelector('.preview-slider-value');
                if (valueSpan) valueSpan.textContent = value;
            }

            // Update the unified preview (recalculates probabilities)
            updateUnifiedPreview();

            // Also update legacy probability panel if it exists
            updateProbabilityPanel();

            // Highlight the affected traits briefly
            highlightAffectedTraits(attrId);
        }

        function highlightAffectedTraits(attrId) {
            // Find traits affected by this attribute
            const affectedTraitIds = config.relationships
                .filter(r => r.type === 'weight_influence' && r.sourceId === attrId)
                .map(r => r.targetId);

            // Add pulse animation to affected trait rows
            affectedTraitIds.forEach(traitId => {
                // New expandable trait items - find the row inside the item
                const traitItem = document.querySelector(`.prob-trait-item[data-trait-id="${traitId}"]`);
                if (traitItem) {
                    const row = traitItem.querySelector('.prob-trait-row');
                    if (row) {
                        row.classList.add('highlighted', 'pulsing');
                        setTimeout(() => row.classList.remove('pulsing'), 500);
                    }
                }
                // Legacy selectors for backwards compat
                const legacyRow = document.querySelector(`.prob-trait-row[data-trait-id="${traitId}"]`);
                if (legacyRow) {
                    legacyRow.classList.add('highlighted', 'pulsing');
                    setTimeout(() => legacyRow.classList.remove('pulsing'), 500);
                }
            });

            // Clear highlight after a delay (unless still dragging)
            clearTimeout(window._highlightTimeout);
            window._highlightTimeout = setTimeout(() => {
                window._activeSimulatorAttr = null;
                document.querySelectorAll('.prob-trait-row.highlighted').forEach(el => {
                    el.classList.remove('highlighted');
                });
            }, 1000);
        }

        function resetSimulatorValues() {
            simulatorValues = {};
            window._activeSimulatorAttr = null;
            getSimulatorValues();
            updateProbabilityPanel();
            renderSimulatorContent();
        }

        function toggleSimulator() {
            simulatorExpanded = !simulatorExpanded;
            const panel = document.querySelector('.attribute-simulator-panel');
            if (panel) panel.classList.toggle('expanded', simulatorExpanded);
        }

        function renderSimulatorContent() {
            // Legacy function - now handled by renderSpawnSimBody()
            // Just update the spawn sim body if it exists
            const body = document.getElementById('spawnSimBody');
            if (body) {
                body.innerHTML = renderSpawnSimBody();
            }
        }

        // Preview which traits an attribute affects (on hover)
        function previewAttributeInfluences(attrId) {
            const affectedTraitIds = config.relationships
                .filter(r => r.type === 'weight_influence' && r.sourceId === attrId)
                .map(r => r.targetId);

            affectedTraitIds.forEach(traitId => {
                // Unified preview rows
                const newRow = document.querySelector(`.preview-trait-row[data-trait-id="${traitId}"]`);
                if (newRow) newRow.classList.add('highlighted');
                // Legacy rows
                const oldRow = document.querySelector(`.prob-trait-row[data-trait-id="${traitId}"]`);
                if (oldRow) oldRow.classList.add('highlighted');
            });

            // Highlight the slider row
            const sliderRow = document.querySelector(`.preview-slider-row[data-attr-id="${attrId}"]`);
            if (sliderRow) sliderRow.classList.add('active-influence');
        }

        function clearAttributeInfluencePreview() {
            document.querySelectorAll('.preview-trait-row.highlighted, .prob-trait-row.highlighted').forEach(el => {
                el.classList.remove('highlighted');
            });
            document.querySelectorAll('.preview-slider-row.active-influence, .sim-attr-row.active-influence').forEach(el => {
                el.classList.remove('active-influence');
            });
        }

        // ========================================
        // SIMULATION VIEW (replaces Spawn Logic)
        // Two modes: Spawn Mode + State Mode
        // ========================================

        function renderSimulationView(container) {
            const entityPresets = config.presets || [];
            const selectedEntity = (simulationMode === 'state' && selectedSpawnEntityId)
                ? spawnLogicEntities.find(e => e.id === selectedSpawnEntityId)
                : null;

            const isStateMode = simulationMode === 'state' && selectedEntity;

            container.innerHTML = `
                <div class="simulation-view">
                    <!-- Header -->
                    <div class="simulation-header">
                        ${isStateMode ? `
                            <button class="entity-detail-back" onclick="exitStateMode()" title="Back to spawn preview">
                                â† Back
                            </button>
                            <span class="simulation-header-title">${selectedEntity.name || 'Entity'}</span>
                            <span style="flex: 1;"></span>
                            <button class="btn btn-xs" onclick="promoteToEntityManager('${selectedEntity.id}')" title="Save to Entities Manager" style="font-size: 0.65rem;">
                                ðŸ“¤ Promote
                            </button>
                            <button class="btn btn-xs" onclick="removeSpawnLogicEntity('${selectedEntity.id}'); exitStateMode();" title="Remove" style="font-size: 0.65rem;">
                                âœ•
                            </button>
                        ` : `
                            <span class="simulation-header-title">Spawn Preview</span>
                            <select id="spawnPresetSelector" class="sim-preset-selector"
                                    onchange="setSpawnSimPreset(this.value)">
                                <option value="" ${spawnSimState.presetId === '' ? 'selected' : ''}>Random Entity</option>
                                ${entityPresets.map(p => `<option value="${p.id}" ${spawnSimState.presetId === p.id ? 'selected' : ''}>${p.name || p.id}</option>`).join('')}
                            </select>
                            <span style="flex: 1;"></span>
                            <button class="btn btn-sm btn-primary" onclick="spawnPreviewEntity()" title="Spawn entity with these stats">
                                ðŸŽ² Spawn Entity
                            </button>
                            <a onclick="persistenceSection='saved'; switchView('persistence');" style="font-size: 0.75rem; color: var(--text-muted); margin-left: 0.5rem; cursor: pointer; text-decoration: none;" onmouseover="this.style.color='var(--copper)'" onmouseout="this.style.color='var(--text-muted)'" title="View saved entities in Persistence tab">
                                ${getEntityCountForCurrentConfig()} saved â†’
                            </a>
                        `}
                    </div>

                    <!-- Main Content -->
                    <div class="simulation-columns" id="simulationColumns">
                        ${isStateMode
                            ? renderUnifiedEntityState(selectedEntity, {
                                editableAttributes: false,
                                editableTraits: false,
                                showModifierToggles: true,
                                showTickControls: false,
                                showPoolAssignment: false,
                                showSaveAsPreset: false,
                                showPromoteButton: false,
                                context: 'simulation'
                            })
                            : `
                                <div class="preview-stats-column" id="previewStatsColumn">
                                    ${renderPreviewStatsPanel()}
                                </div>
                                <div class="preview-probabilities-column" id="previewProbabilitiesColumn">
                                    <div class="spawn-tab-bar">
                                        <button class="spawn-tab ${spawnLogicActiveTab === 'probabilities' ? 'active' : ''}"
                                                onclick="switchSpawnTab('probabilities')">
                                            Trait Probabilities
                                        </button>
                                        <button class="spawn-tab ${spawnLogicActiveTab === 'entities' ? 'active' : ''}"
                                                onclick="switchSpawnTab('entities')">
                                            Entities${spawnLogicEntities.length > 0 ? '<span class="tab-badge">' + spawnLogicEntities.length + '</span>' : ''}
                                        </button>
                                    </div>
                                    <div class="spawn-tab-content" id="spawnTabContent">
                                        ${spawnLogicActiveTab === 'probabilities' ? renderPreviewProbabilitiesPanel() : renderEntitiesTabContent()}
                                    </div>
                                </div>
                            `
                        }
                    </div>

                    <!-- Entity Tray (always visible at bottom) -->
                    <div class="entity-tray" id="entityTray">
                        ${renderEntityTray()}
                    </div>
                </div>
            `;
        }

        function renderEntityTray() {
            if (spawnLogicEntities.length === 0) {
                return '<div class="entity-tray-empty">Spawned entities will appear here</div>';
            }

            return `
                <div class="entity-tray-header">
                    <span class="entity-tray-title">Spawned (${spawnLogicEntities.length})</span>
                    <button class="btn btn-xs" onclick="clearSpawnLogicEntities(); renderSimulationView(document.getElementById('viewContent'));"
                            style="font-size: 0.6rem;">Clear All</button>
                </div>
                <div class="entity-tray-cards">
                    ${spawnLogicEntities.map(entity => {
                        const isSelected = simulationMode === 'state' && selectedSpawnEntityId === entity.id;
                        const traitNames = entity.traits.filter(t => t.active !== false).map(t => t.name || t.id).slice(0, 3);
                        const moreCount = entity.traits.filter(t => t.active !== false).length - 3;
                        return `
                            <div class="entity-tray-card ${isSelected ? 'selected' : ''}"
                                 onclick="enterStateMode('${entity.id}')">
                                <span class="entity-tray-card-name">${entity.name || 'Entity'}</span>
                                <div class="entity-tray-card-traits">
                                    ${traitNames.map(t => `<span class="entity-tray-trait">${t}</span>`).join('')}
                                    ${moreCount > 0 ? `<span class="entity-tray-more">+${moreCount}</span>` : ''}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function enterStateMode(entityId) {
            const entity = spawnLogicEntities.find(e => e.id === entityId);
            if (!entity) return;

            // Save current spawn simulator values (only once, when first leaving spawn mode)
            if (simulationMode === 'spawn') {
                savedNewSpawnValues = JSON.parse(JSON.stringify(simulatorValues));
            }

            simulationMode = 'state';
            selectedSpawnEntityId = entityId;

            // Load entity values into simulatorValues
            const entitySimValues = {};
            Object.entries(entity.attributes).forEach(([id, attr]) => {
                entitySimValues[id] = attr.value;
            });
            Object.entries(entity.variables).forEach(([id, variable]) => {
                entitySimValues[id] = variable.value;
            });
            simulatorValues = entitySimValues;

            renderSimulationView(document.getElementById('viewContent'));
        }

        function exitStateMode() {
            simulationMode = 'spawn';
            selectedSpawnEntityId = null;

            // Restore saved spawn simulator values
            if (savedNewSpawnValues) {
                simulatorValues = savedNewSpawnValues;
                savedNewSpawnValues = null;
            }

            renderSimulationView(document.getElementById('viewContent'));
        }

        // Legacy alias â€” renderPreviewView now delegates to renderSimulationView
        function renderPreviewView(container) {
            renderSimulationView(container);
        }

        // Left column: Stats panel with attribute/variable sliders and threshold modifiers
        function renderPreviewStatsPanel() {
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const simValues = getSimulatorValues();

            // Calculate which modifiers would trigger based on current variable values
            const triggeredModifiers = modifiers.filter(mod => {
                const trigger = mod.config?.trigger;
                if (!trigger || trigger.type !== 'threshold') return false;

                const getVarValue = (targetId) => {
                    return simValues[targetId] ?? 0;
                };

                return checkModifierTriggerConditions(trigger, getVarValue);
            });

            // Get all threshold modifiers for display
            const thresholdModifiers = modifiers.filter(mod => {
                const trigger = mod.config?.trigger;
                return trigger && trigger.type === 'threshold';
            });

            return `
                <div class="stats-panel">
                    <!-- Attributes Section -->
                    ${attributes.length > 0 ? `
                    <div class="stats-section">
                        <div class="stats-section-title">
                            <span style="color: var(--node-attribute);">â—</span> Attributes
                        </div>
                        <div class="stats-sliders">
                            ${attributes.map(attr => {
                                const min = attr.config?.min ?? 1;
                                const max = attr.config?.max ?? 10;
                                const value = simValues[attr.id] ?? Math.round((min + max) / 2);
                                const affectsCount = config.relationships.filter(r =>
                                    r.type === 'weight_influence' && r.sourceId === attr.id
                                ).length;
                                return `
                                    <div class="stats-slider-row" data-attr-id="${attr.id}">
                                        <span class="stats-slider-name" title="${attr.description || attr.name}${affectsCount ? ` (affects ${affectsCount} traits)` : ''}">${attr.name}</span>
                                        <div class="stats-slider-control">
                                            <input type="range" class="stats-slider" data-id="${attr.id}"
                                                   min="${min}" max="${max}" step="1" value="${value}"
                                                   oninput="updatePreviewSlider('${attr.id}', this.value, 'attr')"
                                                   onmouseenter="previewAttributeInfluences('${attr.id}')"
                                                   onmouseleave="clearAttributeInfluencePreview()">
                                            <input type="number" class="stats-slider-input" data-id="${attr.id}"
                                                   min="${min}" max="${max}" value="${value}"
                                                   onchange="updatePreviewSlider('${attr.id}', Math.min(${max}, Math.max(${min}, this.value)), 'attr')"
                                                   title="Range: ${min}-${max}">
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Variables Section -->
                    ${variables.length > 0 ? `
                    <div class="stats-section">
                        <div class="stats-section-title">
                            <span style="color: var(--node-variable);">â—</span> Starting Variables
                            <span class="stats-section-hint">Adjust to test threshold triggers</span>
                        </div>
                        <div class="stats-sliders">
                            ${variables.map(v => {
                                const min = v.config?.min ?? 0;
                                const max = v.config?.max ?? 100;
                                const initial = v.config?.initial ?? v.config?.default ?? max;
                                const value = simValues[v.id] ?? initial;
                                return `
                                    <div class="stats-slider-row" data-var-id="${v.id}">
                                        <span class="stats-slider-name" title="${v.description || v.name}">${v.name}</span>
                                        <div class="stats-slider-control">
                                            <input type="range" class="stats-slider stats-slider-var" data-id="${v.id}"
                                                   min="${min}" max="${max}" step="1" value="${value}"
                                                   oninput="updatePreviewSlider('${v.id}', this.value, 'var')">
                                            <input type="number" class="stats-slider-input" data-id="${v.id}"
                                                   min="${min}" max="${max}" value="${value}"
                                                   onchange="updatePreviewSlider('${v.id}', Math.min(${max}, Math.max(${min}, this.value)), 'var')"
                                                   title="Range: ${min}-${max}">
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Modifiers Section -->
                    ${modifiers.length > 0 ? `
                    <div class="stats-section">
                        <div class="stats-section-title">
                            <span style="color: var(--node-modifier);">â—</span> Modifiers
                            <span class="stats-section-hint">${getActiveModifiers().length} active</span>
                        </div>
                        <div class="modifiers-list">
                            ${modifiers.map(mod => {
                                const trigger = mod.config?.trigger;
                                const triggerType = trigger?.type || mod.config?.triggerType;
                                const isThreshold = triggerType === 'threshold';
                                const isForceApplied = window._forceAppliedModifiers?.has(mod.id);
                                const isForceRemoved = window._forceRemovedModifiers?.has(mod.id);
                                const isTriggered = triggeredModifiers.some(tm => tm.id === mod.id) && !isForceRemoved;
                                const isActive = isForceApplied || isTriggered;

                                // Build condition text for threshold modifiers
                                let conditionText = '';
                                if (isThreshold && trigger) {
                                    const conditions = trigger?.conditions || [{ target: trigger?.target || trigger?.targetId, operator: trigger?.operator, value: trigger?.value }];
                                    conditionText = conditions.slice(0, 2).map(c => {
                                        if (c.type === 'group') return '(...)';
                                        const targetNode = config.nodes.find(n => n.id === c.target);
                                        const name = targetNode?.name?.substring(0, 8) || c.target;
                                        return name + ' ' + (c.operator || '<') + ' ' + (c.value ?? 0);
                                    }).join(trigger?.logic === 'any' ? ' | ' : ' & ');
                                    if ((trigger?.conditions?.length || 1) > 2) conditionText += '...';
                                }

                                // Build tooltip text
                                const tooltipText = (mod.description || mod.name) + (conditionText ? ' | Trigger: ' + conditionText : '');

                                // Determine visual state
                                const activeClass = isActive ? 'active' : '';
                                const triggeredClass = isTriggered ? 'triggered' : '';
                                const forcedClass = isForceApplied ? 'forced' : '';
                                const removedClass = isForceRemoved ? 'force-removed' : '';
                                const btnIcon = isActive ? 'âœ“' : 'â—‹';
                                const btnTitle = isActive ? 'Click to deactivate' : 'Click to force-apply';

                                // Status badges
                                const thresholdBadge = isThreshold ? '<span class="mod-threshold-badge">âš¡</span>' : '';
                                let statusBadge = '';
                                if (isForceRemoved) {
                                    statusBadge = '<span class="mod-removed-badge">off</span>';
                                } else if (isTriggered && !isForceApplied) {
                                    statusBadge = '<span class="mod-auto-badge">auto</span>';
                                } else if (isForceApplied) {
                                    statusBadge = '<span class="mod-forced-badge">forced</span>';
                                }

                                return '<div class="mod-item ' + activeClass + ' ' + triggeredClass + ' ' + forcedClass + ' ' + removedClass + '" data-mod-id="' + mod.id + '" ' +
                                    'onmouseenter="showModifierTooltip(event, \'' + mod.id + '\')" onmouseleave="hideModifierTooltip()">' +
                                    '<button class="mod-toggle-btn ' + (isActive ? 'on' : 'off') + '" onclick="event.stopPropagation(); toggleForceModifier(\'' + mod.id + '\')" title="' + btnTitle + '">' + btnIcon + '</button>' +
                                    '<a class="mod-name-link" onclick="openNodeInEditor(\'' + mod.id + '\')">' + mod.name + '</a>' +
                                    thresholdBadge + statusBadge +
                                '</div>';
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    ${attributes.length === 0 && variables.length === 0 ? `
                        <div class="empty-hint" style="padding: 2rem; text-align: center;">
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">ðŸ“Š</div>
                            <div>Add attributes or variables to adjust spawn stats</div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Right column: Probabilities panel with trait chances
        function renderPreviewProbabilitiesPanel() {
            const presetId = spawnSimState.presetId || '';
            const probabilities = calculateSpawnProbabilities(presetId);

            if (probabilities.length === 0) {
                return `
                    <div class="probabilities-panel">
                        <div class="empty-hint" style="padding: 2rem; text-align: center;">
                            <div style="font-size: 1.2rem; margin-bottom: 0.5rem;">ðŸŽ²</div>
                            <div>Add layers and traits to see spawn probabilities</div>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="probabilities-panel">
                    <div class="probabilities-header">
                        <span style="color: var(--node-trait);">â—</span> Trait Probabilities
                        <span class="probabilities-hint">Click trait to expand details</span>
                    </div>
                    <div class="probabilities-layers">
                        ${probabilities.map((layer, layerIdx) => `
                            <div class="prob-layer">
                                <div class="prob-layer-header">
                                    <span style="color: var(--node-layer);">â—ˆ</span>
                                    ${layer.layer}
                                    ${layer.rollRange[0] !== layer.rollRange[1] ?
                                        `<span class="prob-layer-rolls">(${layer.rollRange[0]}-${layer.rollRange[1]} rolls)</span>` :
                                        layer.rollRange[0] > 1 ?
                                        `<span class="prob-layer-rolls">(${layer.rollRange[0]} rolls)</span>` : ''
                                    }
                                </div>
                                ${renderStackedProbBar(layer.traits, { height: 14 })}
                                <div class="prob-layer-traits">
                                    ${layer.traits.map((t, i) => renderSingleTraitItem(t, i)).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Render a single trait item for the probabilities panel
        // Returns HTML string for one .prob-trait-item div
        function renderSingleTraitItem(t, traitIdx = 0) {
            const traitColor = getTraitColor(traitIdx);
            const hasInfluences = t.influences.length > 0;
            const hasGates = t.eligibilityGates && t.eligibilityGates.length > 0;
            const isHighlighted = hasInfluences && t.influences.some(inf =>
                window._activeSimulatorAttr === inf.sourceId
            );
            const isExpanded = window._expandedTraits?.has(t.id);

            // Build influence summary (compact chips)
            const influenceChips = t.influences.filter(i => !i.conditional).slice(0, 2).map(inf => {
                const sign = inf.effect >= 0 ? '+' : '';
                return `<span class="influence-chip ${inf.effect >= 0 ? 'positive' : 'negative'}"
                              title="${inf.formula}">${sign}${Math.round(inf.effect)}</span>`;
            }).join('');
            const moreCount = t.influences.filter(i => !i.conditional).length - 2;

            // Build detailed influence descriptions (compact)
            const influenceDetails = t.influences.map(inf => {
                if (inf.conditional) {
                    const potentialEffect = inf.potentialEffect ?? inf.effect ?? 0;
                    const potentialSign = potentialEffect >= 0 ? '+' : '';
                    return `<div class="influence-detail conditional">
                        <span class="influence-detail-icon">â—‹</span>
                        <span class="influence-detail-text">
                            <a class="node-link" onclick="openNodeInEditor('${inf.sourceId}')">${inf.sourceName}</a>
                            <span class="influence-potential">(${potentialSign}${potentialEffect} if active)</span>
                        </span>
                    </div>`;
                } else if (inf.sourceType === 'modifier') {
                    const sign = inf.effect >= 0 ? '+' : '';
                    return `<div class="influence-detail ${inf.effect >= 0 ? 'positive' : 'negative'} modifier-active">
                        <span class="influence-detail-icon">âš¡</span>
                        <span class="influence-detail-text">
                            <a class="node-link" onclick="openNodeInEditor('${inf.sourceId}')">${inf.sourceName}</a>
                            <span class="influence-current">${sign}${Math.round(inf.effect)}</span>
                        </span>
                    </div>`;
                } else {
                    const sign = inf.effect >= 0 ? '+' : '';
                    const perPt = inf.multiplier ? ` (${Math.abs(inf.multiplier)}/pt)` : '';
                    return `<div class="influence-detail ${inf.effect >= 0 ? 'positive' : 'negative'}">
                        <span class="influence-detail-icon">${inf.effect >= 0 ? 'â†‘' : 'â†“'}</span>
                        <span class="influence-detail-text">
                            <a class="node-link" onclick="openNodeInEditor('${inf.sourceId}')">${inf.sourceName}</a>${perPt}
                            <span class="influence-current">${sign}${Math.round(inf.effect)}</span>
                        </span>
                    </div>`;
                }
            }).join('');

            // Store tooltip data
            window._traitTooltipData = window._traitTooltipData || {};
            window._traitTooltipData[t.id] = {
                baseWeight: t.baseWeight,
                weight: t.weight,
                influences: t.influences.filter(i => !i.conditional).map(inf => ({
                    sourceId: inf.sourceId,
                    sourceName: inf.sourceName,
                    effect: inf.effect,
                    multiplier: inf.multiplier
                }))
            };

            return `
                <div class="prob-trait-item ${isExpanded ? 'expanded' : ''}" data-trait-id="${t.id}">
                    <div class="prob-trait-row ${isHighlighted ? 'highlighted' : ''}"
                         onclick="toggleTraitExpand('${t.id}')"
                         onmouseenter="if(!window._expandedTraits?.has('${t.id}')) showTraitTooltip(event, '${t.id}')"
                         onmouseleave="hideTraitTooltip()">
                        <span class="prob-trait-expand">${isExpanded ? 'â–¼' : 'â–¶'}</span>
                        <span class="prob-color-dot" style="background: ${traitColor};"></span>
                        <span class="prob-trait-name">${t.name}</span>
                        <div class="prob-trait-bar-wrap">
                            <div class="prob-trait-bar"
                                 style="width: ${t.pct}%; background: ${traitColor};"></div>
                        </div>
                        <span class="prob-trait-pct">${t.pct}%</span>
                        ${hasInfluences ? `<div class="prob-trait-influences">${influenceChips}${moreCount > 0 ? `<span class="more-count">+${moreCount}</span>` : ''}</div>` : ''}
                    </div>
                    ${isExpanded ? `
                    <div class="prob-trait-details">
                        <div class="trait-detail-columns">
                            <div class="trait-detail-left">
                                <div class="trait-weight-row">
                                    <span class="trait-weight-label">Base:</span>
                                    <input type="number" class="trait-weight-input"
                                           value="${t.baseWeight}" min="0" max="1000"
                                           onchange="updateTraitWeight('${t.id}', this.value)"
                                           onclick="event.stopPropagation()">
                                    ${(() => { const delta = Math.round(t.weight) - t.baseWeight; return delta !== 0 ? `<span class="trait-weight-delta ${delta > 0 ? 'positive' : 'negative'}">${delta > 0 ? '+' : ''}${delta}</span>` : ''; })()}
                                    <span class="trait-weight-arrow">&rarr;</span>
                                    <span class="trait-weight-final">${Math.round(t.weight)}</span>
                                </div>
                                <div class="trait-actions-stacked">
                                    <button class="btn-mini" onclick="event.stopPropagation(); openNodeInEditor('${t.id}')">Edit</button>
                                    <button class="btn-mini" onclick="event.stopPropagation(); openAddConnectionFor('${t.id}')">+ Influence</button>
                                </div>
                            </div>
                            <div class="trait-detail-right">
                                ${hasInfluences ? `
                                <div class="trait-influences-compact">
                                    ${influenceDetails}
                                </div>
                                ` : '<div class="no-influences-compact">No influences</div>'}
                                ${hasGates ? `
                                <div class="trait-gates-compact">
                                    ${t.eligibilityGates.map(g => `
                                        <div class="gate-detail-compact">
                                            <span class="gate-icon">ðŸš«</span>
                                            <a class="node-link" onclick="openNodeInEditor('${g.sourceId}')">${g.sourceName}</a>
                                        </div>
                                    `).join('')}
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
        }

        // Track which traits are expanded in the probability panel
        window._expandedTraits = new Set();

        // Track force-applied and force-removed modifiers in spawn preview
        window._forceAppliedModifiers = new Set();
        window._forceRemovedModifiers = new Set();

        // Modifier hover tooltip state
        window._modTooltipTimeout = null;

        // Show modifier tooltip with delay
        function showModifierTooltip(event, modId) {
            if (window._modTooltipTimeout) {
                clearTimeout(window._modTooltipTimeout);
            }

            const row = event.currentTarget;
            if (!row) return;

            window._modTooltipTimeout = setTimeout(() => {
                const mod = config.nodes.find(n => n.id === modId);
                if (!mod) return;

                let tooltip = document.getElementById('modHoverTooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'modHoverTooltip';
                    tooltip.className = 'mod-hover-tooltip';
                    document.body.appendChild(tooltip);
                }

                // Build trigger text
                const trigger = mod.config?.trigger;
                const triggerType = trigger?.type || mod.config?.triggerType;
                let triggerHtml = '';
                if (triggerType === 'threshold' && trigger) {
                    const conditions = trigger?.conditions || [{ target: trigger?.target, operator: trigger?.operator, value: trigger?.value }];
                    const condText = conditions.map(c => {
                        const targetNode = config.nodes.find(n => n.id === c.target);
                        return (targetNode?.name || c.target) + ' ' + (c.operator || '<') + ' ' + (c.value ?? 0);
                    }).join(trigger?.logic === 'any' ? ' OR ' : ' AND ');
                    triggerHtml = '<div class="mod-tooltip-trigger"><span class="trigger-label">Trigger:</span> ' + condText + '</div>';
                }

                tooltip.innerHTML =
                    '<div class="mod-tooltip-name">' + mod.name + '</div>' +
                    (mod.description ? '<div class="mod-tooltip-desc">' + mod.description + '</div>' : '') +
                    triggerHtml +
                    '<div class="mod-tooltip-actions">' +
                        '<a class="tooltip-action-link" onclick="event.stopPropagation(); openNodeInEditor(\'' + modId + '\')">Edit</a>' +
                        '<a class="tooltip-action-link" onclick="event.stopPropagation(); openAddConnectionFor(\'' + modId + '\')">+ Connection</a>' +
                    '</div>';

                // Position tooltip
                const rect = row.getBoundingClientRect();
                const tooltipHeight = 100;
                const spaceBelow = window.innerHeight - rect.bottom;

                tooltip.style.left = (rect.right + 10) + 'px';
                if (rect.right + 270 > window.innerWidth) {
                    tooltip.style.left = (rect.left - 270) + 'px';
                }
                tooltip.style.top = (rect.top + window.scrollY) + 'px';

                tooltip.classList.add('visible');
            }, 500);
        }

        // Hide modifier tooltip
        function hideModifierTooltip() {
            if (window._modTooltipTimeout) {
                clearTimeout(window._modTooltipTimeout);
                window._modTooltipTimeout = null;
            }

            setTimeout(() => {
                const tooltip = document.getElementById('modHoverTooltip');
                if (tooltip && !tooltip.matches(':hover')) {
                    tooltip.classList.remove('visible');
                }
            }, 100);
        }

        // Keep modifier tooltip visible when hovering over it
        document.addEventListener('mouseout', (e) => {
            const tooltip = document.getElementById('modHoverTooltip');
            if (tooltip && e.target.closest('#modHoverTooltip') && !e.relatedTarget?.closest('#modHoverTooltip')) {
                tooltip.classList.remove('visible');
            }
        });

        // Toggle modifier state (force-apply for inactive, force-remove for active)
        function toggleForceModifier(modId) {
            const mod = config.nodes.find(n => n.id === modId);
            if (!mod) return;

            // Check if this would naturally be triggered by threshold
            const trigger = mod.config?.trigger;
            const triggerType = trigger?.type || mod.config?.triggerType;
            const isThreshold = triggerType === 'threshold';

            let wouldBeTriggered = false;
            if (isThreshold && trigger) {
                const simValues = getSimulatorValues();
                const getVarValue = (targetId) => simValues[targetId] ?? 0;
                wouldBeTriggered = checkModifierTriggerConditions(trigger, getVarValue);
            }

            // Determine current effective state
            const isForceApplied = window._forceAppliedModifiers.has(modId);
            const isForceRemoved = window._forceRemovedModifiers.has(modId);
            const isActive = isForceApplied || (wouldBeTriggered && !isForceRemoved);

            if (isActive) {
                // Currently active - remove it
                window._forceAppliedModifiers.delete(modId);
                if (wouldBeTriggered) {
                    // Threshold modifier - need to force-remove to override
                    window._forceRemovedModifiers.add(modId);
                }
            } else {
                // Currently inactive - activate it
                window._forceRemovedModifiers.delete(modId);
                if (!wouldBeTriggered) {
                    // Non-threshold or threshold not met - need to force-apply
                    window._forceAppliedModifiers.add(modId);
                }
            }

            // Re-render both panels to reflect modifier effects
            const statsPanel = document.getElementById('previewStatsColumn');
            if (statsPanel) statsPanel.innerHTML = renderPreviewStatsPanel();
            if (spawnLogicActiveTab === 'probabilities') {
                const tabContent = document.getElementById('spawnTabContent');
                if (tabContent) tabContent.innerHTML = renderPreviewProbabilitiesPanel();
            }
        }

        // Check if a modifier is currently active (threshold triggered OR force-applied)
        function isModifierActive(modId) {
            if (window._forceAppliedModifiers.has(modId)) return true;
            // Check if force-removed (user clicked to deactivate a threshold modifier)
            if (window._forceRemovedModifiers?.has(modId)) return false;

            const mod = config.nodes.find(n => n.id === modId);
            if (!mod) return false;

            // Check both trigger.type (new format) and config.triggerType (old format)
            const trigger = mod.config?.trigger;
            const triggerType = trigger?.type || mod.config?.triggerType;
            if (!trigger || triggerType !== 'threshold') return false;

            const simValues = getSimulatorValues();
            const getVarValue = (targetId) => simValues[targetId] ?? 0;
            return checkModifierTriggerConditions(trigger, getVarValue);
        }

        // Get all currently active modifiers
        function getActiveModifiers() {
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            return modifiers.filter(mod => isModifierActive(mod.id));
        }

        // Toggle trait expansion in probability panel
        function toggleTraitExpand(traitId) {
            // Hide any visible tooltip
            const tooltip = document.getElementById('traitHoverTooltip');
            if (tooltip) tooltip.classList.remove('visible');
            if (window._traitTooltipTimeout) {
                clearTimeout(window._traitTooltipTimeout);
                window._traitTooltipTimeout = null;
            }

            if (window._expandedTraits.has(traitId)) {
                window._expandedTraits.delete(traitId);
            } else {
                window._expandedTraits.add(traitId);
            }

            // Targeted update: replace just this trait item instead of full panel re-render
            const traitItem = document.querySelector(`.prob-trait-item[data-trait-id="${traitId}"]`);
            if (traitItem) {
                const presetId = spawnSimState.presetId || '';
                const probabilities = calculateSpawnProbabilities(presetId);
                let traitData = null;
                let traitColorIdx = 0;
                for (const layer of probabilities) {
                    const foundIdx = layer.traits.findIndex(t => t.id === traitId);
                    if (foundIdx >= 0) { traitData = layer.traits[foundIdx]; traitColorIdx = foundIdx; break; }
                }
                if (traitData) {
                    traitItem.outerHTML = renderSingleTraitItem(traitData, traitColorIdx);
                    // If expanding, focus the weight input for keyboard accessibility
                    if (window._expandedTraits.has(traitId)) {
                        const newItem = document.querySelector(`.prob-trait-item[data-trait-id="${traitId}"]`);
                        if (newItem) {
                            const weightInput = newItem.querySelector('.trait-weight-input');
                            // Don't auto-focus to avoid unexpected behavior
                        }
                    }
                }
            } else {
                // Fallback: full re-render if trait element not found
                const tabContent = document.getElementById('spawnTabContent');
                const probCol = document.getElementById('previewProbabilitiesColumn');
                const target = tabContent || probCol;
                if (target) target.innerHTML = renderPreviewProbabilitiesPanel();
            }
        }

        // Update a trait's base weight from the probability panel
        function updateTraitWeight(traitId, newWeight) {
            const trait = config.nodes.find(n => n.id === traitId);
            if (!trait) return;

            const weight = Math.max(0, parseInt(newWeight) || 0);

            // Update the config
            if (!trait.config) trait.config = {};
            if (!trait.config.selection) trait.config.selection = {};
            trait.config.selection.baseWeight = weight;
            trait.config.baseWeight = weight; // Also set legacy location

            // Save and refresh engine
            engine.loadConfig(config);
            saveToStorage();

            // Targeted DOM update: update probabilities without destroying the focused input
            const presetId = spawnSimState.presetId || '';
            const probabilities = calculateSpawnProbabilities(presetId);

            // Update ALL trait items in the panel (percentages shift when one weight changes)
            for (const layer of probabilities) {
                for (const t of layer.traits) {
                    const traitItem = document.querySelector(`.prob-trait-item[data-trait-id="${t.id}"]`);
                    if (!traitItem) continue;

                    // Update bar width and percentage
                    const bar = traitItem.querySelector('.prob-trait-bar');
                    if (bar) {
                        bar.style.width = t.pct + '%';
                        bar.classList.toggle('high', t.pct >= 40);
                        bar.classList.toggle('low', t.pct < 15);
                    }
                    const pctEl = traitItem.querySelector('.prob-trait-pct');
                    if (pctEl) pctEl.textContent = t.pct + '%';

                    // For the trait being edited, also update delta and final weight
                    if (t.id === traitId) {
                        const delta = Math.round(t.weight) - t.baseWeight;

                        // Update or create delta element
                        let deltaEl = traitItem.querySelector('.trait-weight-delta');
                        const arrowEl = traitItem.querySelector('.trait-weight-arrow');
                        if (delta !== 0) {
                            if (deltaEl) {
                                deltaEl.textContent = (delta > 0 ? '+' : '') + delta;
                                deltaEl.className = 'trait-weight-delta ' + (delta > 0 ? 'positive' : 'negative');
                            } else if (arrowEl) {
                                // Insert delta element before the arrow
                                deltaEl = document.createElement('span');
                                deltaEl.className = 'trait-weight-delta ' + (delta > 0 ? 'positive' : 'negative');
                                deltaEl.textContent = (delta > 0 ? '+' : '') + delta;
                                arrowEl.parentNode.insertBefore(deltaEl, arrowEl);
                            }
                        } else if (deltaEl) {
                            // Remove delta element when delta is 0
                            deltaEl.remove();
                        }

                        // Update final weight display
                        const finalEl = traitItem.querySelector('.trait-weight-final');
                        if (finalEl) finalEl.textContent = Math.round(t.weight);

                        // Update tooltip data
                        window._traitTooltipData = window._traitTooltipData || {};
                        window._traitTooltipData[t.id] = {
                            baseWeight: t.baseWeight,
                            weight: t.weight,
                            influences: t.influences.filter(i => !i.conditional).map(inf => ({
                                sourceId: inf.sourceId,
                                sourceName: inf.sourceName,
                                effect: inf.effect,
                                multiplier: inf.multiplier
                            }))
                        };
                    }
                }
            }

            showToast(`${trait.name} weight set to ${weight}`, 'success');
        }

        // Open a node in the editor (switch to tree view and select it)
        function openNodeInEditor(nodeId, switchView = false) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Select the node (this opens it in the detail panel)
            selectNode(nodeId);

            if (switchView) {
                // Switch to tree view if requested
                currentView = 'tree';
                render();

                // Scroll to the node in the tree
                setTimeout(() => {
                    const nodeEl = document.querySelector(`.tree-item[data-id="${nodeId}"]`);
                    if (nodeEl) {
                        nodeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        nodeEl.classList.add('highlight-flash');
                        setTimeout(() => nodeEl.classList.remove('highlight-flash'), 1000);
                    }
                }, 100);
            } else {
                // Just re-render detail panel without changing view
                renderDetailPanel();
            }
        }

        // Open add connection modal for a specific node
        function openAddConnectionFor(nodeId) {
            selectNode(nodeId);
            showAddRelationshipModal();
        }

        // Trait hover tooltip state
        window._traitTooltipTimeout = null;
        window._traitTooltipVisible = false;
        window._traitTooltipTraitId = null;
        window._traitTooltipData = {}; // Store trait data for tooltips

        // Show trait tooltip with delay
        function showTraitTooltip(event, traitId) {
            // Clear any existing timeout
            if (window._traitTooltipTimeout) {
                clearTimeout(window._traitTooltipTimeout);
            }

            // Capture the target element before setTimeout
            const row = event.currentTarget;
            if (!row) return;

            // Set timeout for 0.5s delay
            window._traitTooltipTimeout = setTimeout(() => {

                // Create or get tooltip element
                let tooltip = document.getElementById('traitHoverTooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'traitHoverTooltip';
                    tooltip.className = 'trait-hover-tooltip';
                    document.body.appendChild(tooltip);
                }

                // Get tooltip data from global store
                const data = window._traitTooltipData[traitId];
                if (!data) return;
                const hasInfluences = data.influences && data.influences.length > 0;

                let influenceHtml = '';
                if (hasInfluences) {
                    influenceHtml = data.influences.map(inf => {
                        const isPos = inf.effect >= 0;
                        const direction = isPos ? 'positively' : 'negatively';
                        const perPoint = inf.multiplier ? `, ${Math.abs(inf.multiplier)}/pt` : '';
                        return `<div class="tooltip-influence-row ${isPos ? 'positive' : 'negative'}">
                            <span class="inf-icon">${isPos ? 'â†‘' : 'â†“'}</span>
                            <span>${direction} by <a class="node-link" onclick="event.stopPropagation(); openNodeInEditor('${inf.sourceId}')">${inf.sourceName}</a>${perPoint}</span>
                        </div>`;
                    }).join('');
                }

                tooltip.innerHTML = `
                    <div class="tooltip-weight-line">
                        <span>Weight:</span>
                        <span class="tooltip-weight-value">${data.baseWeight}</span>
                        <span>â†’</span>
                        <span class="tooltip-weight-value">${data.weight}</span>
                        <span>effective</span>
                    </div>
                    ${hasInfluences ? `<div class="tooltip-influences">${influenceHtml}</div>` : '<div class="tooltip-no-influences">No influences</div>'}
                    <div class="tooltip-actions">
                        <a class="tooltip-action-link" onclick="event.stopPropagation(); openNodeInEditor('${traitId}')">Edit</a>
                        <a class="tooltip-action-link" onclick="event.stopPropagation(); openAddConnectionFor('${traitId}')">+ Influence</a>
                    </div>
                `;

                // Position tooltip
                const rect = row.getBoundingClientRect();
                const tooltipHeight = 120; // estimated
                const spaceBelow = window.innerHeight - rect.bottom;

                tooltip.style.left = (rect.left + rect.width / 2 - 140) + 'px';
                if (spaceBelow < tooltipHeight + 10) {
                    // Position above
                    tooltip.style.top = (rect.top + window.scrollY - tooltipHeight - 8) + 'px';
                } else {
                    // Position below
                    tooltip.style.top = (rect.bottom + window.scrollY + 8) + 'px';
                }

                // Show tooltip
                tooltip.classList.add('visible');
                window._traitTooltipVisible = true;
                window._traitTooltipTraitId = traitId;
            }, 500);
        }

        // Hide trait tooltip
        function hideTraitTooltip() {
            // Clear timeout if still pending
            if (window._traitTooltipTimeout) {
                clearTimeout(window._traitTooltipTimeout);
                window._traitTooltipTimeout = null;
            }

            // Hide tooltip with small delay (allows clicking links inside)
            setTimeout(() => {
                const tooltip = document.getElementById('traitHoverTooltip');
                if (tooltip && !tooltip.matches(':hover')) {
                    tooltip.classList.remove('visible');
                    window._traitTooltipVisible = false;
                    window._traitTooltipTraitId = null;
                }
            }, 100);
        }

        // Keep tooltip visible when hovering over it
        document.addEventListener('mouseover', (e) => {
            const tooltip = document.getElementById('traitHoverTooltip');
            if (tooltip && e.target.closest('#traitHoverTooltip')) {
                // Keep visible
            }
        });

        document.addEventListener('mouseout', (e) => {
            const tooltip = document.getElementById('traitHoverTooltip');
            if (tooltip && e.target.closest('#traitHoverTooltip') && !e.relatedTarget?.closest('#traitHoverTooltip')) {
                tooltip.classList.remove('visible');
                window._traitTooltipVisible = false;
            }
        });

        // Update both slider and input, then refresh preview
        function updatePreviewSlider(id, value, type) {
            const numValue = parseFloat(value);
            simulatorValues[id] = numValue;

            // Sync slider and input (in case one triggered the other)
            const slider = document.querySelector(`.stats-slider[data-id="${id}"]`);
            const input = document.querySelector(`.stats-slider-input[data-id="${id}"]`);
            if (slider && document.activeElement !== slider) slider.value = numValue;
            if (input && document.activeElement !== input) input.value = numValue;

            // Update probabilities panel (right column tab content)
            if (spawnLogicActiveTab === 'probabilities') {
                const tabContent = document.getElementById('spawnTabContent');
                if (tabContent) {
                    tabContent.innerHTML = renderPreviewProbabilitiesPanel();
                }
            }

            // Update only the threshold modifiers section (don't re-render sliders)
            updateThresholdModifiersDisplay();

            // Highlight affected traits if this is an attribute
            if (type === 'attr') {
                window._activeSimulatorAttr = id;
                highlightAffectedTraits(id);
            }
        }

        // Update just the modifiers display without re-rendering sliders
        function updateThresholdModifiersDisplay() {
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const simValues = getSimulatorValues();

            // Find which modifiers would be triggered by threshold (ignoring force-removed)
            const thresholdTriggeredModifiers = modifiers.filter(mod => {
                const trigger = mod.config?.trigger;
                const triggerType = trigger?.type || mod.config?.triggerType;
                if (!trigger || triggerType !== 'threshold') return false;
                const getVarValue = (targetId) => simValues[targetId] ?? 0;
                return checkModifierTriggerConditions(trigger, getVarValue);
            });

            // Clean up stale force-removed entries (where conditions aren't met anymore)
            if (window._forceRemovedModifiers) {
                const toRemove = [];
                window._forceRemovedModifiers.forEach(modId => {
                    if (!thresholdTriggeredModifiers.some(m => m.id === modId)) {
                        toRemove.push(modId);
                    }
                });
                toRemove.forEach(id => window._forceRemovedModifiers.delete(id));
            }

            // Count total active (triggered but not force-removed, OR force-applied)
            const activeCount = modifiers.filter(mod => {
                const isForceApplied = window._forceAppliedModifiers?.has(mod.id);
                const isForceRemoved = window._forceRemovedModifiers?.has(mod.id);
                const isTriggered = thresholdTriggeredModifiers.some(tm => tm.id === mod.id);
                return isForceApplied || (isTriggered && !isForceRemoved);
            }).length;

            // Update the active count in the header
            const hintEl = document.querySelector('.stats-section:has(.modifiers-list) .stats-section-hint');
            if (hintEl) {
                hintEl.textContent = `${activeCount} active`;
            }

            // Update each modifier item's active state
            document.querySelectorAll('.mod-item').forEach(item => {
                const modId = item.dataset.modId;
                const isForceApplied = window._forceAppliedModifiers?.has(modId);
                const isForceRemoved = window._forceRemovedModifiers?.has(modId);
                const isTriggered = thresholdTriggeredModifiers.some(tm => tm.id === modId) && !isForceRemoved;
                const isActive = isForceApplied || isTriggered;

                item.classList.toggle('active', isActive);
                item.classList.toggle('triggered', isTriggered);
                item.classList.toggle('forced', isForceApplied);
                item.classList.toggle('force-removed', isForceRemoved);
                item.style.opacity = isActive ? '1' : (isForceRemoved ? '0.5' : '0.6');

                const btn = item.querySelector('.mod-toggle-btn');
                if (btn) {
                    btn.classList.toggle('on', isActive);
                    btn.textContent = isActive ? 'âœ“' : 'â—‹';
                }

                // Update badges
                const autoBadge = item.querySelector('.mod-auto-badge');
                const forcedBadge = item.querySelector('.mod-forced-badge');
                const removedBadge = item.querySelector('.mod-removed-badge');
                if (autoBadge) autoBadge.style.display = (isTriggered && !isForceApplied) ? '' : 'none';
                if (forcedBadge) forcedBadge.style.display = isForceApplied ? '' : 'none';
                if (removedBadge) removedBadge.style.display = isForceRemoved ? '' : 'none';
            });

            // Legacy support for old threshold-mod-item class
            document.querySelectorAll('.threshold-mod-item').forEach(item => {
                const modName = item.querySelector('.threshold-mod-name')?.textContent;
                const mod = modifiers.find(m => m.name === modName);
                const isActive = mod && thresholdTriggeredModifiers.some(tm => tm.id === mod.id);

                item.classList.toggle('active', isActive);
                item.classList.toggle('inactive', !isActive);

                const icon = item.querySelector('.threshold-mod-icon');
                if (icon) icon.textContent = isActive ? 'âš¡' : 'â—‹';
            });
        }

        // Legacy: Unified spawn preview - shows sliders and probabilities together
        function renderUnifiedSpawnPreview() {
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const simValues = getSimulatorValues();

            // Get probability data
            const presetSelector = document.getElementById('spawnPresetSelector');
            const presetId = presetSelector ? presetSelector.value : '';
            const probabilities = calculateSpawnProbabilities(presetId);

            // Calculate which modifiers would trigger based on current variable values
            const triggeredModifiers = modifiers.filter(mod => {
                const trigger = mod.config?.trigger;
                if (!trigger || trigger.type !== 'threshold') return false;

                const getVarValue = (targetId) => {
                    return simValues[targetId] ?? 0;
                };

                return checkModifierTriggerConditions(trigger, getVarValue);
            });

            return `
                <!-- Attributes Section -->
                ${attributes.length > 0 ? `
                <div class="preview-section">
                    <div class="preview-section-title">
                        <span style="color: var(--node-attribute);">â—</span> Attributes
                        <span class="preview-section-hint">Drag sliders to see probability changes</span>
                    </div>
                    <div class="preview-sliders">
                        ${attributes.map(attr => {
                            const min = attr.config?.min ?? 1;
                            const max = attr.config?.max ?? 10;
                            const value = simValues[attr.id] ?? Math.round((min + max) / 2);
                            const affectsCount = config.relationships.filter(r =>
                                r.type === 'weight_influence' && r.sourceId === attr.id
                            ).length;
                            return `
                                <div class="preview-slider-row" data-attr-id="${attr.id}">
                                    <span class="preview-slider-name" title="${attr.name}${affectsCount ? ` (affects ${affectsCount} traits)` : ''}">${attr.name}</span>
                                    <input type="range" class="preview-slider"
                                           min="${min}" max="${max}" step="1" value="${value}"
                                           oninput="updateSimulatorValue('${attr.id}', this.value)"
                                           onmouseenter="previewAttributeInfluences('${attr.id}')"
                                           onmouseleave="clearAttributeInfluencePreview()">
                                    <span class="preview-slider-value">${value}</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                ` : ''}

                <!-- Variables Section (starting values) -->
                ${variables.length > 0 ? `
                <div class="preview-section">
                    <div class="preview-section-title">
                        <span style="color: var(--node-variable);">â—</span> Starting Variables
                        <span class="preview-section-hint">Set initial values to test threshold triggers</span>
                    </div>
                    <div class="preview-sliders">
                        ${variables.map(v => {
                            const min = v.config?.min ?? 0;
                            const max = v.config?.max ?? 100;
                            const value = simValues[v.id] ?? v.config?.initial ?? v.config?.default ?? max;
                            return `
                                <div class="preview-slider-row" data-var-id="${v.id}">
                                    <span class="preview-slider-name" title="${v.name}">${v.name}</span>
                                    <input type="range" class="preview-slider"
                                           min="${min}" max="${max}" step="1" value="${value}"
                                           oninput="updateSimVariable('${v.id}', this.value)">
                                    <span class="preview-slider-value">${value}</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                ` : ''}

                <!-- Trait Probabilities Section -->
                ${probabilities.length > 0 ? `
                <div class="preview-section preview-probabilities-section">
                    <div class="preview-section-title">
                        <span style="color: var(--node-trait);">â—</span> Trait Probabilities
                        <span class="preview-section-hint">Updates as you adjust sliders above</span>
                    </div>
                    <div class="preview-probability-layers" id="probabilityLayers">
                        ${probabilities.map((layer, layerIdx) => `
                            <div class="preview-layer">
                                <div class="preview-layer-header">
                                    <span style="color: var(--node-layer);">â—ˆ</span>
                                    ${layer.layer}
                                    ${layer.rollRange[0] !== layer.rollRange[1] ?
                                        `<span class="preview-layer-rolls">(${layer.rollRange[0]}-${layer.rollRange[1]} rolls)</span>` :
                                        layer.rollRange[0] > 1 ?
                                        `<span class="preview-layer-rolls">(${layer.rollRange[0]} rolls)</span>` : ''
                                    }
                                </div>
                                <div class="preview-layer-traits">
                                    ${layer.traits.map((t, traitIdx) => {
                                        const hasInfluences = t.influences.length > 0;
                                        const isHighlighted = hasInfluences && t.influences.some(inf =>
                                            window._activeSimulatorAttr === inf.sourceId
                                        );

                                        // Build influence summary
                                        const influenceSummary = t.influences.filter(i => !i.conditional).map(inf => {
                                            const sign = inf.effect >= 0 ? '+' : '';
                                            return `${sign}${Math.round(inf.effect)} from ${inf.sourceName}`;
                                        }).join(', ');

                                        return `
                                            <div class="preview-trait-row ${isHighlighted ? 'highlighted' : ''}"
                                                 data-trait-id="${t.id}">
                                                <span class="preview-trait-name">${t.name}</span>
                                                <div class="preview-trait-bar-container">
                                                    <div class="preview-trait-bar ${t.pct >= 40 ? 'high' : ''} ${t.pct < 15 ? 'low' : ''}"
                                                         style="width: ${t.pct}%;"></div>
                                                </div>
                                                <span class="preview-trait-pct">${t.pct}%</span>
                                                ${influenceSummary ? `
                                                    <span class="preview-trait-influence" title="${influenceSummary}">
                                                        ${influenceSummary}
                                                    </span>
                                                ` : ''}
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : '<div class="empty-hint">Add layers and traits to see spawn probabilities</div>'}

                <!-- Threshold Modifiers Section -->
                ${triggeredModifiers.length > 0 ? `
                <div class="preview-section">
                    <div class="preview-section-title">
                        <span style="color: var(--node-modifier);">â—</span> Threshold Modifiers
                        <span class="preview-section-hint">Would trigger at current variable values</span>
                    </div>
                    <div class="preview-triggered-mods">
                        ${triggeredModifiers.map(mod => {
                            const trigger = mod.config?.trigger;
                            const targetVar = variables.find(v => v.id === trigger?.target || v.id === trigger?.targetId);
                            return `
                                <div class="preview-mod-tag">
                                    âš¡ ${mod.name}
                                    <span class="preview-mod-condition">
                                        (${targetVar?.name || 'var'} ${trigger?.operator || '<'} ${trigger?.value || 0})
                                    </span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                ` : ''}

                ${attributes.length === 0 && variables.length === 0 && probabilities.length === 0 ? `
                    <div class="empty-hint" style="padding: 2rem; text-align: center;">
                        <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">ðŸŽ­</div>
                        <div>Add attributes, layers, and traits to preview spawn probabilities</div>
                    </div>
                ` : ''}
            `;
        }

        // Update the preview panels (both columns)
        function updateUnifiedPreview() {
            // Update two-column layout if it exists
            const statsPanel = document.getElementById('previewStatsColumn');
            const tabContent = document.getElementById('spawnTabContent');

            if (statsPanel && tabContent && spawnLogicActiveTab === 'probabilities') {
                tabContent.innerHTML = renderPreviewProbabilitiesPanel();
                // Don't re-render stats panel as it causes slider focus loss
                return;
            }

            // Fallback: legacy unified panel
            const panel = document.getElementById('unifiedPreviewPanel');
            if (panel) {
                panel.innerHTML = renderUnifiedSpawnPreview();
            }
        }

        // Legacy: Update slider display value and trigger probability recalculation
        function updateSimVariable(varId, value) {
            simulatorValues[varId] = parseFloat(value);

            // Update the display value
            const row = document.querySelector(`.preview-slider-row[data-var-id="${varId}"]`);
            if (row) {
                const valueSpan = row.querySelector('.preview-slider-value');
                if (valueSpan) valueSpan.textContent = value;
            }

            // Recalculate and update the preview
            updateUnifiedPreview();
        }

        function renderSpawnSimBody() {
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const compounds = config.nodes.filter(n => n.type === 'compound');
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
            const simValues = getSimulatorValues();

            // Calculate which modifiers would trigger based on ROLLED variable values
            const triggeredModifiers = modifiers.filter(mod => {
                const trigger = mod.config?.trigger;
                if (!trigger || trigger.type !== 'threshold') return false;

                // Use the multi-condition helper with a getter that uses rolled values
                const getVarValue = (targetId) => {
                    const targetVar = variables.find(v => v.id === targetId);
                    if (!targetVar) return null;

                    // Use rolled value from spawnSimState if available, otherwise fall back to config
                    const rolledVar = spawnSimState.variables[targetVar.id];
                    return rolledVar?.value ?? targetVar.config?.startValue ?? targetVar.config?.initial ?? targetVar.config?.max ?? 100;
                };

                return checkModifierTriggerConditions(trigger, getVarValue);
            });

            // Calculate which compounds would be active based on current traits + modifiers
            const activeTraitIds = new Set(spawnSimState.traits.map(t => t.id));
            const activeModIds = new Set([
                ...spawnSimState.modifiers.map(m => m.id),
                ...triggeredModifiers.map(m => m.id)
            ]);
            const allActiveIds = new Set([...activeTraitIds, ...activeModIds]);

            const activeCompounds = compounds.filter(comp => {
                const reqs = comp.config?.requires || [];
                const logic = comp.config?.requireLogic || 'all';

                if (reqs.length === 0) return false;

                if (logic === 'all') {
                    return reqs.every(reqId => allActiveIds.has(reqId));
                } else {
                    return reqs.some(reqId => allActiveIds.has(reqId));
                }
            });

            // Group available traits by layer for the add menu
            const layers = config.nodes.filter(n => n.type === 'layer');
            const traitsByLayer = {};
            layers.forEach(l => {
                traitsByLayer[l.id] = {
                    name: l.name,
                    traits: traits.filter(t => t.config?.layerId === l.id)
                };
            });

            return `
                <!-- Warning if dirty -->
                <div class="spawn-sim-warning" id="spawnSimWarning" style="display: ${spawnSimState.dirty ? 'flex' : 'none'};">
                    <span>âš ï¸ Settings changed</span>
                    <button class="refresh-btn" onclick="refreshSpawnSim()">Refresh</button>
                </div>

                <!-- Attributes Section -->
                <div class="spawn-sim-section">
                    <div class="spawn-sim-section-title">
                        <span style="color: var(--node-attribute);">â—</span> Attributes
                    </div>
                    <div class="sim-attributes">
                        ${attributes.map(attr => {
                            const min = attr.config?.min ?? 1;
                            const max = attr.config?.max ?? 10;
                            const value = simValues[attr.id] ?? Math.round((min + max) / 2);
                            const affectsCount = config.relationships.filter(r =>
                                r.type === 'weight_influence' && r.sourceId === attr.id
                            ).length;
                            return `
                                <div class="sim-attr-row" data-attr-id="${attr.id}">
                                    <span class="sim-attr-name" title="${attr.name}${affectsCount ? ` (affects ${affectsCount} traits)` : ''}">${attr.name}</span>
                                    <input type="range" class="sim-attr-slider"
                                           min="${min}" max="${max}" step="1" value="${value}"
                                           oninput="updateSimulatorValue('${attr.id}', this.value); this.nextElementSibling.textContent = this.value;"
                                           onmouseenter="previewAttributeInfluences('${attr.id}')"
                                           onmouseleave="clearAttributeInfluencePreview()">
                                    <span class="sim-attr-value">${value}</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>

                <!-- Traits Section -->
                <div class="spawn-sim-section">
                    <div class="spawn-sim-section-title">
                        <span style="color: var(--node-trait);">â—</span> Rolled Traits
                    </div>
                    <div class="sim-traits">
                        ${spawnSimState.traits.map(t => `
                            <div class="sim-trait-tag ${t.locked ? 'active' : ''}" title="${t.layerName} - Click to ${t.locked ? 'unlock' : 'lock'}">
                                <span style="color: var(--accent-gold); font-size: 0.6rem; cursor: pointer;" onclick="toggleTraitLock('${t.id}')" title="${t.locked ? 'Locked (click to unlock)' : 'Unlocked (click to lock)'}">${t.locked ? 'ðŸ”’' : 'ðŸ”“'}</span>
                                ${t.name}
                                <span class="remove-btn" onclick="event.stopPropagation(); removeSimTrait('${t.id}')" title="Remove">âœ•</span>
                            </div>
                        `).join('')}
                        <div class="sim-add-btn" onclick="showAddTraitDropdown(event)" title="Add trait manually">+ Add</div>
                    </div>
                </div>

                <!-- Modifiers Section -->
                <div class="spawn-sim-section">
                    <div class="spawn-sim-section-title">
                        <span style="color: var(--node-modifier);">â—</span> Modifiers
                        ${triggeredModifiers.length > 0 ? `<span style="font-size: 0.6rem; color: var(--text-muted);">(${triggeredModifiers.length} threshold-triggered)</span>` : ''}
                    </div>
                    <div class="sim-modifiers">
                        ${spawnSimState.modifiers.map(m => `
                            <div class="sim-modifier-tag" title="Manually added">
                                ðŸ”’ ${m.name}
                                <span class="remove-btn" onclick="removeSimModifier('${m.id}')" title="Remove">âœ•</span>
                            </div>
                        `).join('')}
                        ${triggeredModifiers.filter(m => !spawnSimState.modifiers.some(sm => sm.id === m.id)).map(m => {
                            const trigger = m.config?.trigger;
                            const targetVar = variables.find(v => v.id === trigger?.targetId);
                            return `
                                <div class="sim-modifier-tag" style="opacity: 0.8;" title="Auto-triggered: ${targetVar?.name || 'var'} ${trigger?.operator || '<'} ${trigger?.value || 0}">
                                    âš¡ ${m.name}
                                </div>
                            `;
                        }).join('')}
                        ${modifiers.length > 0 ? `
                            <div class="sim-add-btn" onclick="showAddModifierDropdown(event)" title="Add modifier">+ Add</div>
                        ` : ''}
                        ${spawnSimState.modifiers.length === 0 && triggeredModifiers.length === 0 ? '<span style="font-size: 0.7rem; color: var(--text-muted); font-style: italic;">None active</span>' : ''}
                    </div>
                </div>

                <!-- Compounds Section -->
                ${compounds.length > 0 ? `
                    <div class="spawn-sim-section">
                        <div class="spawn-sim-section-title">
                            <span style="color: var(--node-compound);">â—</span> Active Compounds
                        </div>
                        <div class="sim-modifiers">
                            ${activeCompounds.length > 0 ? activeCompounds.map(c => {
                                const reqs = c.config?.requires || [];
                                const reqNames = reqs.map(rid => {
                                    const node = config.nodes.find(n => n.id === rid);
                                    return node?.name || rid;
                                }).join(' + ');
                                return `
                                    <div class="sim-modifier-tag" style="background: rgba(139, 58, 58, 0.2); border-color: var(--node-compound);" title="Requires: ${reqNames}">
                                        âœ¨ ${c.name}
                                    </div>
                                `;
                            }).join('') : '<span style="font-size: 0.7rem; color: var(--text-muted); font-style: italic;">None active (need trait+modifier combos)</span>'}
                        </div>
                    </div>
                ` : ''}

                <!-- Variables Section (rolled values, editable) -->
                ${variables.length > 0 ? `
                    <div class="spawn-sim-section">
                        <div class="spawn-sim-section-title">
                            <span style="color: var(--node-variable);">â—</span> Rolled Variables
                            <span style="font-size: 0.6rem; color: var(--text-muted);">(click ðŸ”“ to lock)</span>
                        </div>
                        <div class="sim-variables">
                            ${variables.map(v => {
                                const min = v.config?.min ?? 0;
                                const max = v.config?.max ?? 100;
                                // Use rolled value from state, or fall back to config
                                const rolledVar = spawnSimState.variables[v.id];
                                const startVal = rolledVar?.value ?? v.config?.initial ?? max;
                                const isLocked = rolledVar?.locked ?? false;
                                const pct = ((startVal - min) / (max - min)) * 100;

                                // Show initial range info if available
                                const initialRange = v.config?.initialRange;
                                const rangeInfo = initialRange ? `Range: ${initialRange[0]}-${initialRange[1]}` : '';

                                // Check if any modifier triggers from this variable
                                const relatedMods = triggeredModifiers.filter(m => m.config?.trigger?.targetId === v.id);
                                const hasThreshold = relatedMods.length > 0;
                                const thresholdInfo = relatedMods.map(m => {
                                    const t = m.config?.trigger;
                                    return `${m.name} triggers when ${t?.operator || '<'} ${t?.value}`;
                                }).join(', ');

                                return `
                                    <div class="sim-var-row ${isLocked ? 'locked' : ''}" ${hasThreshold ? 'style="background: rgba(166, 93, 122, 0.1); border-radius: 3px; padding: 0.15rem;"' : ''}
                                         title="${rangeInfo}${thresholdInfo ? (rangeInfo ? ' | ' : '') + thresholdInfo : ''}">
                                        <span class="sim-var-lock" onclick="toggleVariableLock('${v.id}')" style="cursor: pointer; font-size: 0.65rem; color: var(--accent-gold);" title="${isLocked ? 'Locked (click to unlock)' : 'Unlocked (click to lock)'}">${isLocked ? 'ðŸ”’' : 'ðŸ”“'}</span>
                                        <span class="sim-var-name">${v.name}</span>
                                        <input type="range" class="sim-var-slider"
                                               min="${min}" max="${max}" step="1" value="${startVal}"
                                               oninput="updateSimVariable('${v.id}', this.value)"
                                               style="flex: 1; height: 6px; cursor: pointer;">
                                        <span class="sim-var-value" style="min-width: 50px; text-align: right;">${startVal}/${max}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                ` : ''}
            `;
        }

        // Dropdown menus for adding traits/modifiers
        function showAddTraitDropdown(event) {
            event.stopPropagation();
            closeAllDropdowns();

            const layers = config.nodes.filter(n => n.type === 'layer');
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');

            let menuHtml = '<div class="sim-dropdown-menu" id="simDropdownMenu">';
            layers.forEach(layer => {
                const layerTraits = traits.filter(t => t.config?.layerId === layer.id);
                if (layerTraits.length === 0) return;

                menuHtml += `<div class="sim-dropdown-group">${layer.name}</div>`;
                layerTraits.forEach(t => {
                    const alreadyAdded = spawnSimState.traits.some(st => st.id === t.id);
                    menuHtml += `
                        <div class="sim-dropdown-item ${alreadyAdded ? 'disabled' : ''}"
                             onclick="${alreadyAdded ? '' : `addSimTrait('${t.id}'); closeAllDropdowns();`}">
                            ${t.name} ${alreadyAdded ? '<span style="color: var(--text-muted);">(added)</span>' : ''}
                        </div>
                    `;
                });
            });
            menuHtml += '</div>';

            document.body.insertAdjacentHTML('beforeend', menuHtml);
            positionDropdown(event.target, document.getElementById('simDropdownMenu'));

            setTimeout(() => document.addEventListener('click', closeAllDropdowns), 0);
        }

        function showAddModifierDropdown(event) {
            event.stopPropagation();
            closeAllDropdowns();

            const modifiers = config.nodes.filter(n => n.type === 'modifier');

            let menuHtml = '<div class="sim-dropdown-menu" id="simDropdownMenu">';
            modifiers.forEach(m => {
                const alreadyAdded = spawnSimState.modifiers.some(sm => sm.id === m.id);
                menuHtml += `
                    <div class="sim-dropdown-item ${alreadyAdded ? 'disabled' : ''}"
                         onclick="${alreadyAdded ? '' : `addSimModifier('${m.id}'); closeAllDropdowns();`}">
                        ${m.name} ${alreadyAdded ? '<span style="color: var(--text-muted);">(added)</span>' : ''}
                    </div>
                `;
            });
            menuHtml += '</div>';

            document.body.insertAdjacentHTML('beforeend', menuHtml);
            positionDropdown(event.target, document.getElementById('simDropdownMenu'));

            setTimeout(() => document.addEventListener('click', closeAllDropdowns), 0);
        }

        function positionDropdown(anchor, menu) {
            const rect = anchor.getBoundingClientRect();
            menu.style.position = 'fixed';
            menu.style.left = rect.left + 'px';
            menu.style.top = (rect.bottom + 4) + 'px';
            menu.style.zIndex = '10000';
        }

        function closeAllDropdowns() {
            const menu = document.getElementById('simDropdownMenu');
            if (menu) menu.remove();
            document.removeEventListener('click', closeAllDropdowns);
        }

        function spawnPreviewEntity() {
            if (typeof checkEntityLimit === 'function') {
                const check = checkEntityLimit();
                if (!check.allowed) {
                    showToast(check.reason, 'warning', TIER_TOAST_DURATION);
                    return;
                }
            }
            const presetSelector = document.getElementById('spawnPresetSelector');
            const presetId = presetSelector ? presetSelector.value : '';

            // Use current sim state attributes for the spawn
            const overrideAttributes = {};
            const simValues = getSimulatorValues();
            Object.keys(simValues).forEach(attrId => {
                overrideAttributes[attrId] = simValues[attrId];
            });

            // Also use rolled variable values
            const overrideVariables = {};
            Object.keys(spawnSimState.variables).forEach(varId => {
                overrideVariables[varId] = spawnSimState.variables[varId].value;
            });

            const entity = simulateSpawn(presetId, overrideAttributes, overrideVariables);
            // Evaluate threshold traits based on initial variable values
            recalculatePreviewEntity(entity);
            // Also evaluate threshold modifiers for the entity
            recalculateEntityState(entity);

            // Add to spawn logic display
            spawnLogicEntities.unshift(entity);
            if (spawnLogicEntities.length > 10) spawnLogicEntities.pop(); // Limit to 10

            // Also add to preview entities for entities tab
            previewEntities.unshift(entity);
            if (previewEntities.length > 50) previewEntities.pop();

            // Auto-transition to State Mode showing the new entity
            enterStateMode(entity.id);
        }

        function spawnMultipleEntities(count) {
            if (typeof TIER_LIMITS !== 'undefined' && TIER_LIMITS.maxEntities) {
                const remaining = TIER_LIMITS.maxEntities - previewEntities.length;
                if (remaining <= 0) {
                    showToast(`Free tier limited to ${TIER_LIMITS.maxEntities} entities. Upgrade for unlimited!`, 'warning', TIER_TOAST_DURATION);
                    return;
                }
                count = Math.min(count, remaining);
            }
            const presetSelector = document.getElementById('spawnPresetSelector');
            const presetId = presetSelector ? presetSelector.value : '';
            for (let i = 0; i < count; i++) {
                const entity = simulateSpawn(presetId);
                // Evaluate threshold traits based on initial variable values
                recalculatePreviewEntity(entity);
                previewEntities.unshift(entity);
            }
            if (previewEntities.length > 50) {
                previewEntities = previewEntities.slice(0, 50);
            }
            renderPreviewView(document.getElementById('viewContent'));
        }

        function clearPreviewEntities() {
            previewEntities = [];
            renderPreviewView(document.getElementById('viewContent'));
        }

        // Quick spawn for Entities tab (spawns and stays on Entities view)
        function quickSpawnForEntities() {
            // Switch to Simulation tab and spawn there
            switchView('simulation');
            spawnPreviewEntity();
        }

        // Update spawned entities display in Spawn Logic tab
        function updateSpawnLogicEntitiesDisplay() {
            // Update entities tab content if it's the active tab
            if (spawnLogicActiveTab === 'entities') {
                const tabContent = document.getElementById('spawnTabContent');
                if (tabContent) {
                    tabContent.innerHTML = renderEntitiesTabContent();
                }
            }
            // Always update the tab badge count
            const tabBar = document.querySelector('.spawn-tab-bar');
            if (tabBar) {
                const entitiesTab = tabBar.querySelectorAll('.spawn-tab')[1];
                if (entitiesTab) {
                    entitiesTab.innerHTML = `Entities${spawnLogicEntities.length > 0 ? `<span class="tab-badge">${spawnLogicEntities.length}</span>` : ''}`;
                }
            }
            // Always update the entity tray
            const tray = document.getElementById('entityTray');
            if (tray) {
                tray.innerHTML = renderEntityTray();
            }
        }

        // v3.3 Session 4: renderSpawnLogicEntities() deleted â€” replaced by renderEntityTray()

        function removeSpawnLogicEntity(entityId) {
            const wasViewing = selectedSpawnEntityId === entityId;
            if (wasViewing) {
                selectedSpawnEntityId = null;
            }
            spawnLogicEntities = spawnLogicEntities.filter(e => e.id !== entityId);

            // If in state mode viewing the removed entity, exit back to spawn mode
            if (wasViewing && simulationMode === 'state') {
                exitStateMode();
                return; // exitStateMode re-renders everything
            }
            updateSpawnLogicEntitiesDisplay();
        }

        function promoteToEntityManager(entityId) {
            const entity = spawnLogicEntities.find(e => e.id === entityId);
            if (!entity) return;

            // Add to managed entities active list
            if (!managedEntities.active.find(e => e.id === entityId)) {
                const promoted = JSON.parse(JSON.stringify(entity));
                promoted.configId = config.id;
                promoted.activatedAt = Date.now();
                promoted.createdAt = promoted.createdAt || Date.now();
                promoted.poolId = promoted.poolId || 'default';
                managedEntities.active.unshift(promoted);
            }

            // Also keep in previewEntities for backwards compat
            if (!previewEntities.find(e => e.id === entityId)) {
                previewEntities.unshift(entity);
            }

            // Update entity tray
            const tray = document.getElementById('entityTray');
            if (tray) tray.innerHTML = renderEntityTray();

            // Show success message with link to Persistence
            showToast(`${entity.name || 'Entity'} saved â€” <a onclick="switchView('persistence'); persistenceSection='saved';" style="color:var(--accent-copper);cursor:pointer;text-decoration:underline;">View in Persistence</a>`);
            saveToStorage();
        }

        function clearSpawnLogicEntities() {
            spawnLogicEntities = [];
            if (simulationMode === 'state') {
                simulationMode = 'spawn';
                selectedSpawnEntityId = null;
                if (savedNewSpawnValues) {
                    simulatorValues = savedNewSpawnValues;
                    savedNewSpawnValues = null;
                }
            }
            selectedSpawnEntityId = null;
        }

        // ========================================
        // SPAWN TAB SWITCHING & ENTITY DETAIL
        // ========================================

        // TODO v3.3: Still used by spawn-mode sub-tabs (Probabilities/Entities). Will be removed when
        // those sub-tabs are eliminated in Session 4 (entities move to Persistence, probabilities is default).
        function switchSpawnTab(tabName) {
            if (spawnLogicActiveTab === tabName) return;

            // When switching away from entities tab, deselect entity
            if (spawnLogicActiveTab === 'entities' && selectedSpawnEntityId) {
                selectedSpawnEntityId = null;
            }

            spawnLogicActiveTab = tabName;
            renderPreviewView(document.getElementById('viewContent'));
        }

        // Toggle inline expand/collapse of an entity in the Entities sub-tab
        function toggleSpawnEntityExpand(entityId) {
            if (selectedSpawnEntityId === entityId) {
                // Collapse: deselect
                selectedSpawnEntityId = null;
            } else {
                // Expand: select this entity
                selectedSpawnEntityId = entityId;
            }
            refreshEntitiesTab();
        }

        // Open the full two-column state view for an entity (replaces the whole preview)
        // Open full two-column state view â€” delegates to enterStateMode
        function openFullEntityState(entityId) {
            enterStateMode(entityId);
        }

        // Refresh just the Entities sub-tab content without replacing the whole view
        function refreshEntitiesTab() {
            const tabContent = document.getElementById('spawnTabContent');
            if (tabContent && spawnLogicActiveTab === 'entities') {
                tabContent.innerHTML = renderEntitiesTabContent();
            }
        }

        // Legacy: selectSpawnEntity now just toggles expand (used by old callers)
        function selectSpawnEntity(entityId) {
            toggleSpawnEntityExpand(entityId);
        }

        // DEPRECATED v3.3: Use exitStateMode() for stateâ†’spawn transitions. This remains for
        // legacy callers that just need to deselect without a full mode switch.
        function deselectSpawnEntity() {
            selectedSpawnEntityId = null;

            // Restore saved "New Spawn" simulator values
            if (savedNewSpawnValues) {
                simulatorValues = savedNewSpawnValues;
                savedNewSpawnValues = null;
            }
        }

        function renderEntitiesTabContent() {
            // Always show the list with inline expand â€” never replace the whole view
            return renderEntityListView();
        }

        function renderEntityListView() {
            if (spawnLogicEntities.length === 0) {
                return '<div class="spawn-empty-msg">No entities spawned yet. Click "ðŸŽ² Spawn Entity" to create one.</div>';
            }

            return `
                <div style="display: flex; justify-content: flex-end; padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--border-color);">
                    <button class="btn btn-xs" onclick="clearSpawnLogicEntities()" title="Clear all spawned entities"
                            style="font-size: 0.65rem;">Clear All</button>
                </div>
                ${spawnLogicEntities.map((entity, idx) => {
                    const isExpanded = selectedSpawnEntityId === entity.id;
                    const traitNames = entity.traits.filter(t => t.active !== false).map(t => t.name || t.id).slice(0, 3);
                    const moreCount = entity.traits.filter(t => t.active !== false).length - 3;
                    const activeModifiers = entity.modifiers || [];
                    const activeCompounds = entity.compounds || [];
                    const derivedEntries = Object.entries(entity.variables || {}).filter(([id, v]) => v.derived);

                    return `
                        <div class="entity-list-item-wrap ${isExpanded ? 'expanded' : ''}" data-entity-id="${entity.id}">
                            <div class="entity-list-item ${idx === 0 && !isExpanded ? 'newest' : ''} ${isExpanded ? 'selected' : ''}"
                                 onclick="toggleSpawnEntityExpand('${entity.id}')">
                                <span class="entity-expand-arrow">${isExpanded ? 'â–¼' : 'â–¶'}</span>
                                <span class="entity-list-name">${entity.name || 'Entity'}</span>
                                <div class="entity-list-traits">
                                    ${traitNames.map(t => `<span class="entity-list-trait">${t}</span>`).join('')}
                                    ${moreCount > 0 ? `<span style="font-size:0.6rem; color:var(--text-muted);">+${moreCount}</span>` : ''}
                                </div>
                            </div>
                            ${isExpanded ? `
                            <div class="entity-inline-detail">
                                <!-- Traits by layer -->
                                <div class="entity-inline-section">
                                    <span class="entity-inline-label">Traits</span>
                                    <div class="entity-detail-badges">
                                        ${entity.traits.filter(t => t.active !== false).map(t =>
                                            `<span class="entity-detail-badge trait-badge">${t.name || t.id}</span>`
                                        ).join('') || '<span style="font-size: 0.65rem; color: var(--text-muted); font-style: italic;">None</span>'}
                                    </div>
                                </div>

                                <!-- Active modifiers -->
                                ${activeModifiers.length > 0 ? `
                                <div class="entity-inline-section">
                                    <span class="entity-inline-label">Modifiers</span>
                                    <div class="entity-detail-badges">
                                        ${activeModifiers.map(m => `<span class="entity-detail-badge mod-badge">${m.name || m.id || m}</span>`).join('')}
                                    </div>
                                </div>
                                ` : ''}

                                <!-- Active compounds -->
                                ${activeCompounds.length > 0 ? `
                                <div class="entity-inline-section">
                                    <span class="entity-inline-label">Compounds</span>
                                    <div class="entity-detail-badges">
                                        ${activeCompounds.map(c => `<span class="entity-detail-badge compound-badge">${c.name || c.id || c}</span>`).join('')}
                                    </div>
                                </div>
                                ` : ''}

                                <!-- Derived values -->
                                ${derivedEntries.length > 0 ? `
                                <div class="entity-inline-section">
                                    <span class="entity-inline-label">Derived</span>
                                    <div class="entity-detail-badges">
                                        ${derivedEntries.map(([id, v]) =>
                                            `<span class="entity-detail-badge" style="background: rgba(80, 180, 80, 0.15); color: var(--node-derived);">${v.name}: ${Math.round(v.value * 100) / 100}</span>`
                                        ).join('')}
                                    </div>
                                </div>
                                ` : ''}

                                <!-- Action buttons -->
                                <div class="entity-inline-actions">
                                    <button class="btn btn-xs btn-primary" onclick="event.stopPropagation(); openFullEntityState('${entity.id}')" title="Open full two-column state view">
                                        Open Full View
                                    </button>
                                    <button class="btn btn-xs" onclick="event.stopPropagation(); promoteToEntityManager('${entity.id}')" title="Save to Entities Manager">
                                        ðŸ“¤ Promote
                                    </button>
                                    <button class="btn btn-xs" onclick="event.stopPropagation(); removeSpawnLogicEntity('${entity.id}'); refreshEntitiesTab();" title="Remove">
                                        âœ•
                                    </button>
                                </div>
                            </div>
                            ` : ''}
                        </div>
                    `;
                }).join('')}
            `;
        }

        // ========================================
        // UNIFIED ENTITY STATE RENDERER
        // Replaces the three redundant entity detail views
        // ========================================

        /**
         * Render a two-column entity state view.
         * Left = input (things you adjust), Right = output (resulting state)
         * @param {Object} entity - Entity object
         * @param {Object} opts - Options:
         *   editableAttributes {boolean} - Can edit attribute values
         *   editableTraits {boolean} - Can toggle traits on/off
         *   showModifierToggles {boolean} - Show force-apply/remove buttons
         *   showTickControls {boolean} - Show tick button
         *   showPoolAssignment {boolean} - Show pool dropdown
         *   showSaveAsPreset {boolean} - Show save-as-preset button
         *   showPromoteButton {boolean} - Show promote button
         *   context {'simulation'|'persistence'} - Which entity store to use
         */
        function renderUnifiedEntityState(entity, opts = {}) {
            if (!entity) return '<div class="entity-state-empty">No entity selected</div>';
            return `
                <div class="entity-state-input" id="entityStateInput">
                    ${renderEntityInputColumn(entity, opts)}
                </div>
                <div class="entity-state-output" id="entityStateOutput">
                    ${renderEntityOutputColumn(entity, opts)}
                </div>
            `;
        }

        function renderEntityInputColumn(entity, opts) {
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');

            const updateFn = opts.context === 'persistence' ? 'updateManagedEntityVariable' : 'updateUnifiedEntityVariable';
            const attrUpdateFn = opts.context === 'persistence' ? 'updateManagedEntityAttribute' : 'updateUnifiedEntityAttribute';

            // Calculate triggered modifiers based on entity's current variable values
            const triggeredModifiers = modifiers.filter(mod => {
                const trigger = mod.config?.trigger;
                if (!trigger || trigger.type !== 'threshold') return false;
                const getVarValue = (targetId) => entity.variables[targetId]?.value ?? 0;
                return checkModifierTriggerConditions(trigger, getVarValue);
            });

            return `
                <div class="stats-panel">
                    <!-- Attributes Section -->
                    ${attributes.length > 0 ? `
                    <div class="stats-section">
                        <div class="stats-section-title">
                            <span style="color: var(--node-attribute);">â—</span> Attributes
                            ${opts.editableAttributes ? '<span class="stats-section-hint">editable</span>' : ''}
                        </div>
                        <div class="stats-sliders">
                            ${attributes.map(attr => {
                                const val = entity.attributes[attr.id]?.value ?? 0;
                                const min = attr.config?.min ?? 1;
                                const max = attr.config?.max ?? 10;
                                const pct = ((val - min) / (max - min)) * 100;
                                if (opts.editableAttributes) {
                                    return `
                                        <div class="stats-slider-row">
                                            <span class="stats-slider-name" title="${attr.name}">${attr.name}</span>
                                            <div class="stats-slider-control">
                                                <input type="range" class="stats-slider" data-id="${attr.id}"
                                                       min="${min}" max="${max}" step="1" value="${val}"
                                                       oninput="${attrUpdateFn}('${entity.id}', '${attr.id}', parseFloat(this.value))">
                                                <input type="number" class="stats-slider-input" data-id="${attr.id}"
                                                       min="${min}" max="${max}" value="${val}"
                                                       onchange="${attrUpdateFn}('${entity.id}', '${attr.id}', Math.min(${max}, Math.max(${min}, parseFloat(this.value))))">
                                            </div>
                                        </div>
                                    `;
                                } else {
                                    return `
                                        <div class="stats-slider-row">
                                            <span class="stats-slider-name" title="${attr.name}">${attr.name}</span>
                                            <div class="stats-slider-control">
                                                <input type="range" class="stats-slider" min="${min}" max="${max}" step="1" value="${val}" disabled style="opacity: 0.7;">
                                                <input type="number" class="stats-slider-input" min="${min}" max="${max}" value="${val}" disabled style="opacity: 0.7;">
                                            </div>
                                        </div>
                                    `;
                                }
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Variables Section -->
                    ${variables.length > 0 ? `
                    <div class="stats-section">
                        <div class="stats-section-title">
                            <span style="color: var(--node-variable);">â—</span> Variables
                            <span class="stats-section-hint">Adjust to test thresholds</span>
                        </div>
                        <div class="stats-sliders">
                            ${variables.map(v => {
                                const variable = entity.variables[v.id];
                                if (!variable || variable.derived) return '';
                                const min = v.config?.min ?? 0;
                                const max = v.config?.max ?? 100;
                                const val = variable.value;
                                const rateDisplay = variable.rate ? `<span style="font-size: 0.6rem; color: ${variable.rate > 0 ? 'var(--accent-success)' : 'var(--accent-danger)'}">${variable.rate > 0 ? '+' : ''}${variable.rate}/s</span>` : '';
                                return `
                                    <div class="stats-slider-row" data-var-id="${v.id}">
                                        <span class="stats-slider-name" title="${v.name}">${v.name} ${rateDisplay}</span>
                                        <div class="stats-slider-control">
                                            <input type="range" class="stats-slider stats-slider-var" data-id="${v.id}"
                                                   min="${min}" max="${max}" step="1" value="${val}"
                                                   oninput="${updateFn}('${entity.id}', '${v.id}', parseFloat(this.value))">
                                            <input type="number" class="stats-slider-input" data-id="${v.id}"
                                                   min="${min}" max="${max}" value="${Math.round(val)}"
                                                   onchange="${updateFn}('${entity.id}', '${v.id}', Math.min(${max}, Math.max(${min}, parseFloat(this.value))))">
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Modifiers Section (force-toggle for simulation) -->
                    ${modifiers.length > 0 && opts.showModifierToggles ? `
                    <div class="stats-section">
                        <div class="stats-section-title">
                            <span style="color: var(--node-modifier);">â—</span> Modifiers
                            <span class="stats-section-hint">${(entity.modifiers || []).length} active</span>
                        </div>
                        <div class="modifiers-list">
                            ${modifiers.map(mod => {
                                const trigger = mod.config?.trigger;
                                const triggerType = trigger?.type || mod.config?.triggerType;
                                const isThreshold = triggerType === 'threshold';
                                const entityModIds = new Set((entity.modifiers || []).map(m => m.id || m));
                                const isEntityActive = entityModIds.has(mod.id);
                                const isForceApplied = window._forceAppliedModifiers?.has(mod.id);
                                const isForceRemoved = window._forceRemovedModifiers?.has(mod.id);
                                const isTriggered = triggeredModifiers.some(tm => tm.id === mod.id) && !isForceRemoved;
                                const isActive = isForceApplied || isTriggered || isEntityActive;

                                const activeClass = isActive ? 'active' : '';
                                const triggeredClass = isTriggered ? 'triggered' : '';
                                const forcedClass = isForceApplied ? 'forced' : '';
                                const removedClass = isForceRemoved ? 'force-removed' : '';
                                const btnIcon = isActive ? 'âœ“' : 'â—‹';
                                const btnTitle = isActive ? 'Click to deactivate' : 'Click to force-apply';

                                const thresholdBadge = isThreshold ? '<span class="mod-threshold-badge">âš¡</span>' : '';
                                let statusBadge = '';
                                if (isForceRemoved) {
                                    statusBadge = '<span class="mod-removed-badge">off</span>';
                                } else if (isTriggered && !isForceApplied) {
                                    statusBadge = '<span class="mod-auto-badge">auto</span>';
                                } else if (isForceApplied) {
                                    statusBadge = '<span class="mod-forced-badge">forced</span>';
                                } else if (isEntityActive) {
                                    statusBadge = '<span class="mod-auto-badge">on</span>';
                                }

                                return '<div class="mod-item ' + activeClass + ' ' + triggeredClass + ' ' + forcedClass + ' ' + removedClass + '" data-mod-id="' + mod.id + '">' +
                                    '<button class="mod-toggle-btn ' + (isActive ? 'on' : 'off') + '" onclick="event.stopPropagation(); toggleForceModifier(\'' + mod.id + '\')" title="' + btnTitle + '">' + btnIcon + '</button>' +
                                    '<a class="mod-name-link" onclick="openNodeInEditor(\'' + mod.id + '\')">' + mod.name + '</a>' +
                                    thresholdBadge + statusBadge +
                                '</div>';
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    ${opts.showTickControls ? `
                    <div class="stats-section">
                        <div class="stats-section-title">
                            <span style="color: var(--text-muted);">â—</span> Tick Controls
                        </div>
                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                            <button class="btn btn-sm ${autoTickEnabled ? 'btn-success' : ''}" onclick="toggleAutoTick()">
                                ${autoTickEnabled ? 'â¸ Pause' : 'â–¶ Auto-Tick'}
                            </button>
                            <button class="btn btn-sm" onclick="tickAllActiveEntities()" ${autoTickEnabled ? 'disabled' : ''}>
                                â­ Tick Once
                            </button>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
        }

        function renderEntityOutputColumn(entity, opts) {
            // Group traits by layer
            const traitsByLayer = {};
            const activeTraits = (entity.traits || []).filter(t => t.active !== false);
            const inactiveTraits = (entity.traits || []).filter(t => t.active === false);
            activeTraits.forEach(t => {
                const layerName = t.layer || 'Unknown';
                if (!traitsByLayer[layerName]) traitsByLayer[layerName] = [];
                traitsByLayer[layerName].push(t);
            });

            // Derived values
            const derivedEntries = Object.entries(entity.variables || {}).filter(([id, v]) => v.derived);

            return `
                <!-- Traits Section -->
                <div class="entity-state-section">
                    <div class="entity-state-section-title">
                        Traits
                        ${opts.editableTraits ? `
                            <span class="edit-hint">(click to toggle)</span>
                            <button class="add-btn-inline trait-btn" onclick="showTraitMenu(event, '${entity.id}')" title="Add trait">+</button>
                        ` : ''}
                    </div>
                    ${opts.editableTraits ? `
                        <div class="preview-traits" id="entityStateTraits">
                            ${activeTraits.map(trait => `
                                <div class="preview-trait active ${trait.threshold ? 'threshold-trait' : ''}"
                                     onclick="toggleManagedEntityTrait('${entity.id}', '${trait.id}')"
                                     title="${trait.trigger || (trait.threshold ? 'Threshold-triggered' : 'Click to deactivate')}">
                                    <span class="trait-toggle">â—</span>
                                    <span class="trait-name">${trait.name}</span>
                                    <span class="trait-layer">${trait.layer || ''}</span>
                                    ${trait.threshold ? '<span class="trait-type">âš¡</span>' : ''}
                                </div>
                            `).join('')}
                            ${inactiveTraits.map(trait => `
                                <div class="preview-trait inactive"
                                     onclick="toggleManagedEntityTrait('${entity.id}', '${trait.id}')"
                                     title="Click to activate">
                                    <span class="trait-toggle">â—‹</span>
                                    <span class="trait-name">${trait.name}</span>
                                    <span class="trait-layer">${trait.layer || ''}</span>
                                </div>
                            `).join('')}
                            ${activeTraits.length === 0 && inactiveTraits.length === 0 ? '<div class="no-items-msg">No traits assigned</div>' : ''}
                        </div>
                    ` : `
                        <div id="entityStateTraits">
                            ${Object.keys(traitsByLayer).length > 0 ? Object.entries(traitsByLayer).map(([layerName, traits]) => `
                                <div class="entity-detail-layer-group">
                                    <div class="entity-detail-layer-name">â—ˆ ${layerName}</div>
                                    <div class="entity-detail-badges">
                                        ${traits.map(t => `<span class="entity-detail-badge trait-badge">${t.name || t.id}</span>`).join('')}
                                    </div>
                                </div>
                            `).join('') : '<div class="no-items-msg" style="font-size: 0.7rem; color: var(--text-muted);">No active traits</div>'}
                        </div>
                    `}
                </div>

                <!-- Modifiers Section -->
                <div class="entity-state-section">
                    <div class="entity-state-section-title">
                        Modifiers
                        ${opts.editableTraits ? `<button class="add-btn-inline modifier-btn" onclick="showModifierMenu(event, '${entity.id}')" title="Add modifier">+</button>` : ''}
                    </div>
                    <div id="entityStateModifiers">
                        ${renderModifiersSection(entity)}
                    </div>
                </div>

                <!-- Compounds Section -->
                <div class="entity-state-section">
                    <div class="entity-state-section-title">
                        Compounds
                        ${opts.editableTraits ? `<button class="add-btn-inline compound-btn" onclick="showCompoundMenu(event, '${entity.id}')" title="Add compound">+</button>` : ''}
                    </div>
                    <div id="entityStateCompounds">
                        ${renderCompoundsSection(entity)}
                    </div>
                </div>

                <!-- Derived Values -->
                ${derivedEntries.length > 0 ? `
                <div class="entity-state-section">
                    <div class="entity-state-section-title">Derived Values</div>
                    <div id="entityStateDerived">
                        ${derivedEntries.map(([id, v]) => `
                            <div class="entity-attr-row">
                                <span class="entity-attr-label">${v.name}</span>
                                <span class="entity-attr-value" style="color: var(--node-derived);">${Math.round(v.value * 100) / 100}</span>
                                ${v.breakdown ? `<span style="font-size: 0.6rem; color: var(--text-muted); margin-left: 0.25rem;">(${v.breakdown})</span>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
                ` : ''}

                <!-- Pool Assignment (optional) -->
                ${opts.showPoolAssignment ? `
                <div class="entity-state-section">
                    <div class="entity-state-section-title">Pool Assignment</div>
                    <div class="entity-pool-select">
                        <select onchange="handlePoolAssignmentChange('${entity.id}', this.value, this)">
                            ${Array.from(poolConfigs.values()).map(pool =>
                                `<option value="${pool.id}" ${(entity.poolId || 'default') === pool.id ? 'selected' : ''}>${pool.name}</option>`
                            ).join('')}
                            <option value="__new__">+ Add New Pool</option>
                        </select>
                    </div>
                </div>
                ` : ''}

                <!-- Save as Preset (optional) -->
                ${opts.showSaveAsPreset ? `
                <div class="entity-state-section">
                    <button class="btn btn-sm" onclick="openSaveAsPresetModal('${entity.id}')" style="width: 100%;">
                        Save as Preset
                    </button>
                </div>
                ` : ''}
            `;
        }

        // Unified variable update handler for entity state views
        function updateUnifiedEntityVariable(entityId, varId, value) {
            // Try spawn logic entities first, then managed entities
            let entity = spawnLogicEntities.find(e => e.id === entityId);
            if (!entity) {
                entity = findEntityById ? findEntityById(entityId) : null;
            }
            if (!entity || !entity.variables[varId]) return;

            const numValue = parseFloat(value);
            entity.variables[varId].value = numValue;

            // Sync slider and number input (preserve focus)
            const slider = document.querySelector(`.stats-slider[data-id="${varId}"]`);
            const input = document.querySelector(`.stats-slider-input[data-id="${varId}"]`);
            if (slider && document.activeElement !== slider) slider.value = numValue;
            if (input && document.activeElement !== input) input.value = Math.round(numValue);

            // Update simulatorValues for consistency
            simulatorValues[varId] = numValue;

            // Recalculate modifiers, compounds, derived values
            recalculateEntityState(entity);

            // Update output column sections via targeted DOM updates
            const modsEl = document.getElementById('entityStateModifiers');
            if (modsEl) modsEl.innerHTML = renderModifiersSection(entity);

            const compsEl = document.getElementById('entityStateCompounds');
            if (compsEl) compsEl.innerHTML = renderCompoundsSection(entity);

            // Update derived values
            const derivedEl = document.getElementById('entityStateDerived');
            if (derivedEl) {
                const derivedEntries = Object.entries(entity.variables || {}).filter(([id, v]) => v.derived);
                derivedEl.innerHTML = derivedEntries.map(([id, v]) => `
                    <div class="entity-attr-row">
                        <span class="entity-attr-label">${v.name}</span>
                        <span class="entity-attr-value" style="color: var(--node-derived);">${Math.round(v.value * 100) / 100}</span>
                        ${v.breakdown ? `<span style="font-size: 0.6rem; color: var(--text-muted); margin-left: 0.25rem;">(${v.breakdown})</span>` : ''}
                    </div>
                `).join('');
            }

            // Update modifier count in input column hint
            const modHint = document.querySelector('#entityStateInput .stats-section-hint');
            if (modHint) modHint.textContent = `${(entity.modifiers || []).length} active`;
        }

        // Unified attribute update handler for entity state views
        function updateUnifiedEntityAttribute(entityId, attrId, value) {
            let entity = spawnLogicEntities.find(e => e.id === entityId);
            if (!entity) {
                entity = findEntityById ? findEntityById(entityId) : null;
            }
            if (!entity || !entity.attributes[attrId]) return;

            const numValue = parseFloat(value);
            entity.attributes[attrId].value = numValue;

            // Sync slider and number input (preserve focus)
            const slider = document.querySelector(`.stats-slider[data-id="${attrId}"]`);
            const input = document.querySelector(`.stats-slider-input[data-id="${attrId}"]`);
            if (slider && document.activeElement !== slider) slider.value = numValue;
            if (input && document.activeElement !== input) input.value = Math.round(numValue);

            // Recalculate state
            recalculateEntityState(entity);

            // Update output column sections
            const modsEl = document.getElementById('entityStateModifiers');
            if (modsEl) modsEl.innerHTML = renderModifiersSection(entity);
            const compsEl = document.getElementById('entityStateCompounds');
            if (compsEl) compsEl.innerHTML = renderCompoundsSection(entity);
        }

        // v3.3 Session 4: renderEntityDetailView() deleted â€” replaced by renderUnifiedEntityState()

        function updateEntityVariable(entityId, varId, value) {
            const entity = spawnLogicEntities.find(e => e.id === entityId);
            if (!entity || !entity.variables[varId]) return;

            const numValue = parseFloat(value);
            entity.variables[varId].value = numValue;

            // Sync slider and number input in left panel (don't re-render to preserve focus)
            const slider = document.querySelector(`.stats-slider[data-id="${varId}"]`);
            const input = document.querySelector(`.stats-slider-input[data-id="${varId}"]`);
            if (slider && document.activeElement !== slider) slider.value = numValue;
            if (input && document.activeElement !== input) input.value = Math.round(numValue);

            // Also sync the entity detail slider in right panel
            const detailSlider = document.querySelector(`.entity-var-slider[data-id="${varId}"]`);
            if (detailSlider && document.activeElement !== detailSlider) detailSlider.value = numValue;
            const detailValue = document.getElementById(`entityVar_${varId}`);
            if (detailValue) detailValue.textContent = Math.round(numValue);

            // Update simulatorValues for consistency
            simulatorValues[varId] = numValue;

            // Recalculate modifiers, compounds, derived values
            recalculateEntityState(entity);

            // Update left panel modifiers count and badges
            const entityModList = document.getElementById('entityStatsModifiers');
            if (entityModList) {
                const activeModIds = new Set((entity.modifiers || []).map(m => m.id || m));
                const thresholdModifiers = config.nodes.filter(n => n.type === 'modifier' && n.config?.trigger?.type === 'threshold');
                entityModList.innerHTML = thresholdModifiers.map(mod => {
                    const isActive = activeModIds.has(mod.id);
                    return `<span class="mod-item ${isActive ? 'triggered' : ''}" title="${mod.name}${isActive ? ' (active)' : ' (inactive)'}">
                        ${mod.name}${isActive ? '<span class="mod-badge" style="background: var(--accent-success); color: #fff; font-size: 0.55rem; padding: 0 3px; border-radius: 2px; margin-left: 3px;">auto</span>' : ''}
                    </span>`;
                }).join('');
                // Update hint count
                const hint = entityModList.closest('.stats-section')?.querySelector('.stats-section-hint');
                if (hint) hint.textContent = `${activeModIds.size} active`;
            }
        }

        function recalculateEntityState(entity) {
            // Recalculate threshold modifiers based on current variable values
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            entity.modifiers = [];

            modifiers.forEach(mod => {
                const trigger = mod.config?.trigger;
                if (!trigger || trigger.type !== 'threshold') return;

                const getVarValue = (targetId) => {
                    if (entity.variables[targetId]) return entity.variables[targetId].value;
                    if (entity.attributes[targetId]) return entity.attributes[targetId].value;
                    // Check if it's a trait/modifier active check
                    const activeTrait = entity.traits.find(t => t.id === targetId && t.active !== false);
                    if (activeTrait) return 1;
                    const activeMod = entity.modifiers.find(m => (m.id || m) === targetId);
                    if (activeMod) return 1;
                    return 0;
                };

                if (checkModifierTriggerConditions(trigger, getVarValue)) {
                    entity.modifiers.push({ id: mod.id, name: mod.name });
                }
            });

            // Recalculate compounds
            recalculatePreviewEntity(entity);
        }

        // v3.3 Session 4: updateEntityDetailSections() deleted â€” targeted old DOM IDs
        // v3.3 Session 4: renderEntityStatsPanel() deleted â€” replaced by renderEntityInputColumn()

        // showToast is provided by utils.js â€” supports showToast(msg, type, duration)
        // See js/utils.js for the unified implementation

        // ========================================
        // PREVIEW TICK SYSTEM CONTROLS
        // ========================================
        function togglePreviewTickActive(tickSystemId) {
            if (!previewTickStates[tickSystemId]) {
                previewTickStates[tickSystemId] = { active: false, currentTick: 0 };
            }
            previewTickStates[tickSystemId].active = !previewTickStates[tickSystemId].active;

            // Stop timer if deactivating
            if (!previewTickStates[tickSystemId].active && previewTickIntervals[tickSystemId]) {
                clearInterval(previewTickIntervals[tickSystemId]);
                delete previewTickIntervals[tickSystemId];
            }

            renderPreviewView(document.getElementById('viewContent'));
        }

        function advancePreviewTick(tickSystemId) {
            if (!previewTickStates[tickSystemId]) {
                previewTickStates[tickSystemId] = { active: true, currentTick: 0 };
            }
            previewTickStates[tickSystemId].currentTick++;
            previewTickStates[tickSystemId].active = true;

            // Process modifier durations for all preview entities
            processTickAdvance(tickSystemId);

            renderPreviewView(document.getElementById('viewContent'));
        }

        function resetPreviewTick(tickSystemId) {
            if (previewTickIntervals[tickSystemId]) {
                clearInterval(previewTickIntervals[tickSystemId]);
                delete previewTickIntervals[tickSystemId];
            }
            previewTickStates[tickSystemId] = { active: false, currentTick: 0 };

            // Reset modifier durations for all preview entities
            previewEntities.forEach(entity => {
                if (entity.modifierDurations) {
                    Object.keys(entity.modifierDurations).forEach(modId => {
                        if (entity.modifierDurations[modId][tickSystemId] !== undefined) {
                            const modNode = config.nodes.find(n => n.id === modId);
                            const binding = modNode?.config?.tickBindings?.find(b => b.tickSystemId === tickSystemId);
                            if (binding) {
                                entity.modifierDurations[modId][tickSystemId] = binding.duration;
                            }
                        }
                    });
                }
            });

            renderPreviewView(document.getElementById('viewContent'));
        }

        function togglePreviewTickTimer(tickSystemId) {
            const ts = config.nodes.find(n => n.id === tickSystemId);
            if (!ts) return;

            const interval = ts.config?.tickUnit?.value || 1000;

            if (previewTickIntervals[tickSystemId]) {
                // Stop the timer
                clearInterval(previewTickIntervals[tickSystemId]);
                delete previewTickIntervals[tickSystemId];
            } else {
                // Start the timer
                if (!previewTickStates[tickSystemId]) {
                    previewTickStates[tickSystemId] = { active: true, currentTick: 0 };
                }
                previewTickStates[tickSystemId].active = true;

                previewTickIntervals[tickSystemId] = setInterval(() => {
                    advancePreviewTick(tickSystemId);
                }, interval);
            }

            renderPreviewView(document.getElementById('viewContent'));
        }

        function processTickAdvance(tickSystemId) {
            // For each preview entity, decrement modifier durations bound to this tick system
            previewEntities.forEach(entity => {
                if (!entity.modifierDurations) entity.modifierDurations = {};
                if (!entity.modifiers) entity.modifiers = [];

                // Check each active modifier
                const expiredModifiers = [];
                entity.modifiers.forEach(mod => {
                    const modNode = config.nodes.find(n => n.id === mod.id);
                    if (!modNode) return;

                    const binding = modNode.config?.tickBindings?.find(b => b.tickSystemId === tickSystemId);
                    if (!binding) return;

                    // Initialize duration tracking if needed
                    if (!entity.modifierDurations[mod.id]) {
                        entity.modifierDurations[mod.id] = {};
                    }
                    if (entity.modifierDurations[mod.id][tickSystemId] === undefined) {
                        entity.modifierDurations[mod.id][tickSystemId] = binding.duration;
                    }

                    // Decrement duration
                    entity.modifierDurations[mod.id][tickSystemId]--;

                    // Check if expired
                    if (entity.modifierDurations[mod.id][tickSystemId] <= 0) {
                        expiredModifiers.push(mod.id);
                    }
                });

                // Remove expired modifiers
                expiredModifiers.forEach(modId => {
                    entity.modifiers = entity.modifiers.filter(m => m.id !== modId);
                    delete entity.modifierDurations[modId];
                });

                // Recalculate compounds after modifier changes
                if (expiredModifiers.length > 0) {
                    recalculatePreviewEntity(entity);
                }
            });
        }

        // Preview entity name counter
        let previewNameCounter = 1;

        function generatePreviewEntityName(preset) {
            // If preset has a name, use it as base with counter
            if (preset?.name) {
                return `${preset.name} #${previewNameCounter++}`;
            }
            // Default pattern
            return `Entity #${previewNameCounter++}`;
        }

        function simulateSpawn(presetId = '', overrideAttributes = {}, overrideVariables = {}) {
            // Look up preset if provided
            const preset = presetId ? (config.presets || []).find(p => p.id === presetId) : null;

            const entity = {
                id: 'entity_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5),
                name: generatePreviewEntityName(preset),
                presetId: presetId || null,
                presetName: preset?.name || null,
                attributes: {},
                variables: {},
                traits: [],
                modifiers: [],
                compounds: [],
                timestamp: new Date().toLocaleTimeString()
            };

            // 1. Roll attributes (or use preset values, or overrides from simulator)
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            attributes.forEach(attr => {
                const min = attr.config?.min ?? 1;
                const max = attr.config?.max ?? 10;

                // Priority: overrideAttributes > preset > random
                let value;
                if (overrideAttributes[attr.id] !== undefined) {
                    value = overrideAttributes[attr.id];
                } else {
                    const presetValue = preset?.attributes?.[attr.id];
                    value = (presetValue !== undefined && presetValue !== null)
                        ? presetValue
                        : Math.floor(Math.random() * (max - min + 1)) + min;
                }

                entity.attributes[attr.id] = {
                    name: attr.name,
                    value: value,
                    min, max,
                    fromPreset: preset?.attributes?.[attr.id] !== undefined,
                    fromSimulator: overrideAttributes[attr.id] !== undefined
                };
            });

            // 2. Initialize variables (with override, random roll from initialRange, or default)
            const variables = config.nodes.filter(n => n.type === 'variable');
            variables.forEach(variable => {
                // Priority: overrideVariables > initialRange > initial/default
                let initialValue;
                if (overrideVariables[variable.id] !== undefined) {
                    initialValue = overrideVariables[variable.id];
                } else if (variable.config?.initialRange && Array.isArray(variable.config.initialRange)) {
                    const [min, max] = variable.config.initialRange;
                    initialValue = Math.floor(Math.random() * (max - min + 1)) + min;
                } else {
                    // Auto-generate range around initial value (+/- 20% of variable range)
                    const baseInitial = variable.config?.initial ?? variable.config?.min ?? 0;
                    const varMin = variable.config?.min ?? 0;
                    const varMax = variable.config?.max ?? 100;
                    const variance = Math.round((varMax - varMin) * 0.2); // 20% variance
                    const rangeMin = Math.max(varMin, baseInitial - variance);
                    const rangeMax = Math.min(varMax, baseInitial + variance);
                    initialValue = Math.floor(Math.random() * (rangeMax - rangeMin + 1)) + rangeMin;
                }

                entity.variables[variable.id] = {
                    name: variable.name,
                    value: initialValue,
                    rate: variable.config?.baseRate ?? variable.config?.rate ?? 0,
                    min: variable.config?.min ?? 0,
                    max: variable.config?.max ?? 100,
                    fromSimulator: overrideVariables[variable.id] !== undefined
                };
            });

            // 3. Apply spawn-time value modifiers from attributes
            config.relationships
                .filter(r => r.type === 'value_modifier' && r.config?.applyAt === 'spawn')
                .forEach(rel => {
                    const source = entity.attributes[rel.sourceId];
                    const targetVar = entity.variables[rel.targetId];
                    if (source && targetVar) {
                        let modifier = rel.config?.value || 0;
                        if (rel.config?.scaling === 'perPoint') {
                            modifier *= source.value;
                        }
                        if (rel.config?.operation === 'multiply') {
                            targetVar.value *= modifier;
                        } else {
                            targetVar.value += modifier;
                        }
                    }
                });

            // 4. Select traits from each layer (sorted by order)
            const layers = config.nodes.filter(n => n.type === 'layer')
                .sort((a, b) => (a.config?.order ?? 0) - (b.config?.order ?? 0));

            layers.forEach(layer => {
                let layerItems = config.nodes.filter(n =>
                    (n.type === 'item' || n.type === 'trait') &&
                    n.config?.layerId === layer.id &&
                    n.config?.selection?.mode !== 'threshold' // Skip threshold items, handled separately
                );

                // Apply spawn constraints - exclude blacklisted traits
                if (spawnConstraints.exclude.length > 0) {
                    layerItems = layerItems.filter(item => !spawnConstraints.exclude.includes(item.id));
                }

                if (layerItems.length === 0) return;

                // Check for must-have traits in this layer
                const mustHaveInLayer = layerItems.filter(item => spawnConstraints.mustHave.includes(item.id));
                mustHaveInLayer.forEach(item => {
                    const layerNode = config.nodes.find(n => n.id === item.config?.layerId);
                    entity.traits.push({
                        id: item.id,
                        name: item.name,
                        layer: layerNode?.name || '',
                        active: true,
                        forced: true,
                        constraint: 'must-have'
                    });
                });

                const selectionMode = layer.config?.selection?.mode || 'weighted';

                // Determine how many traits to roll
                const rollRange = layer.config?.selection?.rollRange ||
                    [layer.config?.selection?.initialRolls ?? 1, layer.config?.selection?.initialRolls ?? 1];
                const [minRolls, maxRolls] = rollRange;
                const numRolls = Math.floor(Math.random() * (maxRolls - minRolls + 1)) + minRolls;
                const maxItems = layer.config?.selection?.maxItems ?? 10;

                if (selectionMode === 'weighted' || selectionMode === 'pickN') {
                    // Initialize with must-have traits already added
                    const selectedIds = new Set(mustHaveInLayer.map(item => item.id));

                    // Adjust number of rolls to account for must-have traits
                    const adjustedRolls = Math.max(0, numRolls - mustHaveInLayer.length);

                    for (let rollIdx = 0; rollIdx < adjustedRolls && selectedIds.size < maxItems; rollIdx++) {
                        // Calculate weights with modifiers (recalculated each roll to account for prior selections)
                        const eligibleItems = layerItems.filter(item => !selectedIds.has(item.id));
                        if (eligibleItems.length === 0) break;

                        const weights = eligibleItems.map(item => {
                            // Check eligibility gates
                            const isBlocked = config.relationships
                                .filter(r => r.type === 'eligibility_gate' && r.targetId === item.id)
                                .some(rel => {
                                    // Check if blocking source is active
                                    const sourceAttr = entity.attributes[rel.sourceId];
                                    const sourceTrait = entity.traits.find(t => t.id === rel.sourceId && t.active !== false);
                                    return sourceAttr || sourceTrait;
                                });

                            if (isBlocked) return { item, weight: 0, blocked: true };

                            // Check incompatibility with already selected traits
                            const incompatibles = item.config?.incompatibleWith || [];
                            const hasIncompatible = incompatibles.some(incompId =>
                                entity.traits.some(t => t.id === incompId && t.active !== false)
                            );
                            if (hasIncompatible) return { item, weight: 0, blocked: true, reason: 'incompatible' };

                            let weight = item.config?.selection?.baseWeight ?? item.config?.weight ?? 50;

                            // Apply weight influences from attributes
                            const baseWeight = weight;
                            const useDR = layer.config?.selection?.diminishingReturns === true;
                            config.relationships
                                .filter(r => r.type === 'weight_influence' && r.targetId === item.id)
                                .forEach(rel => {
                                    const sourceAttr = entity.attributes[rel.sourceId];
                                    const sourceTrait = entity.traits.find(t => t.id === rel.sourceId && t.active !== false);
                                    const sourceVar = entity.variables[rel.sourceId];

                                    if (sourceAttr) {
                                        let modifier = rel.config?.value || 0;
                                        if (rel.config?.scaling === 'perPoint') {
                                            modifier *= sourceAttr.value;
                                        }
                                        if (useDR && modifier !== 0 && rel.config?.operation !== 'multiply') {
                                            modifier = Math.sign(modifier) * Math.sqrt(Math.abs(modifier)) * Math.sqrt(baseWeight);
                                        }
                                        if (rel.config?.operation === 'multiply') {
                                            weight *= modifier;
                                        } else {
                                            weight += modifier;
                                        }
                                    } else if (sourceTrait) {
                                        // Trait is active, apply influence
                                        let modifier = rel.config?.value || 0;
                                        if (useDR && modifier !== 0 && rel.config?.operation !== 'multiply') {
                                            modifier = Math.sign(modifier) * Math.sqrt(Math.abs(modifier)) * Math.sqrt(baseWeight);
                                        }
                                        if (rel.config?.operation === 'multiply') {
                                            weight *= modifier;
                                        } else {
                                            weight += modifier;
                                        }
                                    } else if (sourceVar) {
                                        // Variable-based weight influence
                                        let modifier = rel.config?.value || 0;
                                        if (rel.config?.scaling === 'perPoint') {
                                            modifier *= sourceVar.value;
                                        }
                                        if (useDR && modifier !== 0 && rel.config?.operation !== 'multiply') {
                                            modifier = Math.sign(modifier) * Math.sqrt(Math.abs(modifier)) * Math.sqrt(baseWeight);
                                        }
                                        if (rel.config?.operation === 'multiply') {
                                            weight *= modifier;
                                        } else {
                                            weight += modifier;
                                        }
                                    }
                                });

                            const weightFloor = layer.config?.selection?.weightFloor ?? 0;
                            return { item, weight: Math.max(weightFloor, weight), blocked: false };
                        });

                        // Weighted random selection
                        const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);
                        if (totalWeight > 0) {
                            let roll = Math.random() * totalWeight;
                            for (const { item, weight, blocked } of weights) {
                                if (blocked) continue;
                                roll -= weight;
                                if (roll <= 0) {
                                    selectedIds.add(item.id);
                                    entity.traits.push({
                                        id: item.id,
                                        name: item.name,
                                        layer: layer.name,
                                        layerId: layer.id,
                                        weight: weight,
                                        totalWeight: totalWeight,
                                        active: true
                                    });
                                    break;
                                }
                            }
                        }
                    }
                } else if (selectionMode === 'allMatching') {
                    // Add all items that pass eligibility
                    layerItems.forEach(item => {
                        const isBlocked = config.relationships
                            .filter(r => r.type === 'eligibility_gate' && r.targetId === item.id)
                            .some(rel => {
                                const sourceAttr = entity.attributes[rel.sourceId];
                                const sourceTrait = entity.traits.find(t => t.id === rel.sourceId && t.active !== false);
                                return sourceAttr || sourceTrait;
                            });

                        // Check incompatibility with already selected traits
                        const incompatibles = item.config?.incompatibleWith || [];
                        const hasIncompatible = incompatibles.some(incompId =>
                            entity.traits.some(t => t.id === incompId && t.active !== false)
                        );

                        if (!isBlocked && !hasIncompatible) {
                            entity.traits.push({
                                id: item.id,
                                name: item.name,
                                layer: layer.name,
                                layerId: layer.id,
                                active: true
                            });
                        }
                    });
                } else if (selectionMode === 'firstMatch') {
                    // Pick first eligible item
                    for (const item of layerItems) {
                        const isBlocked = config.relationships
                            .filter(r => r.type === 'eligibility_gate' && r.targetId === item.id)
                            .some(rel => {
                                const sourceAttr = entity.attributes[rel.sourceId];
                                const sourceTrait = entity.traits.find(t => t.id === rel.sourceId && t.active !== false);
                                return sourceAttr || sourceTrait;
                            });

                        // Check incompatibility with already selected traits
                        const incompatibles = item.config?.incompatibleWith || [];
                        const hasIncompatible = incompatibles.some(incompId =>
                            entity.traits.some(t => t.id === incompId && t.active !== false)
                        );

                        if (!isBlocked && !hasIncompatible) {
                            entity.traits.push({
                                id: item.id,
                                name: item.name,
                                layer: layer.name,
                                layerId: layer.id,
                                active: true
                            });
                            break;
                        }
                    }
                }
                // Note: threshold mode traits are handled by recalculatePreviewEntity()
            });

            // 5. Check compounds
            const compounds = config.nodes.filter(n => n.type === 'compound');
            compounds.forEach(compound => {
                const requires = compound.config?.requires || [];
                const logic = compound.config?.requirementLogic || 'all';

                // Use getRequiredNodeId to handle both string IDs and object format {item: "id"}
                const checkRequirement = (req) => {
                    const reqId = getRequiredNodeId(req);
                    return entity.traits.some(t => t.id === reqId);
                };

                const meetsRequirements = logic === 'any'
                    ? requires.some(checkRequirement)
                    : requires.every(checkRequirement);

                if (meetsRequirements && requires.length > 0) {
                    entity.compounds.push({
                        id: compound.id,
                        name: compound.name,
                        requires: requires.map(req => {
                            const nodeId = getRequiredNodeId(req);
                            const node = config.nodes.find(n => n.id === nodeId);
                            return node?.name || nodeId;
                        })
                    });
                }
            });

            // 6. Calculate derived values
            const derived = config.nodes.filter(n => n.type === 'derived');
            derived.forEach(d => {
                if (d.config?.formula) {
                    try {
                        // Create evaluation context
                        const context = {};
                        Object.entries(entity.attributes).forEach(([id, attr]) => {
                            context[id] = attr.value;
                        });
                        Object.entries(entity.variables).forEach(([id, variable]) => {
                            context[id] = variable.value;
                        });

                        // Simple formula evaluation (replace var names with values)
                        let formula = d.config.formula;
                        Object.entries(context).forEach(([key, value]) => {
                            formula = formula.replace(new RegExp(key, 'g'), value);
                        });

                        const result = eval(formula);
                        const min = d.config.min ?? -Infinity;
                        const max = d.config.max ?? Infinity;
                        entity.variables[d.id] = {
                            name: d.name,
                            value: Math.min(max, Math.max(min, result)),
                            derived: true,
                            formula: d.config.formula
                        };
                    } catch (e) {
                        console.warn('Failed to evaluate formula for', d.name, e);
                    }
                }
            });

            // 7. Apply forced traits from preset (if any)
            if (preset?.forceTraits && Array.isArray(preset.forceTraits)) {
                preset.forceTraits.forEach(traitId => {
                    const traitNode = config.nodes.find(n => n.id === traitId);
                    if (traitNode) {
                        // Handle modifiers separately from traits
                        if (traitNode.type === 'modifier') {
                            const existingMod = entity.modifiers.find(m => m.id === traitId);
                            if (existingMod) {
                                existingMod.active = true;
                                existingMod.fromPreset = true;
                            } else {
                                entity.modifiers.push({
                                    id: traitId,
                                    name: traitNode.name,
                                    type: 'modifier',
                                    active: true,
                                    fromPreset: true,
                                    forced: true
                                });
                            }
                        } else {
                            // Check if trait already exists
                            const existingTrait = entity.traits.find(t => t.id === traitId);
                            if (existingTrait) {
                                existingTrait.active = true;
                                existingTrait.fromPreset = true;
                            } else {
                                // Find the layer for this trait
                                const layerNode = config.nodes.find(n => n.id === traitNode.config?.layerId);
                                entity.traits.push({
                                    id: traitId,
                                    name: traitNode.name,
                                    layer: layerNode?.name || 'Unknown',
                                    layerId: traitNode.config?.layerId,
                                    active: true,
                                    fromPreset: true,
                                    forced: true
                                });
                            }
                        }
                    }
                });
            }

            return entity;
        }

        function renderPreviewEntity(entity, index) {
            const attrEntries = Object.entries(entity.attributes);
            const varEntries = Object.entries(entity.variables).filter(([_, v]) => !v.derived);
            const derivedEntries = Object.entries(entity.variables).filter(([_, v]) => v.derived);
            const entityIndex = previewEntities.length - 1 - index; // Real index in array

            return `
                <div class="preview-entity ${index === 0 ? 'newest' : ''}">
                    <div class="preview-entity-header">
                        <input type="text" class="preview-entity-name-input" value="${entity.name || `Entity #${previewEntities.length - index}`}"
                               onchange="renamePreviewEntity(${entityIndex}, this.value)"
                               placeholder="Entity name..." title="Click to rename">
                        <span class="preview-entity-time">${entity.timestamp}</span>
                        <div class="preview-entity-actions">
                            <button class="btn btn-sm preview-promote-btn" onclick="promotePreviewEntity(${entityIndex})" title="Save to Entity Manager">
                                + Promote
                            </button>
                            <button class="btn btn-sm preview-discard-btn" onclick="discardPreviewEntity(${entityIndex})" title="Discard">
                                âœ•
                            </button>
                        </div>
                    </div>

                    ${attrEntries.length > 0 ? `
                        <div class="preview-section">
                            <div class="preview-section-title">Attributes <span class="edit-hint">(editable)</span></div>
                            <div class="preview-attributes">
                                ${attrEntries.map(([id, attr]) => `
                                    <div class="preview-attr">
                                        <span class="attr-name">${attr.name}</span>
                                        <input type="number" class="attr-value-input" value="${attr.value}"
                                               min="${attr.min}" max="${attr.max}" step="1"
                                               onchange="updatePreviewAttribute(${entityIndex}, '${id}', parseFloat(this.value))">
                                        <div class="attr-bar">
                                            <div class="attr-bar-fill" style="width: ${((attr.value - attr.min) / (attr.max - attr.min)) * 100}%"></div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}

                    <div class="preview-section">
                        <div class="preview-section-title">
                            Traits <span class="edit-hint">(click to toggle)</span>
                            <button class="btn btn-icon btn-sm add-trait-btn" onclick="showAddTraitMenu(event, ${entityIndex})" title="Add trait">+</button>
                        </div>
                        <div class="preview-traits">
                            ${entity.traits.length > 0 ? entity.traits.map((trait, traitIdx) => `
                                <div class="preview-trait ${trait.active === false ? 'inactive' : 'active'} ${trait.threshold ? 'threshold-trait' : ''} ${trait.forced ? 'forced-trait' : ''}"
                                     onclick="togglePreviewTrait(${entityIndex}, ${traitIdx})"
                                     title="${trait.forced ? 'Forced by preset' : (trait.trigger || '')}">
                                    <span class="trait-toggle">${trait.active === false ? 'â—‹' : 'â—'}</span>
                                    <span class="trait-name">${trait.name}</span>
                                    <span class="trait-layer">${trait.layer}</span>
                                    ${trait.forced ? '<span class="trait-type" style="color: var(--accent-gold);" title="Forced by preset">â˜…</span>' : ''}
                                    ${trait.threshold ? '<span class="trait-type">âš¡</span>' : ''}
                                    ${trait.weight !== undefined ? `<span class="trait-chance">${Math.round(trait.weight / trait.totalWeight * 100)}%</span>` : ''}
                                </div>
                            `).join('') : '<div class="empty-hint" style="font-size: 0.8rem; color: var(--text-muted);">No traits yet</div>'}
                        </div>
                    </div>

                    <div class="preview-section">
                        <div class="preview-section-title">
                            Modifiers
                            <button class="add-btn-inline modifier-btn" onclick="showModifierMenu(event, ${entityIndex}, true)" title="Add modifier">+</button>
                        </div>
                        <div class="preview-traits">
                            ${(entity.modifiers || []).length > 0 ? entity.modifiers.map(mod => `
                                <div class="preview-trait active threshold-trait ${mod.forced ? 'forced-trait' : ''}"
                                     title="${mod.forced ? 'Force-applied' : (mod.trigger || 'Active modifier')}">
                                    <span class="trait-toggle" style="color: var(--node-modifier);">â—†</span>
                                    <span class="trait-name">${mod.name || mod.id || mod}</span>
                                    ${mod.forced ? '<span class="trait-type" style="color: var(--accent-gold);" title="Force-applied">âš¡</span>' : ''}
                                    ${mod.threshold ? '<span class="trait-type">âš¡</span>' : ''}
                                </div>
                            `).join('') : '<div class="empty-hint" style="font-size: 0.8rem; color: var(--text-muted);">No modifiers</div>'}
                        </div>
                    </div>

                    <div class="preview-section">
                        <div class="preview-section-title">
                            Compounds
                            <button class="add-btn-inline compound-btn" onclick="showCompoundMenu(event, ${entityIndex}, true)" title="Add compound">+</button>
                        </div>
                        <div class="preview-compounds">
                            ${entity.compounds.length > 0 ? entity.compounds.map(compound => `
                                <div class="preview-compound ${compound.forced ? 'forced' : ''}">
                                    <span class="compound-name">${compound.name}</span>
                                    ${compound.forced ? '<span style="color: var(--accent-gold); font-size: 0.6rem;" title="Force-activated">âš¡</span>' : ''}
                                </div>
                            `).join('') : '<div class="empty-hint" style="font-size: 0.8rem; color: var(--text-muted);">No compounds</div>'}
                        </div>
                    </div>

                    ${varEntries.length > 0 ? `
                        <div class="preview-section">
                            <div class="preview-section-title">Variables <span class="edit-hint">(editable)</span></div>
                            <div class="preview-variables">
                                ${varEntries.map(([id, v]) => `
                                    <div class="preview-var">
                                        <span class="var-name">${v.name}</span>
                                        <input type="number" class="var-value-input" value="${Math.round(v.value)}"
                                               min="${v.min ?? 0}" max="${v.max ?? 100}" step="1"
                                               onchange="updatePreviewVariable(${entityIndex}, '${id}', parseFloat(this.value))">
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}

                    ${derivedEntries.length > 0 ? `
                        <div class="preview-section">
                            <div class="preview-section-title">Derived</div>
                            <div class="preview-derived">
                                ${derivedEntries.map(([id, v]) => `
                                    <div class="preview-var derived" title="${v.formula || ''}">
                                        <span class="var-name">${v.name}</span>
                                        <span class="var-value">${typeof v.value === 'number' ? v.value.toFixed(2) : v.value}</span>
                                        ${v.breakdown ? `<span class="derived-breakdown">${v.breakdown}</span>` : ''}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderPreviewAnalysis() {
            if (previewEntities.length < 2) return '<div class="analysis-hint">Spawn more entities to see distribution analysis</div>';

            // Analyze trait distributions
            const traitCounts = {};
            const attrSums = {};
            const attrCounts = {};

            previewEntities.forEach(entity => {
                // Count traits
                entity.traits.forEach(trait => {
                    traitCounts[trait.name] = (traitCounts[trait.name] || 0) + 1;
                });

                // Sum attributes
                Object.entries(entity.attributes).forEach(([id, attr]) => {
                    attrSums[attr.name] = (attrSums[attr.name] || 0) + attr.value;
                    attrCounts[attr.name] = (attrCounts[attr.name] || 0) + 1;
                });
            });

            const totalEntities = previewEntities.length;

            // Sort traits by frequency
            const sortedTraits = Object.entries(traitCounts)
                .map(([name, count]) => ({ name, count, pct: (count / totalEntities * 100).toFixed(1) }))
                .sort((a, b) => b.count - a.count);

            // Calculate attribute averages
            const attrAverages = Object.entries(attrSums)
                .map(([name, sum]) => ({ name, avg: (sum / attrCounts[name]).toFixed(1) }));

            return `
                <div class="analysis-section">
                    <div class="analysis-title">Distribution Analysis (${totalEntities} entities)</div>

                    ${attrAverages.length > 0 ? `
                        <div class="analysis-group">
                            <div class="analysis-group-title">Attribute Averages</div>
                            ${attrAverages.map(attr => `
                                <div class="analysis-row">
                                    <span class="analysis-label">${attr.name}</span>
                                    <span class="analysis-value">${attr.avg}</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${sortedTraits.length > 0 ? `
                        <div class="analysis-group">
                            <div class="analysis-group-title">Trait Frequency</div>
                            ${sortedTraits.slice(0, 15).map(trait => `
                                <div class="analysis-row">
                                    <span class="analysis-label">${trait.name}</span>
                                    <span class="analysis-value">${trait.pct}%</span>
                                    <div class="analysis-bar">
                                        <div class="analysis-bar-fill" style="width: ${trait.pct}%"></div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Spawn options panel state
        let spawnOptionsExpanded = false;
        let spawnConstraintsExpanded = false;
        let batchSpawnCount = 10;

        // Spawn constraints
        let spawnConstraints = {
            mustHave: [],   // trait IDs that must be included
            exclude: []     // trait IDs that must be excluded
        };

        function toggleSpawnOptions() {
            spawnOptionsExpanded = !spawnOptionsExpanded;
            const panel = document.querySelector('.spawn-options-panel');
            if (panel) {
                panel.classList.toggle('expanded', spawnOptionsExpanded);
            }
        }

        function updateProbabilityPanel() {
            const panel = document.getElementById('probabilityPanel');
            if (panel) {
                panel.innerHTML = renderRelationshipLegend() + renderProbabilityBreakdown();
            }
            // Note: Spawn sim body is updated separately via renderSpawnSimBody() when needed
        }

        function renderRelationshipLegend() {
            // Check if there are any weight_influence relationships
            const hasWeightInfluences = config.relationships.some(r => r.type === 'weight_influence');
            const hasEligibilityGates = config.relationships.some(r => r.type === 'eligibility_gate');

            if (!hasWeightInfluences && !hasEligibilityGates) {
                return '';
            }

            const legendItems = [];

            if (hasWeightInfluences) {
                legendItems.push({
                    color: 'var(--node-weight-influence)',
                    label: 'Weight Influence',
                    desc: 'Attribute values modify trait selection probability. Higher attribute â†’ higher/lower chance depending on multiplier.'
                });
            }

            if (hasEligibilityGates) {
                legendItems.push({
                    color: 'var(--node-eligibility-gate)',
                    label: 'Eligibility Gate',
                    desc: 'Blocks a trait from being selected when source condition is met. Acts as a hard exclude.'
                });
            }

            return `
                <div class="relationship-legend">
                    <div class="relationship-legend-title">Relationship Types Affecting Spawn</div>
                    ${legendItems.map(item => `
                        <div class="relationship-legend-item" title="${item.desc}">
                            <span class="legend-dot" style="background: ${item.color};"></span>
                            <span class="legend-label">${item.label}</span>
                            <span style="color: var(--text-muted); font-size: 0.6rem;">?</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function toggleSpawnConstraints() {
            spawnConstraintsExpanded = !spawnConstraintsExpanded;
            const panel = document.querySelector('.spawn-constraints-panel');
            if (panel) {
                panel.classList.toggle('expanded', spawnConstraintsExpanded);
            }
        }

        function addConstraint(type) {
            const select = document.getElementById(`constraint-${type}-select`);
            if (!select || !select.value) return;

            const traitId = select.value;
            const arr = type === 'must-have' ? spawnConstraints.mustHave : spawnConstraints.exclude;

            // Remove from opposite list if present
            const opposite = type === 'must-have' ? spawnConstraints.exclude : spawnConstraints.mustHave;
            const oppIdx = opposite.indexOf(traitId);
            if (oppIdx > -1) opposite.splice(oppIdx, 1);

            if (!arr.includes(traitId)) {
                arr.push(traitId);
            }

            select.value = '';
            renderConstraintsPanel();
            updateProbabilityPanel();
        }

        function removeConstraint(type, traitId) {
            const arr = type === 'must-have' ? spawnConstraints.mustHave : spawnConstraints.exclude;
            const idx = arr.indexOf(traitId);
            if (idx > -1) {
                arr.splice(idx, 1);
            }
            renderConstraintsPanel();
            updateProbabilityPanel();
        }

        function clearAllConstraints() {
            spawnConstraints.mustHave = [];
            spawnConstraints.exclude = [];
            renderConstraintsPanel();
            updateProbabilityPanel();
        }

        function renderConstraintsPanel() {
            const panel = document.getElementById('constraintsPanel');
            if (panel) {
                panel.innerHTML = renderSpawnConstraints();
            }
            // Update count badge
            const badge = document.querySelector('.spawn-constraints-count');
            const total = spawnConstraints.mustHave.length + spawnConstraints.exclude.length;
            if (badge) {
                badge.textContent = total;
                badge.style.display = total > 0 ? 'inline' : 'none';
            }
        }

        function renderSpawnConstraints() {
            // Get all traits grouped by layer
            const layers = config.nodes.filter(n => n.type === 'layer')
                .sort((a, b) => (a.config?.order ?? 0) - (b.config?.order ?? 0));

            const allTraits = config.nodes.filter(n =>
                (n.type === 'item' || n.type === 'trait') &&
                n.config?.selection?.mode !== 'threshold'
            );

            // Build options grouped by layer
            const traitOptions = layers.map(layer => {
                const layerTraits = allTraits.filter(t => t.config?.layerId === layer.id);
                if (layerTraits.length === 0) return '';
                return `
                    <optgroup label="${layer.name}">
                        ${layerTraits.map(t => `<option value="${t.id}">${t.name}</option>`).join('')}
                    </optgroup>
                `;
            }).join('');

            const getTraitName = (id) => {
                const node = config.nodes.find(n => n.id === id);
                return node?.name || id;
            };

            return `
                <div class="constraints-section">
                    <div class="constraints-section-title">
                        <span style="color: var(--accent-success);">âœ“</span> Must Have
                    </div>
                    <div class="constraints-list">
                        ${spawnConstraints.mustHave.map(id => `
                            <div class="constraint-tag must-have">
                                <span>${getTraitName(id)}</span>
                                <span class="remove-constraint" onclick="removeConstraint('must-have', '${id}')">âœ•</span>
                            </div>
                        `).join('')}
                        ${spawnConstraints.mustHave.length === 0 ? '<span style="color: var(--text-muted); font-size: 0.75rem; font-style: italic;">None</span>' : ''}
                    </div>
                    <div class="constraint-add-row">
                        <select class="constraint-select" id="constraint-must-have-select">
                            <option value="">Select trait...</option>
                            ${traitOptions}
                        </select>
                        <button class="btn btn-xs btn-success constraint-add-btn" onclick="addConstraint('must-have')">+ Add</button>
                    </div>
                </div>

                <div class="constraints-section">
                    <div class="constraints-section-title">
                        <span style="color: var(--accent-danger);">âœ•</span> Exclude
                    </div>
                    <div class="constraints-list">
                        ${spawnConstraints.exclude.map(id => `
                            <div class="constraint-tag exclude">
                                <span>${getTraitName(id)}</span>
                                <span class="remove-constraint" onclick="removeConstraint('exclude', '${id}')">âœ•</span>
                            </div>
                        `).join('')}
                        ${spawnConstraints.exclude.length === 0 ? '<span style="color: var(--text-muted); font-size: 0.75rem; font-style: italic;">None</span>' : ''}
                    </div>
                    <div class="constraint-add-row">
                        <select class="constraint-select" id="constraint-exclude-select">
                            <option value="">Select trait...</option>
                            ${traitOptions}
                        </select>
                        <button class="btn btn-xs btn-danger constraint-add-btn" onclick="addConstraint('exclude')">+ Add</button>
                    </div>
                </div>

                ${(spawnConstraints.mustHave.length > 0 || spawnConstraints.exclude.length > 0) ? `
                    <div style="margin-top: 0.5rem; text-align: right;">
                        <button class="btn btn-xs btn-secondary" onclick="clearAllConstraints()">Clear All</button>
                    </div>
                ` : ''}
            `;
        }

        function updateBatchCount(value) {
            batchSpawnCount = Math.min(50, Math.max(1, parseInt(value) || 10));
        }

        function spawnBatchCustom() {
            spawnMultipleEntities(batchSpawnCount);
        }

        // Distinct color palette for probability visuals â€” 8 colors that work on dark backgrounds
        const PROB_COLORS = [
            '#d4a04c', // gold/amber
            '#5cb8a5', // teal
            '#d46b7b', // rose
            '#7bc46b', // lime
            '#5b9fd4', // sky blue
            '#d48c5b', // coral/orange
            '#9b7bc4', // lavender
            '#4cc4a0', // mint
            '#c4b05b', // yellow-green
            '#c45b8c', // magenta
        ];

        function getTraitColor(index) {
            return PROB_COLORS[index % PROB_COLORS.length];
        }

        // ======================================================================
        // Compound Block Formula Editor
        // Two-level architecture: expression blocks as drag units,
        // connected by formula-level operators with optional paren groups.
        // ======================================================================

        // --- Tokenizer (preserved, shared by preview + parser) ---

        function tokenizeFormula(formula) {
            const tokens = [];
            let i = 0;
            while (i < formula.length) {
                if (' \t\n'.includes(formula[i])) { i++; continue; }
                if ('+-*/()[]'.includes(formula[i])) {
                    // Map [] to () for paren group aliases
                    const ch = formula[i] === '[' ? '(' : formula[i] === ']' ? ')' : formula[i];
                    tokens.push({ type: 'op', value: ch });
                    i++;
                } else if (/[0-9]/.test(formula[i]) || (formula[i] === '.' && i + 1 < formula.length && /[0-9]/.test(formula[i + 1]))) {
                    let num = '';
                    while (i < formula.length && /[0-9.]/.test(formula[i])) { num += formula[i]; i++; }
                    tokens.push({ type: 'num', value: num });
                } else if (/[a-zA-Z_]/.test(formula[i])) {
                    let id = '';
                    while (i < formula.length && /[a-zA-Z0-9_]/.test(formula[i])) { id += formula[i]; i++; }
                    tokens.push({ type: 'id', value: id });
                } else {
                    tokens.push({ type: 'unknown', value: formula[i] });
                    i++;
                }
            }
            return tokens;
        }

        // --- Preview system (preserved) ---

        function validateFormulaTokens(tokens) {
            const errors = [];
            let parenDepth = 0;
            tokens.forEach(t => {
                if (t.type === 'id') {
                    const node = config.nodes.find(n => n.id === t.value);
                    if (!node) errors.push('Unknown: "' + t.value + '"');
                }
                if (t.value === '(') parenDepth++;
                if (t.value === ')') { parenDepth--; if (parenDepth < 0) errors.push('Unmatched )'); }
                if (t.type === 'unknown') errors.push('Unexpected: "' + t.value + '"');
            });
            if (parenDepth > 0) errors.push('Unmatched (');
            return errors;
        }

        function formatFormulaTokens(tokens) {
            return tokens.map(t => {
                if (t.type === 'id') {
                    const node = config.nodes.find(n => n.id === t.value);
                    if (node) return '<span class="formula-node-name">' + node.name + '</span>';
                    return '<span class="formula-error-id">' + t.value + '</span>';
                }
                if (t.type === 'op') {
                    const display = t.value === '*' ? 'Ã—' : t.value === '/' ? 'Ã·' : t.value;
                    return '<span class="formula-operator">' + display + '</span>';
                }
                if (t.type === 'paren-implicit') return '<span class="formula-paren-implicit">' + t.value + '</span>';
                if (t.type === 'num') return '<span class="formula-number">' + t.value + '</span>';
                return '<span style="color: #e05252;">' + t.value + '</span>';
            }).join(' ');
        }

        // ======================================================================
        // Formula Blocks Editor (v3.5.0) â€” Block-Based Lâ†’R Formula Builder
        // ======================================================================
        //
        // Data Model:
        //   FormulaValue = { type: 'id'|'num', value: string }
        //   FormulaBlock = { left: FormulaValue, op?: string, right?: FormulaValue, label?: string }
        //   FormulaStep  = { type: 'block', block: FormulaBlock }
        //   FormulaModel = { steps: FormulaStep[], ops: string[] }
        //   ops[i] is the operator between steps[i] and steps[i+1]; ops.length === steps.length - 1
        //
        // Evaluation: strictly left-to-right. Step order = evaluation order.
        // Serialization: explicit Lâ†’R parenthesization for JS engine compatibility.

        // --- Editor state ---
        const _fbEditors = {}; // nodeId -> { model, selectedStep, undoStack, undoPointer, sourceNodes, expanded, builder }

        function getFBEditor(nodeId) {
            if (!_fbEditors[nodeId]) {
                _fbEditors[nodeId] = {
                    model: { steps: [], ops: [] },
                    selectedStep: -1,
                    undoStack: [],
                    undoPointer: -1,
                    sourceNodes: [],
                    expanded: false,
                    builder: { leftType: 'id', leftValue: '', op: null, rightType: 'id', rightValue: '', label: '' }
                };
            }
            return _fbEditors[nodeId];
        }

        // --- Serialization: new model â†’ formula string ---

        function serializeBlocksFormula(model) {
            if (!model || !model.steps || model.steps.length === 0) return '';

            function serStep(step) {
                const b = step.block;
                if (!b || !b.left) return '0';
                if (b.op && b.right) return '(' + b.left.value + ' ' + b.op + ' ' + b.right.value + ')';
                return String(b.left.value);
            }

            // Lâ†’R: accumulate left-associative parens
            let result = serStep(model.steps[0]);
            for (let i = 0; i < model.ops.length && i + 1 < model.steps.length; i++) {
                result = '(' + result + ' ' + model.ops[i] + ' ' + serStep(model.steps[i + 1]) + ')';
            }
            return result;
        }

        // --- Migration: legacy formats â†’ new model ---

        function convertOldModelToBlocks(oldModel) {
            if (!oldModel || !oldModel.elements) return { steps: [], ops: [] };
            const steps = [];
            const ops = [];

            for (const el of oldModel.elements) {
                if (el.type === 'block') {
                    if (el.block.op && el.block.right) {
                        steps.push({
                            type: 'block',
                            block: {
                                left: { type: el.block.left.type, value: el.block.left.value },
                                op: el.block.op,
                                right: { type: el.block.right.type, value: el.block.right.value }
                            }
                        });
                    } else if (el.block.left) {
                        steps.push({
                            type: 'block',
                            block: {
                                left: { type: el.block.left.type, value: el.block.left.value }
                            }
                        });
                    }
                } else if (el.type === 'op') {
                    ops.push(el.value);
                } else if (el.type === 'group') {
                    // Flatten groups recursively
                    const sub = convertOldModelToBlocks({ elements: el.children });
                    if (steps.length > 0 && sub.steps.length > 0 && ops.length < steps.length) {
                        ops.push('+');
                    }
                    steps.push(...sub.steps);
                    ops.push(...sub.ops);
                }
            }

            // Ensure ops.length === steps.length - 1
            while (ops.length > steps.length - 1) ops.pop();
            while (ops.length < steps.length - 1) ops.push('+');

            return { steps, ops };
        }

        function migrateToFormulaBlocks(formula, formulaGroups, formulaBlocks) {
            // Prefer new format
            if (formulaBlocks && formulaBlocks.steps && formulaBlocks.steps.length > 0) {
                return JSON.parse(JSON.stringify(formulaBlocks));
            }
            // Convert from old FormulaModel (v3.4.0)
            if (formulaGroups && formulaGroups.elements && formulaGroups.elements.length > 0) {
                return convertOldModelToBlocks(formulaGroups);
            }
            // Parse from formula string (pre-v3.4.0)
            if (formula && formula.trim()) {
                const tokens = tokenizeFormula(formula);
                if (tokens.length === 0) return { steps: [], ops: [] };
                const oldModel = parseFormulaLTR(tokens);
                return convertOldModelToBlocks(oldModel);
            }
            return { steps: [], ops: [] };
        }

        // --- Validation ---

        function validateBlocksModel(model) {
            const errors = [];
            if (!model || !model.steps) return errors;

            for (let i = 0; i < model.steps.length; i++) {
                const step = model.steps[i];
                if (!step || !step.block) { errors.push('Invalid step at position ' + (i + 1)); continue; }
                const b = step.block;
                // Check left value
                if (!b.left) { errors.push('Missing value in block ' + (i + 1)); continue; }
                if (b.left.type === 'id') {
                    const node = config.nodes.find(n => n.id === b.left.value);
                    if (!node) errors.push('Unknown: "' + b.left.value + '"');
                }
                // Check right value if compound
                if (b.op && !b.right) {
                    errors.push('Incomplete block: [' + b.left.value + ' ' + b.op + ' ?]');
                }
                if (b.right && b.right.type === 'id') {
                    const node = config.nodes.find(n => n.id === b.right.value);
                    if (!node) errors.push('Unknown: "' + b.right.value + '"');
                }
            }

            // Check ops array length
            if (model.steps.length > 1 && model.ops.length !== model.steps.length - 1) {
                errors.push('Operator count mismatch');
            }

            return [...new Set(errors)];
        }

        // --- Init editor ---

        function initFormulaBlocksEditor(nodeId, formula, formulaGroups, formulaBlocks) {
            const editor = getFBEditor(nodeId);
            editor.model = migrateToFormulaBlocks(formula, formulaGroups, formulaBlocks);
            editor.selectedStep = -1;
            editor.expanded = false;
            editor.undoStack = [JSON.parse(JSON.stringify(editor.model))];
            editor.undoPointer = 0;
            // Defer refresh until after HTML is in the DOM
            requestAnimationFrame(() => refreshFBEditor(nodeId));
        }

        // --- Undo/Redo (adapted for new model) ---

        function pushFBUndoState(nodeId) {
            const editor = getFBEditor(nodeId);
            const snapshot = JSON.parse(JSON.stringify(editor.model));

            if (editor.undoPointer >= 0 &&
                JSON.stringify(editor.undoStack[editor.undoPointer]) === JSON.stringify(snapshot)) return;

            editor.undoStack = editor.undoStack.slice(0, editor.undoPointer + 1);
            editor.undoStack.push(snapshot);

            if (editor.undoStack.length > 50) editor.undoStack.shift();
            editor.undoPointer = editor.undoStack.length - 1;
        }

        function fbUndo(nodeId) {
            const editor = getFBEditor(nodeId);
            if (editor.undoPointer > 0) {
                editor.undoPointer--;
                editor.model = JSON.parse(JSON.stringify(editor.undoStack[editor.undoPointer]));
                editor.selectedStep = -1;
                refreshFBEditor(nodeId);
            }
        }

        function fbRedo(nodeId) {
            const editor = getFBEditor(nodeId);
            if (editor.undoPointer < editor.undoStack.length - 1) {
                editor.undoPointer++;
                editor.model = JSON.parse(JSON.stringify(editor.undoStack[editor.undoPointer]));
                editor.selectedStep = -1;
                refreshFBEditor(nodeId);
            }
        }

        function onFBKeyDown(event, nodeId) {
            if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
                event.preventDefault();
                fbUndo(nodeId);
            } else if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
                event.preventDefault();
                fbRedo(nodeId);
            } else if (event.key === 'Escape') {
                collapseFBEditor(nodeId);
            }
        }

        // --- Central refresh ---

        function refreshFBEditor(nodeId) {
            const editor = getFBEditor(nodeId);
            const isNew = nodeId === 'new';

            // Re-render blocks area (if expanded)
            const blocksEl = document.getElementById('fbBlocks_' + nodeId);
            if (blocksEl) {
                blocksEl.innerHTML = renderFBBlocksArea(nodeId);
                // Dim unselected chips when a step is selected
                if (editor.selectedStep >= 0) blocksEl.classList.add('has-selection');
                else blocksEl.classList.remove('has-selection');
            }

            // Sync unified panel: load selected step into builder or reset to new mode
            syncPanelFromSelection(nodeId);

            // Serialize model â†’ formula string
            const formula = serializeBlocksFormula(editor.model);

            // Update hidden input
            const hiddenId = isNew ? 'newNodeFormula' : 'derivedFormula_' + nodeId;
            const hidden = document.getElementById(hiddenId);
            if (hidden) hidden.value = formula;

            // Update previews (set context for model-based rendering)
            _currentPreviewNodeId = nodeId;

            const summaryText = document.getElementById('fbSummaryText_' + nodeId);
            if (summaryText) {
                summaryText.innerHTML = formula.trim() ? renderFBPreview(formula) : '<span class="formula-summary-empty">No formula defined</span>';
            }

            const previewEl = document.getElementById('fbPreview_' + nodeId);
            if (previewEl) {
                previewEl.innerHTML = formula.trim() ? renderFBPreview(formula) : '';
            }

            _currentPreviewNodeId = null;

            // Validate
            const errors = validateBlocksModel(editor.model);
            const errBox = document.getElementById('fbErrors_' + nodeId);
            if (errBox) {
                errBox.innerHTML = errors.length > 0
                    ? errors.map(e => '<div>' + e + '</div>').join('')
                    : '';
            }

            // Save to config only if valid and not the add-node modal
            if (!isNew && errors.length === 0 && editor.model.steps.length > 0) {
                const node = config.nodes.find(n => n.id === nodeId);
                if (node) {
                    node.config.formula = formula;
                    node.config.formulaBlocks = JSON.parse(JSON.stringify(editor.model));
                    // Clear old format
                    delete node.config.formulaGroups;
                    engine.loadConfig(config);
                    saveToStorage();
                }
            }
        }

        // --- Preview (model-based with bracket grouping) ---

        let _currentPreviewNodeId = null;

        function renderFBPreviewValue(val) {
            if (!val) return '';
            if (val.type === 'id') {
                const n = config.nodes.find(nd => nd.id === val.value);
                if (n) return '<span class="formula-node-name">' + n.name + '</span>';
                return '<span class="formula-error-id">' + val.value + '</span>';
            }
            return '<span class="formula-number">' + val.value + '</span>';
        }

        function renderFBPreview(formula) {
            // Use model-based rendering when available
            if (_currentPreviewNodeId) {
                const editor = _fbEditors[_currentPreviewNodeId];
                if (editor && editor.model && editor.model.steps && editor.model.steps.length > 0) {
                    const model = editor.model;
                    let html = '<span class="formula-preview-eq">= </span>';

                    for (let i = 0; i < model.steps.length; i++) {
                        // Inter-step operator
                        if (i > 0 && i - 1 < model.ops.length) {
                            const op = model.ops[i - 1];
                            const opDisplay = op === '*' ? '\u00d7' : op === '/' ? '\u00f7' : op;
                            html += '<span class="formula-operator"> ' + opDisplay + ' </span>';
                        }

                        const step = model.steps[i];
                        const b = step.block;
                        const isCompound = b.op && b.right;

                        if (isCompound) {
                            // Wrap compound blocks in brackets, keep group on same line
                            html += '<span style="white-space:nowrap"><span class="formula-bracket">[</span>';
                            html += renderFBPreviewValue(b.left);
                            const opDisplay = b.op === '*' ? '\u00d7' : b.op === '/' ? '\u00f7' : b.op;
                            html += '<span class="formula-operator"> ' + opDisplay + ' </span>';
                            html += renderFBPreviewValue(b.right);
                            html += '<span class="formula-bracket">]</span></span>';
                        } else {
                            html += renderFBPreviewValue(b.left);
                        }
                    }

                    return html;
                }
            }

            // Fallback: token-based rendering for formulas without model
            if (!formula || !formula.trim()) return '';
            const tokens = tokenizeFormula(formula);
            const cleanTokens = tokens.filter(t => t.value !== '(' && t.value !== ')');
            const display = formatFormulaTokens(cleanTokens);
            return '<span class="formula-preview-eq">= </span>' + display;
        }

        // --- Step manipulation ---

        function addFBStep(nodeId, selectEl) {
            const id = selectEl.value;
            if (!id) return;
            selectEl.selectedIndex = 0;

            const editor = getFBEditor(nodeId);
            const newStep = { type: 'block', block: { left: { type: 'id', value: id } } };

            if (editor.model.steps.length > 0) {
                editor.model.ops.push('+');
            }
            editor.model.steps.push(newStep);

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function addFBNumStep(event, nodeId) {
            if (event.key !== 'Enter') return;
            const input = event.target;
            const val = input.value.trim();
            if (!val || isNaN(Number(val))) return;

            const editor = getFBEditor(nodeId);
            const newStep = { type: 'block', block: { left: { type: 'num', value: val } } };

            if (editor.model.steps.length > 0) {
                editor.model.ops.push('+');
            }
            editor.model.steps.push(newStep);

            input.value = '';
            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        // --- Block builder functions ---

        function toggleBuilderValueType(nodeId, side) {
            const editor = getFBEditor(nodeId);
            const b = editor.builder;
            if (side === 'left') {
                b.leftType = b.leftType === 'id' ? 'num' : 'id';
                b.leftValue = '';
            } else {
                b.rightType = b.rightType === 'id' ? 'num' : 'id';
                b.rightValue = '';
            }
            if (editor.selectedStep >= 0) {
                syncBuilderToModel(nodeId);
            } else {
                refreshBuilderUI(nodeId);
            }
        }

        function selectBuilderOp(nodeId, op) {
            const editor = getFBEditor(nodeId);
            const b = editor.builder;
            // Toggle: if already active, deactivate
            b.op = b.op === op ? null : op;
            if (!b.op) {
                b.rightValue = '';
            }
            if (editor.selectedStep >= 0) {
                syncBuilderToModel(nodeId);
            } else {
                refreshBuilderUI(nodeId);
            }
        }

        function addBlockFromBuilder(nodeId) {
            const editor = getFBEditor(nodeId);
            const b = editor.builder;
            if (!b.leftValue) return;

            const block = { left: { type: b.leftType, value: b.leftValue } };

            if (b.op && b.rightValue) {
                block.op = b.op;
                block.right = { type: b.rightType, value: b.rightValue };
            }

            const newStep = { type: 'block', block: block };

            if (editor.model.steps.length > 0) {
                editor.model.ops.push('+');
            }
            editor.model.steps.push(newStep);

            resetBlockBuilder(nodeId);
            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function resetBlockBuilder(nodeId) {
            const editor = getFBEditor(nodeId);
            editor.builder = { leftType: 'id', leftValue: '', op: null, rightType: 'id', rightValue: '', label: '' };
            refreshBuilderUI(nodeId);
        }

        function loadStepIntoBuilder(nodeId, stepIdx) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step) return;
            const b = step.block;
            editor.builder = {
                leftType: b.left ? b.left.type : 'id',
                leftValue: b.left ? b.left.value : '',
                op: b.op || null,
                rightType: (b.right ? b.right.type : 'id'),
                rightValue: (b.right ? b.right.value : ''),
                label: b.label || ''
            };
        }

        function syncBuilderToModel(nodeId) {
            const editor = getFBEditor(nodeId);
            if (editor.selectedStep < 0 || editor.selectedStep >= editor.model.steps.length) return;
            const step = editor.model.steps[editor.selectedStep];
            const b = editor.builder;

            step.block.left = { type: b.leftType, value: b.leftValue };

            if (b.op) {
                step.block.op = b.op;
                if (b.rightValue) {
                    step.block.right = { type: b.rightType, value: b.rightValue };
                } else {
                    step.block.right = null;
                }
            } else {
                step.block.op = undefined;
                step.block.right = null;
            }

            step.block.label = b.label || undefined;

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function syncPanelFromSelection(nodeId) {
            const editor = getFBEditor(nodeId);
            const prefix = 'fbBuilder_' + nodeId;
            const isEditing = editor.selectedStep >= 0 && editor.selectedStep < editor.model.steps.length;

            // Update header
            const header = document.getElementById(prefix + '_header');
            if (header) {
                header.textContent = isEditing ? 'Editing Block ' + (editor.selectedStep + 1) : 'New Block';
            }

            // Show/hide label row
            const labelRow = document.getElementById(prefix + '_labelRow');
            if (labelRow) {
                labelRow.style.display = isEditing ? '' : 'none';
                const labelInput = document.getElementById(prefix + '_labelInput');
                if (labelInput) labelInput.value = editor.builder.label || '';
            }

            // Update actions row
            const actionsEl = document.getElementById(prefix + '_actions');
            if (actionsEl) {
                const safeId = nodeId.replace(/'/g, "\\'");
                let actionsHtml = '';
                if (isEditing) {
                    actionsHtml += '<button type="button" class="formula-builder-btn-add" onclick="startNewBlock(\'' + safeId + '\')">+ New Block</button>';
                    actionsHtml += '<button type="button" class="formula-undo-btn" style="color: rgba(224, 82, 82, 0.7)" onclick="removeFBStep(\'' + safeId + '\', ' + editor.selectedStep + ')" title="Delete this block">Delete</button>';
                } else {
                    actionsHtml += '<button type="button" class="formula-builder-btn-add" id="' + prefix + '_addBtn" onclick="addBlockFromBuilder(\'' + safeId + '\')" disabled>+ Add Block</button>';
                }
                actionsHtml += '<span style="flex:1"></span>';
                actionsHtml += '<button type="button" class="formula-undo-btn" onclick="fbUndo(\'' + safeId + '\')" title="Undo (Ctrl+Z)">Undo</button>';
                actionsHtml += '<button type="button" class="formula-undo-btn" onclick="fbRedo(\'' + safeId + '\')" title="Redo (Ctrl+Y)">Redo</button>';
                actionsEl.innerHTML = actionsHtml;
            }

            // Refresh builder UI (values, toggles, op buttons)
            refreshBuilderUI(nodeId);
        }

        function startNewBlock(nodeId) {
            const editor = getFBEditor(nodeId);
            editor.selectedStep = -1;
            resetBlockBuilder(nodeId);
            refreshFBEditor(nodeId);
        }

        function onBuilderLabelChange(nodeId) {
            const editor = getFBEditor(nodeId);
            const prefix = 'fbBuilder_' + nodeId;
            const inp = document.getElementById(prefix + '_labelInput');
            editor.builder.label = inp ? inp.value.trim() : '';
            if (editor.selectedStep >= 0) {
                syncBuilderToModel(nodeId);
            }
        }

        function refreshBuilderUI(nodeId) {
            const b = getFBEditor(nodeId).builder;
            const prefix = 'fbBuilder_' + nodeId;

            // Update type toggles
            const leftToggle = document.getElementById(prefix + '_leftToggle');
            if (leftToggle) leftToggle.textContent = b.leftType === 'id' ? 'Node' : '#';

            const rightToggle = document.getElementById(prefix + '_rightToggle');
            if (rightToggle) rightToggle.textContent = b.rightType === 'id' ? 'Node' : '#';

            // Show/hide select vs input for left
            const leftSelect = document.getElementById(prefix + '_leftSelect');
            const leftInput = document.getElementById(prefix + '_leftInput');
            if (leftSelect) leftSelect.style.display = b.leftType === 'id' ? '' : 'none';
            if (leftInput) leftInput.style.display = b.leftType === 'num' ? '' : 'none';

            // Show/hide select vs input for right
            const rightSelect = document.getElementById(prefix + '_rightSelect');
            const rightInput = document.getElementById(prefix + '_rightInput');
            if (rightSelect) rightSelect.style.display = b.rightType === 'id' ? '' : 'none';
            if (rightInput) rightInput.style.display = b.rightType === 'num' ? '' : 'none';

            // Update op buttons
            const ops = ['+', '-', '*', '/'];
            ops.forEach(op => {
                const btn = document.getElementById(prefix + '_op_' + op);
                if (btn) {
                    if (b.op === op) btn.classList.add('active');
                    else btn.classList.remove('active');
                }
            });

            // Enable/disable right row
            const rightRow = document.getElementById(prefix + '_rightRow');
            if (rightRow) {
                if (b.op) rightRow.classList.remove('disabled');
                else rightRow.classList.add('disabled');
            }

            // Sync select/input values
            if (b.leftType === 'id' && leftSelect) leftSelect.value = b.leftValue;
            if (b.leftType === 'num' && leftInput) leftInput.value = b.leftValue;
            if (b.rightType === 'id' && rightSelect) rightSelect.value = b.rightValue;
            if (b.rightType === 'num' && rightInput) rightInput.value = b.rightValue;

            // Update Add button state
            updateBuilderAddButton(nodeId);
        }

        function updateBuilderAddButton(nodeId) {
            const b = getFBEditor(nodeId).builder;
            const addBtn = document.getElementById('fbBuilder_' + nodeId + '_addBtn');
            if (addBtn) addBtn.disabled = !b.leftValue;
        }

        function onBuilderLeftChange(nodeId) {
            const editor = getFBEditor(nodeId);
            const b = editor.builder;
            const prefix = 'fbBuilder_' + nodeId;
            if (b.leftType === 'id') {
                const sel = document.getElementById(prefix + '_leftSelect');
                b.leftValue = sel ? sel.value : '';
            } else {
                const inp = document.getElementById(prefix + '_leftInput');
                b.leftValue = inp ? inp.value.trim() : '';
            }
            if (editor.selectedStep >= 0) {
                syncBuilderToModel(nodeId);
            } else {
                updateBuilderAddButton(nodeId);
            }
        }

        function onBuilderRightChange(nodeId) {
            const editor = getFBEditor(nodeId);
            const b = editor.builder;
            const prefix = 'fbBuilder_' + nodeId;
            if (b.rightType === 'id') {
                const sel = document.getElementById(prefix + '_rightSelect');
                b.rightValue = sel ? sel.value : '';
            } else {
                const inp = document.getElementById(prefix + '_rightInput');
                b.rightValue = inp ? inp.value.trim() : '';
            }
            if (editor.selectedStep >= 0) {
                syncBuilderToModel(nodeId);
            }
        }

        function removeFBStep(nodeId, stepIdx) {
            const editor = getFBEditor(nodeId);
            if (stepIdx < 0 || stepIdx >= editor.model.steps.length) return;

            editor.model.steps.splice(stepIdx, 1);

            // Fix ops array: remove the op that connected this step
            if (editor.model.steps.length === 0) {
                editor.model.ops = [];
            } else if (stepIdx === 0) {
                // Removed first step â€” remove first op
                if (editor.model.ops.length > 0) editor.model.ops.splice(0, 1);
            } else {
                // Remove the op before this step (stepIdx - 1)
                if (stepIdx - 1 < editor.model.ops.length) editor.model.ops.splice(stepIdx - 1, 1);
            }

            // Deselect if we removed the selected step
            if (editor.selectedStep === stepIdx) {
                editor.selectedStep = -1;
                editor.builder = { leftType: 'id', leftValue: '', op: null, rightType: 'id', rightValue: '', label: '' };
            } else if (editor.selectedStep > stepIdx) {
                editor.selectedStep--;
            }

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function cycleFBInterOp(nodeId, opIdx) {
            const editor = getFBEditor(nodeId);
            if (opIdx < 0 || opIdx >= editor.model.ops.length) return;
            const cycle = ['+', '-', '*', '/'];
            const cur = editor.model.ops[opIdx];
            const next = cycle[(cycle.indexOf(cur) + 1) % cycle.length];
            editor.model.ops[opIdx] = next;

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function cycleFBBlockOp(nodeId, stepIdx) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step || !step.block.op) return;
            const cycle = ['+', '-', '*', '/'];
            const cur = step.block.op;
            step.block.op = cycle[(cycle.indexOf(cur) + 1) % cycle.length];

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function selectFBStep(nodeId, stepIdx) {
            const editor = getFBEditor(nodeId);
            // Toggle selection
            if (editor.selectedStep === stepIdx) {
                editor.selectedStep = -1;
                resetBlockBuilder(nodeId);
            } else {
                editor.selectedStep = stepIdx;
                loadStepIntoBuilder(nodeId, stepIdx);
            }
            refreshFBEditor(nodeId);
        }

        function updateFBStepValue(nodeId, stepIdx, part, newValue) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step) return;

            const isNum = !isNaN(Number(newValue)) && newValue.trim() !== '';
            const isId = !isNum && newValue.trim() !== '';
            if (!isNum && !isId) return;

            const val = isNum
                ? { type: 'num', value: newValue.trim() }
                : { type: 'id', value: newValue.trim() };

            if (part === 'left') {
                step.block.left = val;
            } else if (part === 'right') {
                step.block.right = val;
            }

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function convertFBToCompound(nodeId, stepIdx) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step || step.block.op) return; // Already has operator

            step.block.op = '+';
            // Don't set right value â€” let user fill it in via the detail editor

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function splitFBBlock(nodeId, stepIdx) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step || !step.block.op || !step.block.right) return;

            const leftStep = { type: 'block', block: { left: { ...step.block.left }, label: step.block.label } };
            const rightStep = { type: 'block', block: { left: { ...step.block.right } } };
            const splitOp = step.block.op;

            // Replace current step with two steps + inter-op
            editor.model.steps.splice(stepIdx, 1, leftStep, rightStep);
            editor.model.ops.splice(stepIdx, 0, splitOp);

            editor.selectedStep = -1;
            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function updateFBStepLabel(nodeId, stepIdx, label) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step) return;
            step.block.label = label.trim() || undefined;
            // No undo push for label-only changes (too noisy)
            refreshFBEditor(nodeId);
        }

        // --- Drag-and-drop state ---
        let _fbDragData = null;

        function onFBDragStart(event, nodeId, stepIdx) {
            _fbDragData = { nodeId, stepIdx };
            event.currentTarget.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', '');

            // Add drag-active to blocks area, drop-target to non-dragged chips
            const area = document.getElementById('fbBlocks_' + nodeId);
            if (area) {
                area.classList.add('drag-active');
                area.querySelectorAll('.formula-step-chip').forEach(chip => {
                    if (chip !== event.currentTarget) chip.classList.add('drop-target');
                });
            }
        }

        function onFBDragEnd(event) {
            _fbDragData = null;
            event.currentTarget.classList.remove('dragging');
            // Clear all indicators and drag classes
            document.querySelectorAll('.formula-drag-indicator').forEach(el => el.remove());
            document.querySelectorAll('.formula-step-chip.drag-over').forEach(el => el.classList.remove('drag-over'));
            document.querySelectorAll('.formula-blocks-area.drag-active').forEach(el => el.classList.remove('drag-active'));
            document.querySelectorAll('.formula-step-chip.drop-target').forEach(el => el.classList.remove('drop-target'));
            document.querySelectorAll('.formula-step-chip.combine-target').forEach(el => el.classList.remove('combine-target'));
        }

        function onFBBlocksAreaDragOver(event, nodeId) {
            if (!_fbDragData || _fbDragData.nodeId !== nodeId) return;
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            const area = event.currentTarget;
            const chips = area.querySelectorAll('.formula-step-chip');
            const mouseX = event.clientX;
            const mouseY = event.clientY;

            // Remove existing indicators and combine highlights
            area.querySelectorAll('.formula-drag-indicator').forEach(el => el.remove());
            chips.forEach(c => c.classList.remove('combine-target'));
            delete area.dataset.fbCombineIdx;

            // Check if mouse is directly over a non-dragged, single-value chip (combine target)
            const editor = getFBEditor(nodeId);
            for (let i = 0; i < chips.length; i++) {
                if (i === _fbDragData.stepIdx) continue; // skip dragged chip
                const rect = chips[i].getBoundingClientRect();
                if (mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom) {
                    // Mouse is over this chip â€” check if it's a single-value block (can combine)
                    const step = editor.model.steps[i];
                    if (step && !(step.block.op && step.block.right)) {
                        // Single-value target: show combine indicator
                        chips[i].classList.add('combine-target');
                        area.dataset.fbCombineIdx = i;
                        area.dataset.fbDropIdx = '';
                        return;
                    }
                }
            }

            // Not over a combinable chip â€” standard insertion reorder
            let insertIdx = _fbDragData.stepIdx;
            let insertBefore = null;

            for (let i = 0; i < chips.length; i++) {
                const rect = chips[i].getBoundingClientRect();
                const midX = rect.left + rect.width / 2;

                if (mouseY < rect.bottom && (mouseX < midX || mouseY < rect.top)) {
                    insertIdx = i;
                    insertBefore = chips[i];
                    break;
                }
                insertIdx = i + 1;
            }

            // Don't show indicator if dropping in same position
            if (insertIdx === _fbDragData.stepIdx || insertIdx === _fbDragData.stepIdx + 1) return;

            // Show insertion indicator
            const indicator = document.createElement('span');
            indicator.className = 'formula-drag-indicator';
            if (insertBefore) {
                insertBefore.parentNode.insertBefore(indicator, insertBefore);
            } else {
                area.appendChild(indicator);
            }

            area.dataset.fbDropIdx = insertIdx;
        }

        function onFBBlocksAreaDragLeave(event) {
            // Remove indicators when leaving
            const area = event.currentTarget;
            if (!area.contains(event.relatedTarget)) {
                area.querySelectorAll('.formula-drag-indicator').forEach(el => el.remove());
                area.querySelectorAll('.combine-target').forEach(el => el.classList.remove('combine-target'));
                delete area.dataset.fbDropIdx;
                delete area.dataset.fbCombineIdx;
            }
        }

        function onFBDrop(event, nodeId) {
            event.preventDefault();
            if (!_fbDragData || _fbDragData.nodeId !== nodeId) return;

            const area = event.currentTarget;
            const combineIdx = area.dataset.fbCombineIdx;
            const dropIdx = parseInt(area.dataset.fbDropIdx);
            delete area.dataset.fbDropIdx;
            delete area.dataset.fbCombineIdx;

            const sourceIdx = _fbDragData.stepIdx;
            _fbDragData = null;

            const editor = getFBEditor(nodeId);

            // Quick-combine: merge dragged block into target block
            if (combineIdx !== undefined && combineIdx !== '') {
                const targetCombineIdx = parseInt(combineIdx);
                if (!isNaN(targetCombineIdx) && targetCombineIdx !== sourceIdx) {
                    combineFBBlocks(nodeId, targetCombineIdx, sourceIdx);
                    return;
                }
            }

            // Standard reorder
            if (isNaN(dropIdx) || dropIdx === sourceIdx || dropIdx === sourceIdx + 1) return;

            const steps = editor.model.steps;
            const ops = editor.model.ops;

            // Extract the source step
            const movedStep = steps[sourceIdx];

            // Remove step and its associated op
            steps.splice(sourceIdx, 1);
            let removedOp = '+';
            if (ops.length > 0) {
                if (sourceIdx === 0) {
                    removedOp = ops.length > 0 ? ops.splice(0, 1)[0] : '+';
                } else {
                    removedOp = ops.splice(sourceIdx - 1, 1)[0] || '+';
                }
            }

            // Calculate adjusted target index after removal
            let targetIdx = dropIdx;
            if (dropIdx > sourceIdx) targetIdx--;

            // Clamp
            targetIdx = Math.max(0, Math.min(targetIdx, steps.length));

            // Insert step at target position
            steps.splice(targetIdx, 0, movedStep);

            // Insert an op for the new position
            if (steps.length > 1) {
                if (targetIdx === 0) {
                    ops.splice(0, 0, removedOp);
                } else {
                    ops.splice(targetIdx - 1, 0, removedOp);
                }
            }

            // Ensure ops.length === steps.length - 1
            while (ops.length > steps.length - 1) ops.pop();
            while (ops.length < steps.length - 1) ops.push('+');

            // Update selection if needed
            if (editor.selectedStep === sourceIdx) {
                editor.selectedStep = targetIdx;
            } else if (editor.selectedStep >= 0) {
                if (editor.selectedStep > sourceIdx) editor.selectedStep--;
                if (editor.selectedStep >= targetIdx) editor.selectedStep++;
            }

            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        function combineFBBlocks(nodeId, targetIdx, sourceIdx) {
            const editor = getFBEditor(nodeId);
            const steps = editor.model.steps;
            const ops = editor.model.ops;
            const targetStep = steps[targetIdx];
            const sourceStep = steps[sourceIdx];

            if (!targetStep || !sourceStep) return;

            // Determine the inter-op between source and target to use as internal op
            let combineOp = '+';
            const lo = Math.min(sourceIdx, targetIdx);
            const hi = Math.max(sourceIdx, targetIdx);
            // Use the op between them if they're adjacent
            if (hi - lo === 1 && lo < ops.length) {
                combineOp = ops[lo];
            }

            // Target becomes compound: target.left stays, source.left becomes target.right
            targetStep.block.op = combineOp;
            targetStep.block.right = { ...sourceStep.block.left };

            // Remove source step
            steps.splice(sourceIdx, 1);
            // Fix ops: remove one op
            if (steps.length === 0) {
                editor.model.ops = [];
            } else if (sourceIdx === 0) {
                if (ops.length > 0) ops.splice(0, 1);
            } else if (sourceIdx - 1 < ops.length) {
                ops.splice(sourceIdx - 1, 1);
            }

            while (ops.length > steps.length - 1) ops.pop();
            while (ops.length < steps.length - 1) ops.push('+');

            editor.selectedStep = -1;
            editor.builder = { leftType: 'id', leftValue: '', op: null, rightType: 'id', rightValue: '', label: '' };
            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        // --- Expand/Collapse ---

        function expandFBEditor(nodeId) {
            // Collapse any other expanded editor first
            document.querySelectorAll('.formula-editor-expanded.active').forEach(el => {
                const otherId = el.dataset.nodeId;
                if (otherId && otherId !== nodeId) {
                    const otherEditor = _fbEditors[otherId];
                    if (otherEditor) otherEditor.expanded = false;
                    el.classList.remove('active');
                }
            });

            const editor = getFBEditor(nodeId);
            editor.expanded = true;

            const expandedEl = document.getElementById('fbExpanded_' + nodeId);
            if (expandedEl) {
                expandedEl.classList.add('active');

                // Position via JS: align to the summary element's position
                const summaryEl = document.getElementById('fbSummary_' + nodeId);
                if (summaryEl) {
                    const rect = summaryEl.getBoundingClientRect();
                    const editorWidth = 580;
                    // Try to position so the right edge aligns with the summary's right edge
                    let left = rect.right - editorWidth;
                    // Don't go off the left edge of the viewport
                    if (left < 10) left = 10;
                    // Don't go off the right edge either
                    if (left + editorWidth > window.innerWidth - 10) {
                        left = window.innerWidth - editorWidth - 10;
                    }
                    expandedEl.style.left = left + 'px';
                    expandedEl.style.top = Math.max(60, rect.top - 8) + 'px';
                }

                // Focus for keyboard shortcuts
                expandedEl.focus();
            }

            // Hide summary
            const summaryEl = document.getElementById('fbSummary_' + nodeId);
            if (summaryEl) summaryEl.style.display = 'none';

            refreshFBEditor(nodeId);

            // Sync builder UI after DOM is ready
            requestAnimationFrame(function() { refreshBuilderUI(nodeId); });
        }

        function collapseFBEditor(nodeId) {
            const editor = getFBEditor(nodeId);
            editor.expanded = false;
            editor.selectedStep = -1;

            const expandedEl = document.getElementById('fbExpanded_' + nodeId);
            if (expandedEl) expandedEl.classList.remove('active');

            // Show summary
            const summaryEl = document.getElementById('fbSummary_' + nodeId);
            if (summaryEl) summaryEl.style.display = '';

            refreshFBEditor(nodeId);
        }

        // --- Click-outside handler ---
        document.addEventListener('mousedown', function(e) {
            const expanded = document.querySelector('.formula-editor-expanded.active');
            if (expanded && !expanded.contains(e.target) && !e.target.closest('.formula-summary')) {
                const nodeId = expanded.dataset.nodeId;
                if (nodeId) collapseFBEditor(nodeId);
            }
        });

        // --- Rendering: collapsed summary ---

        function renderFBSection(nodeId, sourceNodes, formula, formulaGroups, formulaBlocks) {
            const editor = getFBEditor(nodeId);
            editor.sourceNodes = sourceNodes || [];
            const safeId = nodeId.replace(/'/g, "\\'");
            const escapedFormula = (formula || '').replace(/"/g, '&quot;');
            const isNew = nodeId === 'new';
            const hiddenInputId = isNew ? 'newNodeFormula' : 'derivedFormula_' + nodeId;

            // Build summary preview text
            _currentPreviewNodeId = nodeId;
            const previewHtml = formula && formula.trim()
                ? renderFBPreview(formula)
                : '<span class="formula-summary-empty">No formula defined â€” click to add</span>';
            _currentPreviewNodeId = null;

            let html = '<div class="formula-section">';

            // Collapsed summary
            html += '<div class="formula-summary" id="fbSummary_' + nodeId + '" onclick="expandFBEditor(\'' + safeId + '\')">';
            html += '<div class="formula-summary-top"><button type="button" class="formula-summary-edit-btn" onclick="event.stopPropagation(); expandFBEditor(\'' + safeId + '\')">Edit</button></div>';
            html += '<span class="formula-summary-text" id="fbSummaryText_' + nodeId + '">' + previewHtml + '</span>';
            html += '</div>';

            // Expanded editor (hidden by default)
            html += '<div class="formula-editor-expanded" id="fbExpanded_' + nodeId + '" data-node-id="' + nodeId + '" tabindex="0" onkeydown="onFBKeyDown(event, \'' + safeId + '\')">';

            // Header
            html += '<div class="formula-editor-header">';
            html += '<span class="formula-editor-title">Formula Editor</span>';
            html += '<button type="button" class="formula-editor-close" onclick="collapseFBEditor(\'' + safeId + '\')" title="Close">&times;</button>';
            html += '</div>';

            // Blocks area
            html += '<div class="formula-blocks-area" id="fbBlocks_' + nodeId + '"';
            html += ' ondragover="onFBBlocksAreaDragOver(event, \'' + safeId + '\')"';
            html += ' ondragleave="onFBBlocksAreaDragLeave(event)"';
            html += ' ondrop="onFBDrop(event, \'' + safeId + '\')">';
            html += '</div>';

            // Unified block panel (builder in new mode, editor in edit mode)
            const prefix = 'fbBuilder_' + nodeId;
            html += '<div class="formula-editor-toolbar" id="fbPanel_' + nodeId + '">';
            html += '<div class="formula-builder-header" id="' + prefix + '_header">New Block</div>';

            // Build source node options for selects
            let nodeOptions = '<option value="">-- Select --</option>';
            if (sourceNodes && sourceNodes.length > 0) {
                const groups = {};
                sourceNodes.forEach(n => {
                    const type = n.type.charAt(0).toUpperCase() + n.type.slice(1) + 's';
                    if (!groups[type]) groups[type] = [];
                    groups[type].push(n);
                });
                Object.entries(groups).forEach(([label, nodes]) => {
                    nodeOptions += '<optgroup label="' + label + '">';
                    nodes.forEach(n => { nodeOptions += '<option value="' + n.id + '">' + n.name + '</option>'; });
                    nodeOptions += '</optgroup>';
                });
            }

            // Left value row
            html += '<div class="formula-builder-row">';
            html += '<span class="formula-builder-label">Left</span>';
            html += '<div class="formula-builder-value">';
            html += '<button type="button" class="formula-builder-type-toggle" id="' + prefix + '_leftToggle" onclick="toggleBuilderValueType(\'' + safeId + '\', \'left\')">Node</button>';
            html += '<select class="formula-builder-select" id="' + prefix + '_leftSelect" onchange="onBuilderLeftChange(\'' + safeId + '\')">' + nodeOptions + '</select>';
            html += '<input type="text" class="formula-builder-num-input" id="' + prefix + '_leftInput" placeholder="Number" oninput="onBuilderLeftChange(\'' + safeId + '\')" style="display:none">';
            html += '</div></div>';

            // Op buttons row
            html += '<div class="formula-builder-row">';
            html += '<span class="formula-builder-label">Op</span>';
            html += '<div class="formula-builder-ops">';
            ['+', '-', '*', '/'].forEach(op => {
                const display = op === '*' ? '\u00d7' : op === '/' ? '\u00f7' : op;
                html += '<button type="button" class="formula-builder-op-btn" id="' + prefix + '_op_' + op + '" onclick="selectBuilderOp(\'' + safeId + '\', \'' + op + '\')">' + display + '</button>';
            });
            html += '</div></div>';

            // Right value row
            html += '<div class="formula-builder-row formula-builder-right disabled" id="' + prefix + '_rightRow">';
            html += '<span class="formula-builder-label">Right</span>';
            html += '<div class="formula-builder-value">';
            html += '<button type="button" class="formula-builder-type-toggle" id="' + prefix + '_rightToggle" onclick="toggleBuilderValueType(\'' + safeId + '\', \'right\')">Node</button>';
            html += '<select class="formula-builder-select" id="' + prefix + '_rightSelect" onchange="onBuilderRightChange(\'' + safeId + '\')">' + nodeOptions + '</select>';
            html += '<input type="text" class="formula-builder-num-input" id="' + prefix + '_rightInput" placeholder="Number" oninput="onBuilderRightChange(\'' + safeId + '\')" style="display:none">';
            html += '</div></div>';

            // Label row (edit mode only, hidden by default)
            html += '<div class="formula-builder-row" id="' + prefix + '_labelRow" style="display:none">';
            html += '<span class="formula-builder-label">Label</span>';
            html += '<div class="formula-builder-value">';
            html += '<input type="text" class="formula-builder-num-input" id="' + prefix + '_labelInput" placeholder="optional name" style="color: var(--text-muted); font-weight: 400" onchange="onBuilderLabelChange(\'' + safeId + '\')">';
            html += '</div></div>';

            // Actions row
            html += '<div class="formula-builder-actions" id="' + prefix + '_actions">';
            html += '<button type="button" class="formula-builder-btn-add" id="' + prefix + '_addBtn" onclick="addBlockFromBuilder(\'' + safeId + '\')" disabled>+ Add Block</button>';
            html += '<span style="flex:1"></span>';
            html += '<button type="button" class="formula-undo-btn" onclick="fbUndo(\'' + safeId + '\')" title="Undo (Ctrl+Z)">Undo</button>';
            html += '<button type="button" class="formula-undo-btn" onclick="fbRedo(\'' + safeId + '\')" title="Redo (Ctrl+Y)">Redo</button>';
            html += '</div>';

            html += '</div>'; // end panel

            // Errors
            html += '<div class="formula-errors-box" id="fbErrors_' + nodeId + '"></div>';

            // Preview
            html += '<div class="formula-preview" id="fbPreview_' + nodeId + '"></div>';

            html += '</div>'; // end expanded editor

            // Hidden input for backward compat
            html += '<input type="hidden" id="' + hiddenInputId + '" value="' + escapedFormula + '">';

            html += '</div>'; // end formula-section

            return html;
        }

        // --- Rendering: blocks area ---

        function renderFBBlocksArea(nodeId) {
            const editor = getFBEditor(nodeId);
            const model = editor.model;
            if (!model.steps || model.steps.length === 0) return '';

            const safeId = nodeId.replace(/'/g, "\\'");
            let html = '';

            for (let i = 0; i < model.steps.length; i++) {
                // Render inter-step operator before this step (except first)
                if (i > 0 && i - 1 < model.ops.length) {
                    const op = model.ops[i - 1];
                    const opDisplay = op === '*' ? '&times;' : op === '/' ? '&divide;' : op;
                    html += '<span class="formula-inter-op" onclick="cycleFBInterOp(\'' + safeId + '\', ' + (i - 1) + ')" title="Click to change operator">' + opDisplay + '</span>';
                }

                // Render step chip
                html += renderFBStepChip(nodeId, i, model.steps[i]);
            }

            return html;
        }

        function renderFBStepChip(nodeId, stepIdx, step) {
            const safeId = nodeId.replace(/'/g, "\\'");
            const editor = getFBEditor(nodeId);
            const b = step.block;
            const isSelected = editor.selectedStep === stepIdx;
            const isCompound = b.op && b.right;

            let cls = 'formula-step-chip';
            if (isSelected) cls += ' selected';
            if (isCompound) cls += ' compound';

            let html = '<span class="' + cls + '" draggable="true"';
            html += ' ondragstart="onFBDragStart(event, \'' + safeId + '\', ' + stepIdx + ')"';
            html += ' ondragend="onFBDragEnd(event)"';
            html += ' onclick="selectFBStep(\'' + safeId + '\', ' + stepIdx + ')">';

            // Quick delete button
            html += '<span class="formula-step-delete" onclick="event.stopPropagation(); removeFBStep(\'' + safeId + '\', ' + stepIdx + ')" title="Delete">&#10005;</span>';

            // Split button (compound blocks only)
            if (isCompound) {
                html += '<span class="formula-step-split" onclick="event.stopPropagation(); splitFBBlock(\'' + safeId + '\', ' + stepIdx + ')" title="Split to 2 blocks">&#8596;</span>';
            }

            // Label (if present)
            if (b.label) {
                html += '<span class="formula-step-label">' + b.label + '</span>';
            }

            // Left value
            html += renderFBValue(b.left);

            // Internal operator (if compound)
            if (b.op) {
                const opDisplay = b.op === '*' ? '&times;' : b.op === '/' ? '&divide;' : b.op;
                html += '<span class="formula-step-op" onclick="event.stopPropagation(); cycleFBBlockOp(\'' + safeId + '\', ' + stepIdx + ')" title="Click to change">' + opDisplay + '</span>';
            }

            // Right value (if compound)
            if (isCompound) {
                html += renderFBValue(b.right);
            }

            html += '</span>';
            return html;
        }

        function renderFBValue(val) {
            if (!val) return '';
            let cls = 'formula-step-value';
            let label = val.value;
            if (val.type === 'id') {
                cls += ' is-id';
                const n = config.nodes.find(nd => nd.id === val.value);
                if (n) { label = n.name; }
                else { cls += ' seg-error'; }
            } else {
                cls += ' is-num';
            }
            return '<span class="' + cls + '">' + label + '</span>';
        }

        // --- Rendering: block detail editor ---

        function renderFBDetailEditor(nodeId, stepIdx) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step) return '';

            const safeId = nodeId.replace(/'/g, "\\'");
            const b = step.block;
            const hasOp = !!b.op;
            const isCompound = b.op && b.right;
            const sourceNodes = editor.sourceNodes || [];

            let html = '';

            // Header
            html += '<div class="formula-detail-header-row">';
            html += '<span class="formula-detail-title">Block ' + (stepIdx + 1) + (b.label ? ' â€” "' + b.label + '"' : '') + '</span>';
            html += '</div>';

            // Left value row
            html += '<div class="formula-detail-row">';
            html += '<span class="formula-detail-label">' + (hasOp ? 'Left' : 'Value') + '</span>';
            html += renderFBValueSelector(nodeId, stepIdx, 'left', b.left, sourceNodes);
            html += '</div>';

            // Operator + Right value (show when op is set, even without right value yet)
            if (hasOp) {
                html += '<div class="formula-detail-row">';
                html += '<span class="formula-detail-label">Op</span>';
                html += renderFBOpSelector(nodeId, stepIdx, b.op);
                html += '</div>';

                html += '<div class="formula-detail-row">';
                html += '<span class="formula-detail-label">Right</span>';
                html += renderFBValueSelector(nodeId, stepIdx, 'right', b.right || { type: 'id', value: '' }, sourceNodes);
                html += '</div>';
            }

            // Label row
            html += '<div class="formula-detail-row">';
            html += '<span class="formula-detail-label">Label</span>';
            html += '<input type="text" class="formula-detail-input" value="' + (b.label || '') + '" placeholder="optional name" onchange="updateFBStepLabel(\'' + safeId + '\', ' + stepIdx + ', this.value)">';
            html += '</div>';

            // Action buttons
            html += '<div class="formula-detail-actions">';
            if (!hasOp) {
                html += '<button type="button" class="formula-detail-btn" onclick="convertFBToCompound(\'' + safeId + '\', ' + stepIdx + ')">+ Add Second Value</button>';
            } else if (isCompound) {
                html += '<button type="button" class="formula-detail-btn" onclick="splitFBBlock(\'' + safeId + '\', ' + stepIdx + ')">Split to 2 Blocks</button>';
            }
            html += '<button type="button" class="formula-detail-btn delete" onclick="removeFBStep(\'' + safeId + '\', ' + stepIdx + ')">Delete Block</button>';
            html += '</div>';

            return html;
        }

        function renderFBValueSelector(nodeId, stepIdx, part, currentVal, sourceNodes) {
            const safeId = nodeId.replace(/'/g, "\\'");
            const isNum = currentVal && currentVal.type === 'num';

            let html = '<div class="formula-value-selector">';

            if (isNum) {
                // Number input
                html += '<input type="text" class="formula-detail-num-input" value="' + (currentVal.value || '0') + '"';
                html += ' onchange="updateFBStepValue(\'' + safeId + '\', ' + stepIdx + ', \'' + part + '\', this.value)">';
                // Switch to ID button
                html += '<select class="formula-detail-id-switch" onchange="if(this.value) { updateFBStepValue(\'' + safeId + '\', ' + stepIdx + ', \'' + part + '\', this.value); }">';
                html += '<option value="">â†’ node</option>';
                const groups = {};
                sourceNodes.forEach(n => {
                    const type = n.type.charAt(0).toUpperCase() + n.type.slice(1) + 's';
                    if (!groups[type]) groups[type] = [];
                    groups[type].push(n);
                });
                Object.entries(groups).forEach(([label, nodes]) => {
                    html += '<optgroup label="' + label + '">';
                    nodes.forEach(n => { html += '<option value="' + n.id + '">' + n.name + '</option>'; });
                    html += '</optgroup>';
                });
                html += '</select>';
            } else {
                // ID dropdown
                html += '<select class="formula-detail-id-select" onchange="updateFBStepValue(\'' + safeId + '\', ' + stepIdx + ', \'' + part + '\', this.value)">';
                if (!currentVal || !currentVal.value) {
                    html += '<option value="" selected>-- Select --</option>';
                }
                const groups = {};
                sourceNodes.forEach(n => {
                    const type = n.type.charAt(0).toUpperCase() + n.type.slice(1) + 's';
                    if (!groups[type]) groups[type] = [];
                    groups[type].push(n);
                });
                Object.entries(groups).forEach(([label, nodes]) => {
                    html += '<optgroup label="' + label + '">';
                    nodes.forEach(n => {
                        const sel = (currentVal && currentVal.value === n.id) ? ' selected' : '';
                        html += '<option value="' + n.id + '"' + sel + '>' + n.name + '</option>';
                    });
                    html += '</optgroup>';
                });
                html += '</select>';
                // Switch to number button
                html += '<input type="text" class="formula-detail-num-switch" placeholder="#" onkeydown="if(event.key===\'Enter\'){updateFBStepValue(\'' + safeId + '\', ' + stepIdx + ', \'' + part + '\', this.value);}">';
            }

            html += '</div>';
            return html;
        }

        function renderFBOpSelector(nodeId, stepIdx, currentOp) {
            const safeId = nodeId.replace(/'/g, "\\'");
            const ops = ['+', '-', '*', '/'];
            const displays = ['+', 'âˆ’', 'Ã—', 'Ã·'];

            let html = '<div class="formula-op-selector">';
            for (let i = 0; i < ops.length; i++) {
                const active = currentOp === ops[i] ? ' active' : '';
                html += '<button type="button" class="formula-op-btn' + active + '" onclick="setFBBlockOp(\'' + safeId + '\', ' + stepIdx + ', \'' + ops[i] + '\')">' + displays[i] + '</button>';
            }
            html += '</div>';
            return html;
        }

        function setFBBlockOp(nodeId, stepIdx, op) {
            const editor = getFBEditor(nodeId);
            const step = editor.model.steps[stepIdx];
            if (!step) return;
            step.block.op = op;
            pushFBUndoState(nodeId);
            refreshFBEditor(nodeId);
        }

        // --- Legacy parser: used for migration from old formula strings ---
        // LTR mode: every op is a formula-level op, every value is a simple block
        function parseFormulaLTR(tokens) {
            const elements = [];
            let i = 0;
            while (i < tokens.length) {
                const t = tokens[i];
                if (t.type === 'op' && t.value === '(') {
                    const sub = parseLTRGroup(tokens, i + 1);
                    elements.push({ type: 'group', children: sub.elements });
                    i = sub.endIdx + 1;
                } else if (t.type === 'op' && t.value === ')') {
                    break;
                } else if (t.type === 'op') {
                    elements.push({ type: 'op', value: t.value });
                    i++;
                } else if (t.type === 'id' || t.type === 'num') {
                    elements.push({ type: 'block', block: { left: { type: t.type, value: t.value } } });
                    i++;
                } else { i++; }
            }
            return { elements };
        }

        function parseLTRGroup(tokens, startIdx) {
            const elements = [];
            let i = startIdx;
            while (i < tokens.length) {
                const t = tokens[i];
                if (t.type === 'op' && t.value === '(') {
                    const sub = parseLTRGroup(tokens, i + 1);
                    elements.push({ type: 'group', children: sub.elements });
                    i = sub.endIdx + 1;
                } else if (t.type === 'op' && t.value === ')') {
                    return { elements, endIdx: i };
                } else if (t.type === 'op') {
                    elements.push({ type: 'op', value: t.value });
                    i++;
                } else if (t.type === 'id' || t.type === 'num') {
                    elements.push({ type: 'block', block: { left: { type: t.type, value: t.value } } });
                    i++;
                } else { i++; }
            }
            return { elements, endIdx: i };
        }



        // Render a stacked probability bar for a set of traits
        function renderStackedProbBar(traits, opts = {}) {
            const height = opts.height || 16;
            const showLabels = opts.showLabels !== false;
            if (!traits || traits.length === 0) return '';
            return `
                <div class="prob-stacked-bar" style="height: ${height}px;">
                    ${traits.map((t, i) => {
                        const color = getTraitColor(i);
                        const label = showLabels && t.pct >= 18 ? `<span class="prob-stacked-label" style="line-height: ${height}px;">${t.name} ${t.pct}%</span>` : '';
                        return `<div class="prob-stacked-segment" style="width: ${t.pct}%; background: ${color};" title="${t.name}: ${t.pct}%">${label}</div>`;
                    }).join('')}
                </div>
            `;
        }

        // Render probability context for a trait's layer in the detail panel
        function renderLayerProbabilityVisual(layerId) {
            const layer = config.nodes.find(n => n.id === layerId);
            if (!layer) return '';
            const traits = config.nodes.filter(n =>
                (n.type === 'trait' || n.type === 'item') && n.config.layerId === layerId && n.config.selection?.mode !== 'threshold'
            );
            if (traits.length < 2) return '';
            const totalWeight = traits.reduce((sum, t) => sum + (t.config.selection?.baseWeight ?? 20), 0);
            if (totalWeight <= 0) return '';
            const traitData = traits.map(t => ({
                name: t.name,
                pct: Math.round(((t.config.selection?.baseWeight ?? 20) / totalWeight) * 100),
                id: t.id
            }));
            return `
                <div style="margin-top: 0.5rem;">
                    <div style="font-size: 0.65rem; color: var(--text-muted); margin-bottom: 0.25rem;">${layer.name} probabilities</div>
                    ${renderStackedProbBar(traitData, { height: 12 })}
                </div>
            `;
        }

        function calculateSpawnProbabilities(presetId = '') {
            const preset = presetId ? (config.presets || []).find(p => p.id === presetId) : null;

            // Get layers sorted by order
            const layers = config.nodes.filter(n => n.type === 'layer')
                .sort((a, b) => (a.config?.order ?? 0) - (b.config?.order ?? 0));

            const probabilities = [];

            layers.forEach(layer => {
                const layerItems = config.nodes.filter(n =>
                    (n.type === 'item' || n.type === 'trait') &&
                    n.config?.layerId === layer.id &&
                    n.config?.selection?.mode !== 'threshold'
                );

                if (layerItems.length === 0) return;

                // Get layer config info
                const layerConfig = layer.config || {};
                const selectionMode = layerConfig.selection?.mode || 'weighted';
                const equalWeights = layerConfig.selection?.equalWeights || false;

                // Calculate base weights with detailed influence tracking
                let totalWeight = 0;
                const traitWeights = layerItems.map(item => {
                    const baseWeight = item.config?.selection?.baseWeight ?? item.config?.baseWeight ?? 1;
                    let weight = baseWeight;
                    const influences = [];

                    // Check if preset forces this trait
                    const forcedByPreset = preset?.forceTraits?.includes(item.id);

                    // Check for eligibility gates (blocking relationships)
                    const eligibilityGates = config.relationships
                        .filter(r => r.type === 'eligibility_gate' && r.targetId === item.id)
                        .map(rel => {
                            const sourceNode = config.nodes.find(n => n.id === rel.sourceId);
                            return {
                                type: 'eligibility_gate',
                                sourceId: rel.sourceId,
                                sourceName: sourceNode?.name || rel.sourceId,
                                sourceType: sourceNode?.type || 'unknown',
                                condition: rel.config?.condition || 'active'
                            };
                        });

                    // Apply weight influences from relationships
                    const simValues = getSimulatorValues();
                    const weightInfluenceRels = config.relationships
                        .filter(r => r.type === 'weight_influence' && r.targetId === item.id);

                    weightInfluenceRels.forEach(rel => {
                            const sourceNode = config.nodes.find(n => n.id === rel.sourceId);
                            if (sourceNode?.type === 'attribute' || sourceNode?.type === 'variable') {
                                // Use simulator value if available, otherwise midpoint/default
                                const isAttr = sourceNode.type === 'attribute';
                                const nodeMin = sourceNode.config?.min ?? (isAttr ? 1 : 0);
                                const nodeMax = sourceNode.config?.max ?? (isAttr ? 10 : 100);
                                const defaultVal = isAttr
                                    ? Math.round((nodeMin + nodeMax) / 2)
                                    : (sourceNode.config?.default ?? sourceNode.config?.defaultValue ?? nodeMin);
                                const nodeValue = simValues[sourceNode.id] ?? defaultVal;
                                const usingSimulator = simValues[sourceNode.id] !== undefined;

                                // For attribute/variable sources, ALWAYS scale by source value
                                // This is the expected behavior: higher attr = more influence
                                // Config formats:
                                // - Old format: { multiplier: 0.1 } -> effect = nodeValue * multiplier
                                // - New format: { value: 3 } -> effect = nodeValue * value (per point)
                                // - Explicit flat: { value: 10, scaling: "flat" } -> effect = value (rare case)
                                let effect = 0;
                                let formula = '';
                                const scaling = rel.config?.scaling;
                                const value = rel.config?.value ?? rel.config?.multiplier ?? 0;

                                // Default to per-point scaling for attributes/variables
                                // Only use flat if explicitly set to "flat"
                                if (scaling === 'flat') {
                                    // Explicit flat - fixed amount regardless of source value
                                    effect = value;
                                    formula = `${sourceNode.name} â†’ ${value >= 0 ? '+' : ''}${value} (flat)`;
                                } else {
                                    // Per-point scaling (default for attr/var sources)
                                    effect = nodeValue * value;
                                    formula = `${sourceNode.name}(${nodeValue}) Ã— ${value}`;
                                }

                                // Apply invert flag if set (higher source = lower weight)
                                if (rel.config?.invert) {
                                    effect = -effect;
                                    formula += ' (inverted)';
                                }

                                // Apply diminishing returns if enabled on layer
                                if (layerConfig.selection?.diminishingReturns && effect !== 0) {
                                    effect = Math.sign(effect) * Math.sqrt(Math.abs(effect)) * Math.sqrt(baseWeight);
                                    formula += ' (DR)';
                                }

                                weight += effect;

                                influences.push({
                                    type: 'weight_influence',
                                    sourceId: rel.sourceId,
                                    sourceName: sourceNode.name,
                                    sourceType: sourceNode.type,
                                    multiplier: value,
                                    estimatedValue: nodeValue,
                                    effect: effect,
                                    formula: formula,
                                    note: usingSimulator ? `(sim)` : (isAttr ? `(mid)` : `(def)`)
                                });
                            } else if (sourceNode?.type === 'trait' || sourceNode?.type === 'item') {
                                // Trait-to-trait weight influence (only applies if source is active)
                                const effect = rel.config?.value ?? rel.config?.amount ?? 0;
                                influences.push({
                                    type: 'weight_influence',
                                    sourceId: rel.sourceId,
                                    sourceName: sourceNode?.name || rel.sourceId,
                                    sourceType: 'trait',
                                    effect: effect,
                                    formula: `if ${sourceNode?.name || 'trait'} active`,
                                    conditional: true
                                });
                            } else if (sourceNode?.type === 'modifier') {
                                // Modifier-to-trait weight influence
                                // Check if modifier is currently active (triggered or force-applied)
                                const modIsActive = isModifierActive(sourceNode.id);
                                const effectValue = rel.config?.value ?? rel.config?.amount ?? 0;
                                const effect = modIsActive ? effectValue : 0;

                                influences.push({
                                    type: 'weight_influence',
                                    sourceId: rel.sourceId,
                                    sourceName: sourceNode?.name || rel.sourceId,
                                    sourceType: 'modifier',
                                    effect: effect,
                                    potentialEffect: effectValue,
                                    formula: modIsActive
                                        ? `${sourceNode?.name} active â†’ ${effectValue >= 0 ? '+' : ''}${effectValue}`
                                        : `if ${sourceNode?.name || 'modifier'} active`,
                                    conditional: !modIsActive,
                                    modifierActive: modIsActive
                                });

                                // Apply to weight if modifier is active
                                if (modIsActive) {
                                    let modEffect = effectValue;
                                    if (layerConfig.selection?.diminishingReturns && modEffect !== 0) {
                                        modEffect = Math.sign(modEffect) * Math.sqrt(Math.abs(modEffect)) * Math.sqrt(baseWeight);
                                    }
                                    weight += modEffect;
                                }
                            }
                        });

                    const weightFloor = layerConfig.selection?.weightFloor ?? 0;
                    weight = Math.max(weightFloor, weight);
                    totalWeight += weight;

                    return {
                        id: item.id,
                        name: item.name,
                        baseWeight,
                        weight,
                        influences,
                        eligibilityGates,
                        forcedByPreset
                    };
                });

                // Calculate percentages
                const traits = traitWeights.map(t => ({
                    ...t,
                    pct: totalWeight > 0 ? Math.round(t.weight / totalWeight * 100) : 0,
                    basePct: totalWeight > 0 ? Math.round(t.baseWeight / totalWeight * 100) : 0
                })).sort((a, b) => b.pct - a.pct);

                probabilities.push({
                    layer: layer.name,
                    layerId: layer.id,
                    traits,
                    rollRange: layer.config?.selection?.rollRange || [1, 1],
                    selectionMode,
                    equalWeights,
                    totalWeight
                });
            });

            return probabilities;
        }

        function renderProbabilityBreakdown() {
            const presetSelector = document.getElementById('spawnPresetSelector');
            const presetId = presetSelector ? presetSelector.value : '';

            const probabilities = calculateSpawnProbabilities(presetId);
            const baselineProbabilities = calculateBaselineProbabilities(presetId);

            if (probabilities.length === 0) {
                return '<div class="empty-hint">No layers with traits defined</div>';
            }

            // Store probabilities data for tooltip access
            window._probabilityData = probabilities;
            window._baselineProbabilities = baselineProbabilities;

            return `
                <div class="probability-viz">
                    ${probabilities.map((layer, layerIdx) => {
                        const baselineLayer = baselineProbabilities[layerIdx];
                        return `
                        <div class="prob-layer-card">
                            <div class="prob-layer-header">
                                <span class="prob-layer-name">
                                    <span style="color: var(--node-layer);">â—ˆ</span>
                                    ${layer.layer}
                                    ${layer.rollRange[0] !== layer.rollRange[1] ?
                                        `<span class="prob-layer-rolls">(rolls ${layer.rollRange[0]}-${layer.rollRange[1]})</span>` :
                                        layer.rollRange[0] > 1 ?
                                        `<span class="prob-layer-rolls">(${layer.rollRange[0]} rolls)</span>` : ''
                                    }
                                </span>
                            </div>
                            <div class="prob-layer-body">
                                ${renderStackedProbBar(layer.traits)}
                                ${layer.traits.map((t, traitIdx) => {
                                    const baselineTrait = baselineLayer?.traits.find(bt => bt.id === t.id);
                                    const baselinePct = baselineTrait?.pct ?? t.pct;
                                    const delta = t.pct - baselinePct;
                                    const hasInfluences = t.influences.length > 0;
                                    const hasGates = t.eligibilityGates.length > 0;
                                    const isHighlighted = hasInfluences && t.influences.some(inf =>
                                        window._activeSimulatorAttr === inf.sourceId
                                    );
                                    const traitColor = getTraitColor(traitIdx);

                                    // Build influence chips
                                    const influenceChips = t.influences.map(inf => {
                                        const sign = inf.effect >= 0 ? '+' : '';
                                        const cls = inf.effect >= 0 ? 'positive' : 'negative';
                                        return `<span class="influence-chip ${cls}" title="${inf.formula} ${inf.note || ''}">${inf.sourceName}: ${sign}${inf.effect.toFixed(1)}</span>`;
                                    }).join('');

                                    return `
                                    <div class="prob-breakdown-row ${isHighlighted ? 'highlighted' : ''} ${hasGates ? 'gated' : ''}"
                                         data-trait-id="${t.id}"
                                         onmouseenter="showProbabilityTooltip(event, ${layerIdx}, ${traitIdx})"
                                         onmouseleave="hideProbabilityTooltip()">
                                        <span class="prob-trait-name" style="display: flex; align-items: center; gap: 4px;">
                                            <span class="prob-color-dot" style="background: ${traitColor};"></span>
                                            ${t.name}
                                            ${hasGates ? '<span class="gate-icon" title="Has eligibility gates">ðŸš«</span>' : ''}
                                        </span>
                                        <div class="prob-bar-container">
                                            <div class="prob-bar" style="width: ${t.pct}%; background: ${traitColor};">
                                            </div>
                                        </div>
                                        <span class="prob-pct">
                                            ${t.pct}%
                                            ${delta !== 0 ? `<span class="delta-text ${delta > 0 ? 'positive' : 'negative'}">${delta > 0 ? '+' : ''}${delta}</span>` : ''}
                                        </span>
                                        ${hasInfluences ? `<div class="prob-influences">${influenceChips}</div>` : ''}
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                    `}).join('')}
                </div>
            `;
        }

        // Calculate baseline probabilities (using midpoint attribute values, ignoring simulator)
        function calculateBaselineProbabilities(presetId = '') {
            const savedSimValues = { ...simulatorValues };
            simulatorValues = {}; // Temporarily clear to get midpoints
            const baseline = calculateSpawnProbabilities(presetId);
            simulatorValues = savedSimValues; // Restore
            return baseline;
        }

        // Probability tooltip functions
        let probabilityTooltipEl = null;

        function showProbabilityTooltip(event, layerIdx, traitIdx) {
            const data = window._probabilityData;
            if (!data || !data[layerIdx] || !data[layerIdx].traits[traitIdx]) return;

            const trait = data[layerIdx].traits[traitIdx];
            const layer = data[layerIdx];
            const baseline = window._baselineProbabilities?.[layerIdx]?.traits?.find(t => t.id === trait.id);
            const baselinePct = baseline?.pct ?? trait.pct;
            const delta = trait.pct - baselinePct;

            // Create tooltip if needed
            if (!probabilityTooltipEl) {
                probabilityTooltipEl = document.createElement('div');
                probabilityTooltipEl.className = 'probability-tooltip';
                document.body.appendChild(probabilityTooltipEl);
            }

            // Build cascade chain visualization
            let cascadeHtml = '';
            if (trait.influences.length > 0) {
                cascadeHtml = `
                    <div class="cascade-chain">
                        ${trait.influences.map(inf => `
                            <div class="chain-step">
                                <span class="chain-node attr">${inf.sourceName}: ${inf.estimatedValue}</span>
                                <span class="chain-arrow">â†’</span>
                                <span class="chain-node effect">Ã—${inf.multiplier}</span>
                                <span class="chain-arrow">â†’</span>
                                <span class="chain-node trait" style="color: ${inf.effect >= 0 ? 'var(--accent-success)' : 'var(--accent-danger)'}">
                                    ${inf.effect >= 0 ? '+' : ''}${inf.effect.toFixed(1)} weight
                                </span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Build tooltip content
            let html = `
                <div class="probability-tooltip-header">
                    ${trait.name}
                    <span style="font-weight: normal; color: var(--accent-gold); margin-left: 0.5rem;">${trait.pct}%</span>
                    ${delta !== 0 ? `<span style="font-size: 0.75rem; color: ${delta > 0 ? 'var(--accent-success)' : 'var(--accent-danger)'}; margin-left: 0.25rem;">(${delta > 0 ? '+' : ''}${delta}% from baseline)</span>` : ''}
                </div>
                ${cascadeHtml}
                <div class="probability-tooltip-math">
                    <div class="math-line">
                        <span class="math-label">Base weight:</span>
                        <span class="math-value">${trait.baseWeight.toFixed(1)}</span>
                    </div>
            `;

            // Show influence effects
            trait.influences.forEach(inf => {
                const effectStr = inf.effect >= 0 ? `+${inf.effect.toFixed(1)}` : inf.effect.toFixed(1);
                const effectClass = inf.effect >= 0 ? 'positive' : 'negative';
                html += `
                    <div class="math-line">
                        <span class="math-label">${inf.conditional ? '(if active) ' : ''}${inf.sourceName}:</span>
                        <span class="math-value ${effectClass}">${effectStr}</span>
                    </div>
                `;
            });

            html += `
                    <div class="math-line">
                        <span class="math-label">Final weight:</span>
                        <span class="math-value">${trait.weight.toFixed(1)} / ${layer.totalWeight.toFixed(1)}</span>
                    </div>
                </div>
            `;

            // Show relationship influences detail
            if (trait.influences.length > 0) {
                html += `
                    <div class="probability-tooltip-influences">
                        <div class="probability-tooltip-influences-title">Weight Influences</div>
                `;
                trait.influences.forEach(inf => {
                    const effectStr = inf.effect >= 0 ? `+${inf.effect.toFixed(1)}` : inf.effect.toFixed(1);
                    const effectClass = inf.effect >= 0 ? 'positive' : 'negative';
                    html += `
                        <div class="probability-tooltip-influence">
                            <span class="influence-icon" style="color: var(--node-weight-influence);">â†”</span>
                            <span class="influence-source">${inf.formula} ${inf.note || ''}</span>
                            <span class="influence-effect ${effectClass}">${effectStr}</span>
                        </div>
                    `;
                });
                html += `</div>`;
            }

            // Show eligibility gates
            if (trait.eligibilityGates.length > 0) {
                html += `
                    <div class="probability-tooltip-influences">
                        <div class="probability-tooltip-influences-title" style="color: var(--accent-danger);">Eligibility Gates</div>
                `;
                trait.eligibilityGates.forEach(gate => {
                    html += `
                        <div class="probability-tooltip-influence">
                            <span class="influence-icon" style="color: var(--accent-danger);">ðŸš«</span>
                            <span class="influence-source">Blocked if ${gate.sourceName} ${gate.condition}</span>
                        </div>
                    `;
                });
                html += `</div>`;
            }

            // Add note for conditional influences
            const hasConditional = trait.influences.some(i => i.conditional);
            if (hasConditional) {
                html += `<div class="probability-tooltip-note">* Conditional effects depend on other traits being active at spawn time</div>`;
            }

            probabilityTooltipEl.innerHTML = html;

            // Position tooltip
            const rect = event.target.getBoundingClientRect();
            const tooltipRect = probabilityTooltipEl.getBoundingClientRect();

            let left = rect.right + 10;
            let top = rect.top;

            // Keep on screen
            if (left + 320 > window.innerWidth) {
                left = rect.left - 320 - 10;
            }
            if (top + tooltipRect.height > window.innerHeight) {
                top = window.innerHeight - tooltipRect.height - 10;
            }

            probabilityTooltipEl.style.left = left + 'px';
            probabilityTooltipEl.style.top = top + 'px';
            probabilityTooltipEl.classList.add('visible');
        }

        function hideProbabilityTooltip() {
            if (probabilityTooltipEl) {
                probabilityTooltipEl.classList.remove('visible');
            }
        }

        // Preview interactivity functions
        function updatePreviewAttribute(entityIndex, attrId, newValue) {
            const entity = previewEntities[entityIndex];
            if (!entity || !entity.attributes[attrId]) return;

            entity.attributes[attrId].value = newValue;
            recalculatePreviewEntity(entity);
            renderPreviewEntities();
        }

        function updatePreviewVariable(entityIndex, varId, newValue) {
            const entity = previewEntities[entityIndex];
            if (!entity || !entity.variables[varId]) return;

            entity.variables[varId].value = newValue;
            recalculatePreviewEntity(entity);
            renderPreviewEntities();
        }

        function togglePreviewTrait(entityIndex, traitIndex) {
            const entity = previewEntities[entityIndex];
            if (!entity || !entity.traits[traitIndex]) return;

            const trait = entity.traits[traitIndex];
            trait.active = trait.active === false ? true : false;

            recalculatePreviewEntity(entity);
            renderPreviewEntities();
        }

        // Add trait menu state
        let addTraitMenuVisible = false;
        let addTraitTargetEntity = null;

        function showAddTraitMenu(event, entityIndex) {
            event.stopPropagation();

            // Close any existing menu
            closeAddTraitMenu();

            const entity = previewEntities[entityIndex];
            if (!entity) return;

            addTraitTargetEntity = entityIndex;
            addTraitMenuVisible = true;

            // Get all traits grouped by layer
            const layers = config.nodes.filter(n => n.type === 'layer');
            const allTraits = config.nodes.filter(n =>
                (n.type === 'item' || n.type === 'trait') &&
                n.config?.selection?.mode !== 'threshold' // Don't show threshold traits
            );

            // Check eligibility and active status for each trait
            const traitsByLayer = {};
            layers.forEach(layer => {
                const layerTraits = allTraits.filter(t => t.config?.layerId === layer.id);
                if (layerTraits.length === 0) return;

                traitsByLayer[layer.id] = {
                    name: layer.name,
                    traits: layerTraits.map(trait => {
                        const isActive = entity.traits.some(t => t.id === trait.id && t.active !== false);
                        const eligibility = checkTraitEligibility(entity, trait);
                        return {
                            id: trait.id,
                            name: trait.name,
                            isActive,
                            eligible: eligibility.eligible,
                            reason: eligibility.reason
                        };
                    })
                };
            });

            // Create menu HTML
            const menuHtml = `
                <div class="add-trait-menu" id="addTraitMenu">
                    <div class="add-trait-menu-header">Add Trait</div>
                    ${Object.values(traitsByLayer).map(layer => `
                        <div class="add-trait-layer-group">
                            <div class="add-trait-layer-title">${layer.name}</div>
                            ${layer.traits.map(trait => `
                                <div class="add-trait-item ${trait.isActive ? 'already-active' : ''} ${!trait.eligible ? 'disabled' : ''}"
                                     onclick="${trait.eligible && !trait.isActive ? `addTraitToEntity(${entityIndex}, '${trait.id}')` : ''}">
                                    <span>${trait.isActive ? 'â—' : 'â—‹'}</span>
                                    <span>${trait.name}</span>
                                    <span class="trait-status">
                                        ${trait.isActive ? 'active' : (trait.eligible ? '' : trait.reason)}
                                    </span>
                                </div>
                            `).join('')}
                        </div>
                    `).join('')}
                </div>
            `;

            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', menuHtml);

            // Position menu near the button
            const menu = document.getElementById('addTraitMenu');
            const rect = event.target.getBoundingClientRect();
            menu.style.left = Math.min(rect.left, window.innerWidth - menu.offsetWidth - 10) + 'px';
            menu.style.top = Math.min(rect.bottom + 5, window.innerHeight - menu.offsetHeight - 10) + 'px';

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', closeAddTraitMenu);
            }, 0);
        }

        function closeAddTraitMenu() {
            const menu = document.getElementById('addTraitMenu');
            if (menu) menu.remove();
            addTraitMenuVisible = false;
            addTraitTargetEntity = null;
            document.removeEventListener('click', closeAddTraitMenu);
        }

        function checkTraitEligibility(entity, traitNode) {
            // Check eligibility gates
            const blockingRels = config.relationships.filter(r =>
                r.type === 'eligibility_gate' && r.targetId === traitNode.id
            );

            for (const rel of blockingRels) {
                const sourceAttr = entity.attributes[rel.sourceId];
                const sourceTrait = entity.traits.find(t => t.id === rel.sourceId && t.active !== false);

                if (sourceAttr || sourceTrait) {
                    const sourceName = sourceAttr?.name || sourceTrait?.name || rel.sourceId;
                    return { eligible: false, reason: `blocked by ${sourceName}` };
                }
            }

            // Check 'requires' relationships
            const requiresRels = config.relationships.filter(r =>
                r.type === 'requires' && r.sourceId === traitNode.id
            );

            for (const rel of requiresRels) {
                const requiredAttr = entity.attributes[rel.targetId];
                const requiredTrait = entity.traits.find(t => t.id === rel.targetId && t.active !== false);
                const requiredNode = config.nodes.find(n => n.id === rel.targetId);

                if (!requiredAttr && !requiredTrait) {
                    const reqName = requiredNode?.name || rel.targetId;
                    return { eligible: false, reason: `needs ${reqName}` };
                }
            }

            // Check 'replaces' relationships (can't add if replacement target is active)
            const replacesRels = config.relationships.filter(r =>
                r.type === 'replaces' && r.sourceId === traitNode.id
            );

            for (const rel of replacesRels) {
                const targetTrait = entity.traits.find(t => t.id === rel.targetId && t.active !== false);
                if (targetTrait) {
                    // Actually this is ok - adding this trait will replace the other
                }
            }

            return { eligible: true, reason: '' };
        }

        function addTraitToEntity(entityIndex, traitId) {
            closeAddTraitMenu();

            const entity = previewEntities[entityIndex];
            if (!entity) return;

            const traitNode = config.nodes.find(n => n.id === traitId);
            if (!traitNode) return;

            const layer = config.nodes.find(n => n.id === traitNode.config?.layerId);

            // Check if already exists
            if (entity.traits.some(t => t.id === traitId)) return;

            // Add the trait
            entity.traits.push({
                id: traitNode.id,
                name: traitNode.name,
                layer: layer?.name || 'Unknown',
                layerId: layer?.id,
                active: true,
                manuallyAdded: true
            });

            // Handle 'replaces' relationships
            const replacesRels = config.relationships.filter(r =>
                r.type === 'replaces' && r.sourceId === traitId
            );
            replacesRels.forEach(rel => {
                const idx = entity.traits.findIndex(t => t.id === rel.targetId);
                if (idx >= 0) {
                    entity.traits.splice(idx, 1);
                }
            });

            recalculatePreviewEntity(entity);
            renderPreviewEntities();
        }

        function recalculatePreviewEntity(entity) {
            // Recalculate derived values based on current attributes/variables
            const derived = config.nodes.filter(n => n.type === 'derived');
            derived.forEach(d => {
                if (d.config?.formula) {
                    try {
                        // Create evaluation context
                        const context = {};
                        Object.entries(entity.attributes).forEach(([id, attr]) => {
                            context[id] = attr.value;
                        });
                        Object.entries(entity.variables).forEach(([id, variable]) => {
                            if (!variable.derived) context[id] = variable.value;
                        });

                        // Build breakdown string showing substituted values
                        const substitutions = [];
                        let formula = d.config.formula;
                        Object.entries(context).forEach(([key, value]) => {
                            if (formula.includes(key)) {
                                substitutions.push(`${key}=${value}`);
                            }
                            formula = formula.replace(new RegExp(key, 'g'), value);
                        });

                        const result = eval(formula);
                        const min = d.config.min ?? -Infinity;
                        const max = d.config.max ?? Infinity;
                        entity.variables[d.id] = {
                            name: d.name,
                            value: Math.min(max, Math.max(min, result)),
                            derived: true,
                            formula: d.config.formula,
                            breakdown: substitutions.length > 0 ? substitutions.join(', ') : null
                        };
                    } catch (e) {
                        console.warn('Failed to evaluate formula for', d.name, e);
                    }
                }
            });

            // Evaluate threshold traits based on current variable values
            evaluateThresholdTraits(entity);

            // Recalculate compounds based on active traits AND modifiers
            entity.compounds = [];
            const compounds = config.nodes.filter(n => n.type === 'compound');
            compounds.forEach(compound => {
                const requires = compound.config?.requires || [];
                const logic = compound.config?.requirementLogic || 'all';

                const activeTraits = entity.traits.filter(t => t.active !== false);
                const activeModifiers = entity.modifiers || [];

                const checkRequirement = (req) => {
                    const reqId = getRequiredNodeId(req);
                    // Check if it's a trait/item
                    if (activeTraits.some(t => t.id === reqId)) return true;
                    // Check if it's a modifier
                    if (activeModifiers.some(m => (m.id || m) === reqId)) return true;
                    return false;
                };

                const meetsRequirements = logic === 'any'
                    ? requires.some(checkRequirement)
                    : requires.every(checkRequirement);

                if (meetsRequirements && requires.length > 0) {
                    entity.compounds.push({
                        id: compound.id,
                        name: compound.name,
                        requires: requires.map(req => {
                            const nodeId = getRequiredNodeId(req);
                            const node = config.nodes.find(n => n.id === nodeId);
                            return node?.name || nodeId;
                        })
                    });
                }
            });
        }

        // Helper function to check threshold condition
        function checkThresholdCondition(value, operator, threshold) {
            switch (operator) {
                case '<=': return value <= threshold;
                case '>=': return value >= threshold;
                case '<': return value < threshold;
                case '>': return value > threshold;
                case '==': case '=': return value === threshold;
                case '!=': return value !== threshold;
                default: return value <= threshold; // Default to <= for backwards compatibility
            }
        }

        // Helper function to check multi-condition modifier trigger
        function checkModifierTriggerConditions(trigger, entityOrVariableGetter) {
            // Support both single condition (backwards compat) and multi-condition format
            if (trigger.conditions && trigger.conditions.length > 0) {
                // Multi-condition format
                const logic = trigger.logic || 'all';
                const results = trigger.conditions.map(cond => {
                    const getVar = typeof entityOrVariableGetter === 'function'
                        ? entityOrVariableGetter
                        : (id) => entityOrVariableGetter.variables?.[id];

                    const variable = getVar(cond.target);
                    if (!variable) return false;

                    const value = typeof variable === 'object' ? variable.value : variable;
                    return checkThresholdCondition(value, cond.operator || '<=', cond.value ?? 0);
                });

                return logic === 'all'
                    ? results.every(r => r)
                    : results.some(r => r);
            } else {
                // Single condition (backwards compatibility)
                const getVar = typeof entityOrVariableGetter === 'function'
                    ? entityOrVariableGetter
                    : (id) => entityOrVariableGetter.variables?.[id];

                const variable = getVar(trigger.target);
                if (!variable) return false;

                const value = typeof variable === 'object' ? variable.value : variable;
                return checkThresholdCondition(value, trigger.operator || '<=', trigger.value ?? 0);
            }
        }

        // Evaluate and update threshold traits AND modifiers based on current variable values
        function evaluateThresholdTraits(entity) {
            // Initialize modifiers array if not present
            if (!entity.modifiers) entity.modifiers = [];

            // 1. Find all threshold-mode TRAITS
            const thresholdTraits = config.nodes.filter(n =>
                (n.type === 'item' || n.type === 'trait') &&
                n.config?.selection?.mode === 'threshold'
            );

            thresholdTraits.forEach(traitNode => {
                const trigger = traitNode.config?.selection?.trigger;
                if (!trigger || !trigger.target) return;

                const variable = entity.variables[trigger.target];
                if (!variable) return;

                const layer = config.nodes.find(n => n.id === traitNode.config?.layerId);
                const meetsCondition = checkThresholdCondition(
                    variable.value,
                    trigger.operator || '<=',
                    trigger.value ?? 0
                );

                // Check auto-remove condition if trait is currently active
                const autoRemove = traitNode.config?.selection?.autoRemove;
                let shouldRemove = false;
                if (autoRemove && autoRemove.target) {
                    const removeVar = entity.variables[autoRemove.target];
                    if (removeVar) {
                        shouldRemove = checkThresholdCondition(
                            removeVar.value,
                            autoRemove.operator || '>',
                            autoRemove.value ?? 0
                        );
                    }
                }

                // Find existing trait in entity
                const existingIdx = entity.traits.findIndex(t => t.id === traitNode.id);
                const existing = existingIdx >= 0 ? entity.traits[existingIdx] : null;

                if (meetsCondition && !shouldRemove) {
                    // Should be active
                    if (!existing) {
                        // Add the trait
                        entity.traits.push({
                            id: traitNode.id,
                            name: traitNode.name,
                            layer: layer?.name || 'Unknown',
                            threshold: true,
                            active: true,
                            trigger: `${variable.name} ${trigger.operator} ${trigger.value}`
                        });
                    } else if (existing.active === false) {
                        // Reactivate if manually deactivated but condition still met
                        // (Keep deactivated to allow manual override)
                    }
                } else {
                    // Should be inactive
                    if (existing && existing.threshold) {
                        // Remove threshold trait when condition no longer met
                        entity.traits.splice(existingIdx, 1);
                    }
                }
            });

            // 2. Find all threshold-mode MODIFIERS
            const thresholdModifiers = config.nodes.filter(n =>
                n.type === 'modifier' &&
                (n.config?.triggerType === 'threshold' || n.config?.trigger?.type === 'threshold')
            );

            thresholdModifiers.forEach(modNode => {
                const trigger = modNode.config?.trigger;
                if (!trigger) return;

                // Check for valid trigger (either multi-condition or single condition)
                const hasConditions = trigger.conditions && trigger.conditions.length > 0;
                const hasSingleTarget = trigger.target;
                if (!hasConditions && !hasSingleTarget) return;

                // Use the multi-condition helper
                const meetsCondition = checkModifierTriggerConditions(trigger, entity);

                // Check auto-remove condition
                const autoRemove = modNode.config?.autoRemove;
                let shouldRemove = false;
                if (autoRemove && autoRemove.target) {
                    const removeVar = entity.variables[autoRemove.target];
                    if (removeVar) {
                        shouldRemove = checkThresholdCondition(
                            removeVar.value,
                            autoRemove.operator || '>',
                            autoRemove.value ?? 0
                        );
                    }
                }

                // Find existing modifier
                const existingIdx = entity.modifiers.findIndex(m => (m.id || m) === modNode.id);
                const existing = existingIdx >= 0 ? entity.modifiers[existingIdx] : null;

                // Build trigger description
                let triggerDesc = '';
                if (hasConditions) {
                    const logic = trigger.logic || 'all';
                    triggerDesc = trigger.conditions.map(c => {
                        const v = config.nodes.find(n => n.id === c.target);
                        return `${v?.name || c.target} ${c.operator} ${c.value}`;
                    }).join(logic === 'all' ? ' AND ' : ' OR ');
                } else {
                    const v = config.nodes.find(n => n.id === trigger.target);
                    triggerDesc = `${v?.name || trigger.target} ${trigger.operator} ${trigger.value}`;
                }

                if (meetsCondition && !shouldRemove) {
                    if (!existing) {
                        entity.modifiers.push({
                            id: modNode.id,
                            name: modNode.name,
                            threshold: true,
                            trigger: triggerDesc
                        });
                    }
                } else {
                    if (existing) {
                        entity.modifiers.splice(existingIdx, 1);
                    }
                }
            });
        }

        function renderPreviewEntities() {
            const container = document.getElementById('previewEntities');
            if (!container) return;
            container.innerHTML = previewEntities.slice().reverse().map((entity, index) =>
                renderPreviewEntity(entity, index)
            ).join('');
        }

        function renderFlowView(container) {
            // Linear spawn flow visualization
            container.innerHTML = `
                <div class="tree-view">
                    <div class="tree-view-section">
                        <div class="tree-view-section-title">
                            Spawn Flow (left to right)
                        </div>
                        <div style="display: flex; align-items: flex-start; gap: 2rem; overflow-x: auto; padding: 1rem;">
                            ${renderFlowStage('Contexts', 'context')}
                            <div style="color: var(--text-muted); font-size: 1.5rem;">â†’</div>
                            ${renderFlowStage('Attributes', 'attribute')}
                            <div style="color: var(--text-muted); font-size: 1.5rem;">â†’</div>
                            ${renderFlowStage('Layers', 'layer')}
                            <div style="color: var(--text-muted); font-size: 1.5rem;">â†’</div>
                            ${renderFlowStage('Variables', 'variable')}
                            <div style="color: var(--text-muted); font-size: 1.5rem;">â†’</div>
                            ${renderFlowStage('Output', 'derived')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderFlowStage(label, type) {
            const nodes = config.nodes.filter(n => n.type === type);
            return `
                <div style="min-width: 120px;">
                    <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">${label}</div>
                    ${nodes.length > 0 ? nodes.map(node => `
                        <div class="tree-view-node ${selectedNodeId === node.id ? 'selected' : ''}"
                             onclick="selectNode('${node.id}')"
                             style="margin-bottom: 0.3rem;">
                            <span class="dot ${type}"></span>
                            ${node.name}
                        </div>
                    `).join('') : '<div style="color: var(--text-muted); font-size: 0.8rem;">None</div>'}
                </div>
            `;
        }

        // ========================================
        // ENTITY MANAGER
        // ========================================

        // Entity Manager State
        let managedEntities = {
            active: [],      // Currently "in play"
            stored: [],      // Inactive pool
            starred: []      // Pinned/permanent
        };
        let selectedEntityId = null;
        let autoTickEnabled = false;
        let persistenceSection = 'presets';  // 'presets' | 'pools' | 'saved'

        // Pool Management State
        let selectedPoolFilter = 'all';  // 'all' or pool ID
        let poolConfigs = new Map();     // Pool configurations from config.pools

        // Initialize pools from config
        function initPoolsFromConfig() {
            poolConfigs.clear();

            // Always have a default pool
            poolConfigs.set('default', {
                id: 'default',
                name: 'Default Pool',
                description: 'Default entity pool',
                config: {
                    maxSize: 100,
                    preWarm: 0,
                    preWarmPreset: null,
                    shrinkThreshold: 0.5,
                    shrinkDelay: 30000
                },
                rules: null
            });

            // Load pools from config if present
            if (config.pools && Array.isArray(config.pools)) {
                for (const poolData of config.pools) {
                    poolConfigs.set(poolData.id, {
                        id: poolData.id,
                        name: poolData.name || poolData.id,
                        description: poolData.description || '',
                        config: poolData.config || {},
                        rules: poolData.rules || null
                    });
                }
            }
        }

        // Save pools to config
        function savePoolsToConfig() {
            config.pools = Array.from(poolConfigs.values()).map(pool => ({
                id: pool.id,
                name: pool.name,
                description: pool.description,
                config: pool.config,
                rules: pool.rules
            }));
            saveToStorage();
        }

        // Get pool statistics
        function getPoolStats(poolId) {
            const entities = getEntitiesForPool(poolId);
            return {
                total: entities.active.length + entities.stored.length + entities.starred.length,
                active: entities.active.length,
                stored: entities.stored.length,
                starred: entities.starred.length
            };
        }

        // Get entities filtered by pool
        function getEntitiesForPool(poolId) {
            const currentConfigId = config.id;
            const filterByPool = (e) => {
                if (e.configId !== currentConfigId) return false;
                if (poolId === 'all') return true;
                return (e.poolId || 'default') === poolId;
            };

            return {
                active: managedEntities.active.filter(filterByPool),
                stored: managedEntities.stored.filter(filterByPool),
                starred: managedEntities.starred.filter(filterByPool)
            };
        }

        // Update getEntitiesForCurrentConfig to use pool filter
        function getEntitiesForCurrentConfig() {
            if (selectedPoolFilter === 'all') {
                const currentConfigId = config.id;
                return {
                    active: managedEntities.active.filter(e => e.configId === currentConfigId),
                    stored: managedEntities.stored.filter(e => e.configId === currentConfigId),
                    starred: managedEntities.starred.filter(e => e.configId === currentConfigId)
                };
            }
            return getEntitiesForPool(selectedPoolFilter);
        }

        // Change pool filter
        function setPoolFilter(poolId) {
            selectedPoolFilter = poolId;
            // Re-render is handled by caller (persistence saved section has its own onchange)
        }

        // Move entity to pool
        function moveEntityToPool(entityId, targetPoolId) {
            const entity = findEntityById(entityId);
            if (entity) {
                entity.poolId = targetPoolId;
                saveEntitiesToStorage();
                renderEntitiesView(document.getElementById('viewContent'));
                showToast(`Moved to ${poolConfigs.get(targetPoolId)?.name || targetPoolId}`);
            }
        }

        // Handle pool assignment dropdown change (including "Add New Pool" option)
        function handlePoolAssignmentChange(entityId, value, selectEl) {
            if (value === '__new__') {
                // Reset dropdown to current pool before opening modal
                const entity = findEntityById(entityId);
                selectEl.value = entity?.poolId || 'default';
                // Open pool management modal
                showPoolManagementModal();
            } else {
                moveEntityToPool(entityId, value);
            }
        }

        // Create a new pool
        function createNewPool() {
            const id = `pool_${Date.now()}`;
            const name = `Pool ${poolConfigs.size}`;

            poolConfigs.set(id, {
                id,
                name,
                description: '',
                config: {
                    maxSize: 100,
                    preWarm: 0,
                    preWarmPreset: null,
                    shrinkThreshold: 0.5,
                    shrinkDelay: 30000
                },
                rules: null
            });

            savePoolsToConfig();
            // Re-render based on context
            if (currentView === 'persistence') {
                // Caller handles re-render
            } else {
                renderPoolManagementModal();
                if (currentView === 'entities') {
                    renderEntitiesView(document.getElementById('viewContent'));
                }
            }
            showToast('Pool created');
        }

        // Update pool config
        function updatePoolConfig(poolId, field, value) {
            const pool = poolConfigs.get(poolId);
            if (!pool) return;

            if (field === 'name') {
                pool.name = value;
            } else if (field === 'description') {
                pool.description = value;
            } else if (field in pool.config) {
                pool.config[field] = value;
            }

            savePoolsToConfig();
        }

        // Delete a pool
        function deletePool(poolId) {
            if (poolId === 'default') {
                showToast('Cannot delete default pool', 'error');
                return;
            }

            // Move entities to default pool
            [...managedEntities.active, ...managedEntities.stored, ...managedEntities.starred]
                .filter(e => e.poolId === poolId)
                .forEach(e => { e.poolId = 'default'; });

            poolConfigs.delete(poolId);

            if (selectedPoolFilter === poolId) {
                selectedPoolFilter = 'all';
            }

            savePoolsToConfig();
            saveEntitiesToStorage();
            // Re-render based on context
            if (currentView === 'persistence') {
                renderPersistenceView(document.getElementById('viewContent'));
            } else {
                renderPoolManagementModal();
                if (currentView === 'entities') {
                    renderEntitiesView(document.getElementById('viewContent'));
                }
            }
            showToast('Pool deleted');
        }

        // Show pool management modal
        function showPoolManagementModal() {
            let modal = document.getElementById('poolManagementModal');
            if (!modal) {
                // Create modal if it doesn't exist
                modal = document.createElement('div');
                modal.id = 'poolManagementModal';
                modal.className = 'modal-overlay';
                document.body.appendChild(modal);
            }
            renderPoolManagementModal();
            modal.classList.add('active');
        }

        function closePoolManagementModal() {
            const modal = document.getElementById('poolManagementModal');
            if (modal) modal.classList.remove('active');
            // Refresh view to update pool assignment dropdowns
            if (currentView === 'persistence') {
                renderPersistenceView(document.getElementById('viewContent'));
            } else if (currentView === 'entities') {
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function renderPoolManagementModal() {
            const modal = document.getElementById('poolManagementModal');
            if (!modal) return;

            const pools = Array.from(poolConfigs.values());
            const presets = config.nodes.filter(n => n.type === 'preset' || (n.type === 'layer' && n.config?.presetGroup));

            modal.innerHTML = `
                <div class="modal" style="width: 700px; max-width: 90vw;">
                    <div class="modal-header">
                        <span class="modal-title">Pool Management</span>
                        <button class="btn btn-icon" onclick="closePoolManagementModal()">âœ•</button>
                    </div>
                    <div class="modal-body pool-modal-content">
                        <div class="pool-list">
                            ${pools.map(pool => renderPoolCard(pool)).join('')}
                            <div class="add-pool-card" onclick="createNewPool()">
                                <span>+ Create New Pool</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderPoolCard(pool) {
            const isDefault = pool.id === 'default';
            const stats = getPoolStats(pool.id);
            const rulesMode = pool._rulesMode || 'simple';

            return `
                <div class="pool-card ${isDefault ? 'default' : ''}">
                    <div class="pool-card-header">
                        <span class="pool-icon">â—ˆ</span>
                        <input type="text" class="pool-name-input" value="${pool.name}"
                               onchange="updatePoolConfig('${pool.id}', 'name', this.value)"
                               ${isDefault ? 'readonly' : ''}>
                        <span class="pool-id-badge">${pool.id}</span>
                        ${!isDefault ? `
                            <button class="btn btn-sm btn-danger" onclick="deletePool('${pool.id}')">Delete</button>
                        ` : ''}
                    </div>
                    <div class="pool-card-body">
                        <div class="pool-config-grid">
                            <div class="pool-config-field">
                                <label>Max Size</label>
                                <input type="number" value="${pool.config.maxSize || 100}" min="1"
                                       onchange="updatePoolConfig('${pool.id}', 'maxSize', parseInt(this.value))">
                            </div>
                            <div class="pool-config-field">
                                <label>Pre-warm Count</label>
                                <input type="number" value="${pool.config.preWarm || 0}" min="0"
                                       onchange="updatePoolConfig('${pool.id}', 'preWarm', parseInt(this.value))">
                            </div>
                            <div class="pool-config-field">
                                <label>Shrink Threshold</label>
                                <input type="number" value="${pool.config.shrinkThreshold || 0.5}" min="0" max="1" step="0.1"
                                       onchange="updatePoolConfig('${pool.id}', 'shrinkThreshold', parseFloat(this.value))">
                            </div>
                            <div class="pool-config-field">
                                <label>Shrink Delay (ms)</label>
                                <input type="number" value="${pool.config.shrinkDelay || 30000}" min="0" step="1000"
                                       onchange="updatePoolConfig('${pool.id}', 'shrinkDelay', parseInt(this.value))">
                            </div>
                        </div>
                        ${!isDefault ? renderPoolRulesSection(pool) : ''}
                    </div>
                    <div class="pool-card-stats">
                        <div class="stat"><span class="stat-label">Total:</span> <span class="stat-value">${stats.total}</span></div>
                        <div class="stat"><span class="stat-label">Active:</span> <span class="stat-value">${stats.active}</span></div>
                        <div class="stat"><span class="stat-label">Stored:</span> <span class="stat-value">${stats.stored}</span></div>
                    </div>
                </div>
            `;
        }

        function renderPoolRulesSection(pool) {
            const rulesMode = pool._rulesMode || 'simple';
            const rules = pool.rules || { conditions: [] };
            const conditions = rules.conditions || [];

            // Simple mode: just preset pattern
            const presetCondition = conditions.find(c => c.source === 'preset');
            const simplePattern = presetCondition?.match || '';

            return `
                <div class="pool-rules-section">
                    <div class="pool-rules-header">
                        <span>Assignment Rules</span>
                        <div class="pool-rules-toggle">
                            <button class="btn btn-sm ${rulesMode === 'simple' ? 'active' : ''}"
                                    onclick="setPoolRulesMode('${pool.id}', 'simple')">Simple</button>
                            <button class="btn btn-sm ${rulesMode === 'advanced' ? 'active' : ''}"
                                    onclick="setPoolRulesMode('${pool.id}', 'advanced')">Advanced</button>
                        </div>
                    </div>
                    ${rulesMode === 'simple' ? `
                        <div class="pool-config-field" style="margin-top: 0.5rem;">
                            <label>Match Preset Pattern (use * as wildcard)</label>
                            <input type="text" placeholder="e.g., enemy_* or npc_tavern_*"
                                   value="${simplePattern}"
                                   onchange="setSimplePoolRule('${pool.id}', this.value)">
                        </div>
                    ` : `
                        <div class="pool-rules-advanced" style="margin-top: 0.5rem;">
                            ${conditions.map((cond, idx) => renderPoolRuleRow(pool.id, cond, idx)).join('')}
                            <button class="btn btn-sm" onclick="addPoolRule('${pool.id}')">+ Add Rule</button>
                        </div>
                    `}
                </div>
            `;
        }

        function renderPoolRuleRow(poolId, condition, index) {
            return `
                <div class="pool-rule-row">
                    <select onchange="updatePoolRule('${poolId}', ${index}, 'source', this.value)">
                        <option value="preset" ${condition.source === 'preset' ? 'selected' : ''}>Preset matches</option>
                        <option value="trait" ${condition.source === 'trait' ? 'selected' : ''}>Has trait</option>
                        <option value="attribute" ${condition.source === 'attribute' ? 'selected' : ''}>Attribute</option>
                        <option value="modifier" ${condition.source === 'modifier' ? 'selected' : ''}>Has modifier</option>
                    </select>
                    <input type="text" placeholder="pattern or ID" value="${condition.match || ''}"
                           onchange="updatePoolRule('${poolId}', ${index}, 'match', this.value)">
                    ${condition.source === 'attribute' ? `
                        <select onchange="updatePoolRule('${poolId}', ${index}, 'operator', this.value)">
                            <option value="gt" ${condition.operator === 'gt' ? 'selected' : ''}>&gt;</option>
                            <option value="gte" ${condition.operator === 'gte' ? 'selected' : ''}>&gt;=</option>
                            <option value="lt" ${condition.operator === 'lt' ? 'selected' : ''}>&lt;</option>
                            <option value="lte" ${condition.operator === 'lte' ? 'selected' : ''}>&lt;=</option>
                            <option value="eq" ${condition.operator === 'eq' ? 'selected' : ''}>=</option>
                        </select>
                        <input type="number" placeholder="value" value="${condition.value || ''}" style="width: 60px;"
                               onchange="updatePoolRule('${poolId}', ${index}, 'value', parseFloat(this.value))">
                    ` : ''}
                    <button class="pool-rule-delete" onclick="removePoolRule('${poolId}', ${index})">âœ•</button>
                </div>
            `;
        }

        function setPoolRulesMode(poolId, mode) {
            const pool = poolConfigs.get(poolId);
            if (pool) {
                pool._rulesMode = mode;
                renderPoolManagementModal();
            }
        }

        function setSimplePoolRule(poolId, pattern) {
            const pool = poolConfigs.get(poolId);
            if (!pool) return;

            if (pattern.trim()) {
                pool.rules = {
                    conditions: [{ source: 'preset', match: pattern.trim() }]
                };
            } else {
                pool.rules = null;
            }
            savePoolsToConfig();
        }

        function addPoolRule(poolId) {
            const pool = poolConfigs.get(poolId);
            if (!pool) return;

            if (!pool.rules) pool.rules = { conditions: [] };
            pool.rules.conditions.push({ source: 'preset', match: '' });
            savePoolsToConfig();
            renderPoolManagementModal();
        }

        function updatePoolRule(poolId, index, field, value) {
            const pool = poolConfigs.get(poolId);
            if (!pool?.rules?.conditions?.[index]) return;

            pool.rules.conditions[index][field] = value;
            savePoolsToConfig();

            // Re-render if source changed (to show/hide operator fields)
            if (field === 'source') {
                renderPoolManagementModal();
            }
        }

        function removePoolRule(poolId, index) {
            const pool = poolConfigs.get(poolId);
            if (!pool?.rules?.conditions) return;

            pool.rules.conditions.splice(index, 1);
            if (pool.rules.conditions.length === 0) {
                pool.rules = null;
            }
            savePoolsToConfig();
            renderPoolManagementModal();
        }

        // Determine which pool an entity should be assigned to based on rules
        function determineEntityPool(entity) {
            // Check each pool's rules (except default)
            for (const [poolId, pool] of poolConfigs) {
                if (poolId === 'default' || !pool.rules?.conditions) continue;

                const conditions = pool.rules.conditions;
                let matches = false;

                for (const cond of conditions) {
                    if (evaluatePoolCondition(entity, cond)) {
                        matches = true;
                        break; // Any match = pool match
                    }
                }

                if (matches) return poolId;
            }

            return 'default';
        }

        // Evaluate a pool assignment condition against an entity
        function evaluatePoolCondition(entity, condition) {
            const { source, match, operator, value } = condition;
            if (!match) return false;

            switch (source) {
                case 'preset':
                    // Match preset pattern (glob-style with *)
                    const presetId = entity.presetId || '';
                    if (!match.includes('*')) return presetId === match;
                    const regex = new RegExp('^' + match.replace(/\*/g, '.*') + '$');
                    return regex.test(presetId);

                case 'trait':
                    // Check if entity has trait active
                    return (entity.traits || []).some(t => t.id === match && t.active !== false);

                case 'attribute':
                    // Check attribute value
                    const attr = entity.attributes?.[match];
                    if (!attr) return false;
                    const attrValue = typeof attr === 'object' ? attr.value : attr;
                    return evaluateOperator(attrValue, operator || 'eq', value);

                case 'modifier':
                    // Check if modifier is active
                    return (entity.modifiers || []).some(m => (m.id || m) === match);

                default:
                    return false;
            }
        }

        // Evaluate comparison operators
        function evaluateOperator(val, op, target) {
            switch (op) {
                case 'eq': return val === target;
                case 'ne': return val !== target;
                case 'gt': return val > target;
                case 'gte': return val >= target;
                case 'lt': return val < target;
                case 'lte': return val <= target;
                default: return false;
            }
        }

        let autoTickInterval = null;
        let entityNameCounter = 1;
        const ENTITY_STORAGE_KEY = 'spawnEditor_entities';
        const ENTITY_SETTINGS_KEY = 'spawnEditor_entitySettings';

        // Entity Manager Settings
        let entitySettings = {
            maxStored: 50,
            maxStoredAge: 7 * 24 * 60 * 60 * 1000, // 7 days in ms
            defaultNamePattern: 'Entity #{n}',
            autoSave: true
        };

        // Load entities from localStorage on init
        function loadEntitiesFromStorage() {
            try {
                const stored = localStorage.getItem(ENTITY_STORAGE_KEY);
                if (stored) {
                    const data = JSON.parse(stored);
                    managedEntities = {
                        active: data.active || [],
                        stored: data.stored || [],
                        starred: data.starred || []
                    };
                    entityNameCounter = data.nameCounter || 1;
                }
                const settings = localStorage.getItem(ENTITY_SETTINGS_KEY);
                if (settings) {
                    entitySettings = { ...entitySettings, ...JSON.parse(settings) };
                }
            } catch (e) {
                console.warn('Failed to load entities from storage:', e);
            }
        }

        // Save entities to localStorage
        function saveEntitiesToStorage() {
            if (!entitySettings.autoSave) return;
            try {
                const data = {
                    active: managedEntities.active,
                    stored: managedEntities.stored,
                    starred: managedEntities.starred,
                    nameCounter: entityNameCounter,
                    savedAt: Date.now()
                };
                localStorage.setItem(ENTITY_STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.warn('Failed to save entities to storage:', e);
            }
        }

        // Prune old stored entities
        function pruneStoredEntities() {
            const now = Date.now();
            const maxAge = entitySettings.maxStoredAge;

            // Remove old entities
            managedEntities.stored = managedEntities.stored.filter(e => {
                const age = now - (e.storedAt || e.createdAt || 0);
                return age < maxAge;
            });

            // Enforce max count
            if (managedEntities.stored.length > entitySettings.maxStored) {
                managedEntities.stored = managedEntities.stored.slice(0, entitySettings.maxStored);
            }

            saveEntitiesToStorage();
        }

        // Generate entity name
        function generateEntityName() {
            const pattern = entitySettings.defaultNamePattern;
            const name = pattern.replace('{n}', entityNameCounter);
            entityNameCounter++;
            saveEntitiesToStorage();
            return name;
        }

        // Promote preview entity to Entity Manager
        function promotePreviewEntity(previewIndex) {
            const previewEntity = previewEntities[previewIndex];
            if (!previewEntity) return;

            // Convert preview format to managed format
            // Use the preview entity's name if it has one, otherwise generate
            const entity = {
                id: previewEntity.id,
                name: previewEntity.name || generateEntityName(),
                createdAt: Date.now(),
                promotedAt: Date.now(),
                configId: config.id,
                poolId: determineEntityPool(previewEntity),  // Assign to pool based on rules
                // Copy state
                attributes: { ...previewEntity.attributes },
                variables: { ...previewEntity.variables },
                traits: [...previewEntity.traits],
                modifiers: [...previewEntity.modifiers],
                compounds: [...previewEntity.compounds]
            };

            // Add to active entities
            managedEntities.active.unshift(entity);

            // Remove from preview
            previewEntities.splice(previewIndex, 1);

            saveEntitiesToStorage();

            // Re-render both views
            renderPreviewView(document.getElementById('viewContent'));

            // Show feedback
            showToast(`Promoted to Entities: ${entity.name}`);
        }

        // Discard preview entity
        function discardPreviewEntity(previewIndex) {
            previewEntities.splice(previewIndex, 1);
            renderPreviewView(document.getElementById('viewContent'));
        }

        // Rename preview entity
        function renamePreviewEntity(previewIndex, newName) {
            if (previewEntities[previewIndex] && newName.trim()) {
                previewEntities[previewIndex].name = newName.trim();
            }
        }

        // Entity status transitions
        function activateEntity(entityId) {
            let entity = managedEntities.stored.find(e => e.id === entityId);
            if (entity) {
                managedEntities.stored = managedEntities.stored.filter(e => e.id !== entityId);
                delete entity.storedAt;
                entity.activatedAt = Date.now();
                managedEntities.active.unshift(entity);
                saveEntitiesToStorage();
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function deactivateEntity(entityId) {
            let entity = managedEntities.active.find(e => e.id === entityId);
            if (entity) {
                managedEntities.active = managedEntities.active.filter(e => e.id !== entityId);
                entity.storedAt = Date.now();
                managedEntities.stored.unshift(entity);
                pruneStoredEntities();
                if (selectedEntityId === entityId) selectedEntityId = null;
                saveEntitiesToStorage();
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function starEntity(entityId) {
            // Find in active or stored
            let entity = managedEntities.active.find(e => e.id === entityId);
            let source = 'active';
            if (!entity) {
                entity = managedEntities.stored.find(e => e.id === entityId);
                source = 'stored';
            }
            if (!entity) return;

            // Remove from source
            if (source === 'active') {
                managedEntities.active = managedEntities.active.filter(e => e.id !== entityId);
            } else {
                managedEntities.stored = managedEntities.stored.filter(e => e.id !== entityId);
            }

            entity.starredAt = Date.now();
            managedEntities.starred.unshift(entity);
            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
        }

        function unstarEntity(entityId) {
            let entity = managedEntities.starred.find(e => e.id === entityId);
            if (!entity) return;

            managedEntities.starred = managedEntities.starred.filter(e => e.id !== entityId);
            delete entity.starredAt;
            entity.activatedAt = Date.now();
            managedEntities.active.unshift(entity);
            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
        }

        function deleteEntity(entityId) {
            managedEntities.active = managedEntities.active.filter(e => e.id !== entityId);
            managedEntities.stored = managedEntities.stored.filter(e => e.id !== entityId);
            managedEntities.starred = managedEntities.starred.filter(e => e.id !== entityId);
            if (selectedEntityId === entityId) selectedEntityId = null;
            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
        }

        function renameEntity(entityId, newName) {
            const entity = findEntityById(entityId);
            if (entity && newName.trim()) {
                entity.name = newName.trim();
                saveEntitiesToStorage();
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function updateManagedEntityAttribute(entityId, attrId, newValue) {
            const entity = findEntityById(entityId);
            if (entity && entity.attributes[attrId]) {
                const attr = entity.attributes[attrId];
                attr.value = Math.max(attr.min || 0, Math.min(attr.max || 100, newValue));
                recalculateManagedEntity(entity);
                saveEntitiesToStorage();
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function updateManagedEntityVariable(entityId, varId, newValue) {
            const entity = findEntityById(entityId);
            if (entity && entity.variables[varId]) {
                const v = entity.variables[varId];
                v.value = Math.max(v.min ?? 0, Math.min(v.max ?? 100, newValue));
                recalculateManagedEntity(entity);
                saveEntitiesToStorage();
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function toggleManagedEntityTrait(entityId, traitId) {
            const entity = findEntityById(entityId);
            if (!entity) return;

            const traitIdx = entity.traits.findIndex(t => t.id === traitId);
            if (traitIdx >= 0) {
                const trait = entity.traits[traitIdx];
                // Toggle active state
                if (trait.active === false) {
                    trait.active = true;
                } else {
                    trait.active = false;
                }
            } else {
                // Trait not on entity - add it
                const traitNode = config.nodes.find(n => n.id === traitId);
                if (traitNode) {
                    const layer = config.nodes.find(n => n.id === traitNode.config?.layerId);
                    entity.traits.push({
                        id: traitNode.id,
                        name: traitNode.name,
                        layer: layer?.name || '',
                        active: true
                    });
                }
            }

            recalculateEntityCompounds(entity);
            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
        }

        function findEntityById(entityId) {
            return managedEntities.active.find(e => e.id === entityId) ||
                   managedEntities.stored.find(e => e.id === entityId) ||
                   managedEntities.starred.find(e => e.id === entityId);
        }

        function getEntityStatus(entityId) {
            if (managedEntities.active.find(e => e.id === entityId)) return 'active';
            if (managedEntities.stored.find(e => e.id === entityId)) return 'stored';
            if (managedEntities.starred.find(e => e.id === entityId)) return 'starred';
            return null;
        }

        function getTotalEntityCount() {
            return managedEntities.active.length +
                   managedEntities.stored.length +
                   managedEntities.starred.length;
        }

        // Config-filtered entity getters (only show entities for current config)
        // Note: getEntitiesForCurrentConfig is now defined in Pool Management section with pool filtering support

        function getEntityCountForCurrentConfig() {
            const filtered = getEntitiesForCurrentConfig();
            return filtered.active.length + filtered.stored.length + filtered.starred.length;
        }

        function getActiveEntitiesForCurrentConfig() {
            return managedEntities.active.filter(e => e.configId === config.id);
        }

        // Auto-tick functionality
        function toggleAutoTick() {
            autoTickEnabled = !autoTickEnabled;
            if (autoTickEnabled) {
                startAutoTick();
            } else {
                stopAutoTick();
            }
            renderEntitiesView(document.getElementById('viewContent'));
        }

        function startAutoTick() {
            if (autoTickInterval) return;
            const tickRate = config.engineConfig?.tickRate || 1000;
            autoTickInterval = setInterval(() => {
                tickAllActiveEntities();
            }, tickRate);
        }

        function stopAutoTick() {
            if (autoTickInterval) {
                clearInterval(autoTickInterval);
                autoTickInterval = null;
            }
        }

        function tickAllActiveEntities() {
            const tickRate = (config.engineConfig?.tickRate || 1000) / 1000; // Convert to seconds
            // Only tick entities for the current config
            getActiveEntitiesForCurrentConfig().forEach(entity => {
                tickEntity(entity, tickRate);
            });
            if (currentView === 'entities') {
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function tickEntity(entity, deltaSeconds) {
            // Update variables based on their rates
            Object.entries(entity.variables).forEach(([varId, varState]) => {
                if (varState.rate && varState.rate !== 0) {
                    varState.value += varState.rate * deltaSeconds;
                    varState.value = Math.max(varState.min || 0, Math.min(varState.max || 100, varState.value));
                }
            });

            // Re-evaluate threshold traits
            recalculateManagedEntity(entity);
        }

        function recalculateManagedEntity(entity) {
            // Initialize modifiers array if not present
            if (!entity.modifiers) entity.modifiers = [];

            // 1. Evaluate threshold TRAITS (items with selection.mode = 'threshold')
            const thresholdTraits = config.nodes.filter(n =>
                (n.type === 'item' || n.type === 'trait') &&
                n.config?.selection?.mode === 'threshold'
            );

            thresholdTraits.forEach(traitNode => {
                const trigger = traitNode.config?.selection?.trigger;
                if (!trigger || !trigger.target) return;

                const varState = entity.variables[trigger.target];
                if (!varState) return;

                const varValue = varState.value;
                const layer = config.nodes.find(n => n.id === traitNode.config?.layerId);

                const shouldBeActive = checkThresholdCondition(
                    varValue,
                    trigger.operator || '<=',
                    trigger.value ?? 0
                );

                // Check auto-remove condition if trait is currently active
                const autoRemove = traitNode.config?.selection?.autoRemove;
                let shouldRemove = false;
                if (autoRemove && autoRemove.target) {
                    const removeVar = entity.variables[autoRemove.target];
                    if (removeVar) {
                        shouldRemove = checkThresholdCondition(
                            removeVar.value,
                            autoRemove.operator || '>',
                            autoRemove.value ?? 0
                        );
                    }
                }

                // Find existing trait
                const existingIdx = entity.traits.findIndex(t => t.id === traitNode.id);
                const existing = existingIdx >= 0 ? entity.traits[existingIdx] : null;

                if (shouldBeActive && !shouldRemove) {
                    if (!existing) {
                        entity.traits.push({
                            id: traitNode.id,
                            name: traitNode.name,
                            layer: layer?.name || 'Unknown',
                            active: true,
                            threshold: true,
                            trigger: `${varState.name} ${trigger.operator || '<='} ${trigger.value ?? 0}`
                        });
                    }
                } else {
                    if (existing && existing.threshold) {
                        entity.traits.splice(existingIdx, 1);
                    }
                }
            });

            // 2. Evaluate threshold MODIFIERS (modifiers with triggerType = 'threshold')
            const thresholdModifiers = config.nodes.filter(n =>
                n.type === 'modifier' &&
                n.config?.triggerType === 'threshold'
            );

            thresholdModifiers.forEach(modNode => {
                const trigger = modNode.config?.trigger;
                if (!trigger || !trigger.target) return;

                const varState = entity.variables[trigger.target];
                if (!varState) return;

                const shouldBeActive = checkThresholdCondition(
                    varState.value,
                    trigger.operator || '<=',
                    trigger.value ?? 0
                );

                // Check auto-remove condition
                const autoRemove = modNode.config?.autoRemove;
                let shouldRemove = false;
                if (autoRemove && autoRemove.target) {
                    const removeVar = entity.variables[autoRemove.target];
                    if (removeVar) {
                        shouldRemove = checkThresholdCondition(
                            removeVar.value,
                            autoRemove.operator || '>',
                            autoRemove.value ?? 0
                        );
                    }
                }

                // Find existing modifier
                const existingIdx = entity.modifiers.findIndex(m => (m.id || m) === modNode.id);
                const existing = existingIdx >= 0 ? entity.modifiers[existingIdx] : null;

                if (shouldBeActive && !shouldRemove) {
                    if (!existing) {
                        entity.modifiers.push({
                            id: modNode.id,
                            name: modNode.name,
                            threshold: true,
                            trigger: `${varState.name} ${trigger.operator || '<='} ${trigger.value ?? 0}`
                        });
                    }
                } else {
                    if (existing) {
                        entity.modifiers.splice(existingIdx, 1);
                    }
                }
            });

            // Re-evaluate compounds
            recalculateEntityCompounds(entity);
        }

        function recalculateEntityCompounds(entity) {
            const compounds = config.nodes.filter(n => n.type === 'compound');
            const activeTraitIds = new Set(entity.traits.filter(t => t.active !== false).map(t => t.id));
            const activeModifierIds = new Set(entity.modifiers.map(m => m.id || m));

            entity.compounds = [];

            compounds.forEach(compound => {
                const requires = compound.config.requires || [];
                const logic = compound.config.requirementLogic || 'all';

                if (requires.length === 0) return;

                const results = requires.map(req => {
                    if (req.item || req.trait) {
                        return activeTraitIds.has(req.item || req.trait);
                    }
                    if (req.modifier) {
                        return activeModifierIds.has(req.modifier);
                    }
                    return false;
                });

                const meetsRequirements = logic === 'all'
                    ? results.every(r => r)
                    : results.some(r => r);

                if (meetsRequirements) {
                    entity.compounds.push({
                        id: compound.id,
                        name: compound.name,
                        requires: requires.map(r => {
                            const id = r.item || r.trait || r.modifier;
                            const node = config.nodes.find(n => n.id === id);
                            return node?.name || id;
                        })
                    });
                }
            });
        }

        // showToast is now provided by js/utils.js

        // ========================================
        // PERSISTENCE TAB (v3.3 â€” replaces Entities tab)
        // ========================================

        function renderPersistenceView(container) {
            // Initialize pools if needed
            if (poolConfigs.size === 0) initPoolsFromConfig();

            const presets = config.presets || [];
            const pools = Array.from(poolConfigs.values());
            const filtered = getEntitiesForCurrentConfig();
            const savedCount = filtered.active.length + filtered.stored.length + filtered.starred.length;

            container.innerHTML = `
                <div class="persistence-view">
                    <div class="persistence-sections">
                        <button class="persistence-section-tab ${persistenceSection === 'presets' ? 'active' : ''}"
                                onclick="switchPersistenceSection('presets')"
                                title="Entity templates with trait and attribute overrides">
                            Presets <span class="tab-badge-sm">${presets.length}</span>
                        </button>
                        <button class="persistence-section-tab ${persistenceSection === 'pools' ? 'active' : ''}"
                                onclick="switchPersistenceSection('pools')"
                                title="Runtime containers â€” capacity, pre-warming, lifecycle rules">
                            Pools <span class="tab-badge-sm">${pools.length}</span>
                        </button>
                        <button class="persistence-section-tab ${persistenceSection === 'saved' ? 'active' : ''}"
                                onclick="switchPersistenceSection('saved')"
                                title="Spawned entity instances with live state">
                            Entities <span class="tab-badge-sm">${savedCount}</span>
                        </button>
                    </div>
                    <div class="persistence-section-hint">
                        ${persistenceSection === 'presets' ? 'Define spawn templates â€” forced traits, attribute &amp; variable overrides'
                        : persistenceSection === 'pools' ? 'Configure entity containers â€” capacity limits, pre-warming, lifecycle'
                        : 'Spawned instances â€” manage active, stored &amp; starred entities'}
                    </div>
                    <div class="persistence-content">
                        ${persistenceSection === 'presets' ? renderPersistencePresetsSection()
                        : persistenceSection === 'pools' ? renderPersistencePoolsSection()
                        : renderPersistenceSavedSection()}
                    </div>
                </div>
            `;
        }

        function switchPersistenceSection(section) {
            persistenceSection = section;
            renderPersistenceView(document.getElementById('viewContent'));
        }

        // ----------------------------------------
        // Persistence: Presets Section
        // ----------------------------------------

        function renderPersistencePresetsSection() {
            const groups = config.presetGroups || [];
            const presets = config.presets || [];
            const ungroupedPresets = presets.filter(p => !p.group);

            // Hierarchical filtering: if a parent group is selected, show its presets AND all descendants
            let filtered = presets;
            if (selectedPresetGroupId === '__ungrouped') {
                filtered = presets.filter(p => !p.group);
            } else if (selectedPresetGroupId) {
                const descendantIds = getDescendantGroupIds(selectedPresetGroupId);
                const groupIds = [selectedPresetGroupId, ...descendantIds];
                filtered = presets.filter(p => groupIds.includes(p.group));
            }

            const selectedGroupName = selectedPresetGroupId === '__ungrouped' ? 'Ungrouped'
                : selectedPresetGroupId ? (groups.find(g => g.id === selectedPresetGroupId)?.name || 'Presets')
                : 'All Presets';

            return `
                <div class="entities-presets-content">
                    <div class="presets-sidebar">
                        <div class="presets-sidebar-header">
                            <span>Groups</span>
                            <button class="folder-add-btn" onclick="startAddGroupInline(null)" title="Add group">+</button>
                        </div>
                        <div class="preset-groups-list">
                            <div class="pg-tree-item ${!selectedPresetGroupId ? 'selected' : ''}"
                                 onclick="selectPresetGroup(null)"
                                 ondragover="pgDragOver(event, 'root', null)"
                                 ondragleave="pgDragLeave(event)"
                                 ondrop="pgDrop(event, 'root', null)">
                                <span class="pg-dot" style="background: var(--copper);"></span>
                                <span class="pg-tree-name">All Presets</span>
                                <span class="pg-tree-count">${presets.length}</span>
                            </div>
                            ${ungroupedPresets.length > 0 ? `
                                <div class="pg-tree-item ${selectedPresetGroupId === '__ungrouped' ? 'selected' : ''}"
                                     onclick="selectPresetGroup('__ungrouped')"
                                     ondragover="pgDragOver(event, 'ungrouped', null)"
                                     ondragleave="pgDragLeave(event)"
                                     ondrop="pgDrop(event, 'ungrouped', null)">
                                    <span class="pg-dot" style="background: var(--text-muted);"></span>
                                    <span class="pg-tree-name">Ungrouped</span>
                                    <span class="pg-tree-count">${ungroupedPresets.length}</span>
                                </div>
                            ` : ''}
                            ${renderPresetGroupTree(null, 0)}
                            <div class="pg-root-drop-zone" id="pgRootDropZone"
                                 ondragover="pgDragOver(event, 'root', null)"
                                 ondragleave="pgDragLeave(event)"
                                 ondrop="pgDrop(event, 'root', null)">
                                â†‘ Drop here â†’ move to root
                            </div>
                        </div>
                    </div>
                    <div class="presets-main">
                        <div class="presets-main-header">
                            <span>${selectedGroupName}</span>
                            <button class="btn btn-primary btn-sm" onclick="openAddPresetModal()">+ New Preset</button>
                        </div>
                        <div class="presets-grid-compact">
                            ${filtered.length === 0 ? `
                                <div class="presets-empty">No presets in this group</div>
                            ` : filtered.map(preset => `
                                <div class="preset-card-compact ${selectedPresetId === preset.id ? 'selected' : ''}"
                                     onclick="selectPresetInPersistence('${preset.id}')"
                                     draggable="true"
                                     ondragstart="pgDragStart(event, 'preset', '${preset.id}')"
                                     ondragend="pgDragEnd(event)">
                                    <div class="preset-card-name">${preset.name}</div>
                                    ${preset.forceTraits?.length > 0 ? `
                                        <div class="preset-card-traits">${preset.forceTraits.length} forced traits</div>
                                    ` : ''}
                                    <div class="preset-card-actions">
                                        <button class="btn btn-xs btn-success" onclick="event.stopPropagation(); testPresetInSimulation('${preset.id}')" title="Test this preset in Simulation tab">
                                            ðŸ§ª Test in Sim
                                        </button>
                                        <button class="btn btn-xs" onclick="event.stopPropagation(); spawnFromPresetInPersistence('${preset.id}')" title="Spawn entity from this preset">
                                            â–¶ Spawn
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    <div class="presets-detail">
                        ${addingNewPreset ? renderInlineAddPresetForm()
                        : addingNewGroup ? renderInlineAddGroupForm()
                        : selectedPresetId ? renderPresetDetailWithOverrides()
                        : (selectedPresetGroupId && selectedPresetGroupId !== '__ungrouped') ? renderPresetGroupEditor()
                        : `
                            <div class="presets-detail-empty">
                                <div class="empty-icon">âš™</div>
                                <div>Select a preset or group to edit</div>
                            </div>
                        `}
                    </div>
                </div>
            `;
        }

        // Hierarchical group tree renderer â€” matches node tree design pattern
        function renderPresetGroupTree(parentId, depth) {
            const groups = config.presetGroups || [];
            const presets = config.presets || [];
            const children = getChildGroups(parentId);

            if (children.length === 0) return '';

            // Assign colors based on depth for visual hierarchy
            const depthColors = ['var(--node-layer)', 'var(--node-item)', 'var(--node-variable)', 'var(--node-modifier)', 'var(--node-compound)'];

            return children.map(group => {
                const directPresets = presets.filter(p => p.group === group.id);
                const descendantIds = getDescendantGroupIds(group.id);
                const totalPresets = directPresets.length + presets.filter(p => descendantIds.includes(p.group)).length;
                const hasChildren = getChildGroups(group.id).length > 0;
                const isExpanded = window._expandedPresetGroups?.has(group.id) ?? true;
                const dotColor = depthColors[depth % depthColors.length];
                const isSelected = selectedPresetGroupId === group.id;

                // Drag attrs shared by both folder headers and leaf items
                const dragAttrs = `draggable="true"
                    ondragstart="pgDragStart(event, 'group', '${group.id}')"
                    ondragend="pgDragEnd(event)"
                    ondragover="pgDragOver(event, 'group', '${group.id}')"
                    ondragleave="pgDragLeave(event)"
                    ondrop="pgDrop(event, 'group', '${group.id}')"`;

                const actionBtns = `
                    <button class="pg-tree-add" onclick="event.stopPropagation(); startAddGroupInline('${group.id}')" title="Add child group">+</button>
                    <button class="pg-tree-remove" onclick="event.stopPropagation(); removeGroupOnly('${group.id}')" title="Remove group (keep children &amp; presets)">âˆ’</button>
                `;

                if (hasChildren) {
                    return `
                        <div class="pg-tree-folder">
                            <div class="pg-tree-folder-header ${isSelected ? 'selected' : ''}"
                                 onclick="selectPresetGroup('${group.id}')" ${dragAttrs}>
                                <span class="pg-tree-toggle" onclick="event.stopPropagation(); togglePresetGroupExpand('${group.id}')">
                                    ${isExpanded ? 'â–¼' : 'â–¶'}
                                </span>
                                <span class="pg-dot" style="background: ${dotColor};"></span>
                                <span class="pg-tree-name">${group.name}</span>
                                <span class="pg-tree-count">${totalPresets}</span>
                                ${actionBtns}
                            </div>
                            ${isExpanded ? `
                                <div class="pg-tree-children">
                                    ${renderPresetGroupTree(group.id, depth + 1)}
                                </div>
                            ` : ''}
                        </div>
                    `;
                } else {
                    return `
                        <div class="pg-tree-item ${isSelected ? 'selected' : ''}"
                             onclick="selectPresetGroup('${group.id}')" ${dragAttrs}>
                            <span class="pg-dot" style="background: ${dotColor};"></span>
                            <span class="pg-tree-name">${group.name}</span>
                            <span class="pg-tree-count">${totalPresets}</span>
                            ${actionBtns}
                        </div>
                    `;
                }
            }).join('');
        }

        // Hierarchy helpers
        function getChildGroups(parentId) {
            const groups = config.presetGroups || [];
            return groups.filter(g => (g.parentId || null) === parentId);
        }

        function getDescendantGroupIds(groupId) {
            const children = getChildGroups(groupId);
            let ids = children.map(c => c.id);
            children.forEach(child => {
                ids = ids.concat(getDescendantGroupIds(child.id));
            });
            return ids;
        }

        function getPresetsForGroupAndDescendants(groupId) {
            const presets = config.presets || [];
            const descendantIds = getDescendantGroupIds(groupId);
            const groupIds = [groupId, ...descendantIds];
            return presets.filter(p => groupIds.includes(p.group));
        }

        // ---- Remove group (safe â€” keeps children & presets) ----
        function removeGroupOnly(groupId) {
            const group = (config.presetGroups || []).find(g => g.id === groupId);
            if (!group) return;

            const children = getChildGroups(groupId);
            const directPresets = (config.presets || []).filter(p => p.group === groupId);
            const parts = [];
            if (children.length > 0) parts.push(`${children.length} child group${children.length > 1 ? 's' : ''} moved up`);
            if (directPresets.length > 0) parts.push(`${directPresets.length} preset${directPresets.length > 1 ? 's' : ''} become ungrouped`);
            const detail = parts.length > 0 ? '\n\n' + parts.join(', ') + '.' : '';

            if (!confirm(`Remove group "${group.name}"?${detail}\n\nChildren and presets will NOT be deleted.`)) return;

            // Move children up to this group's parent
            const parentId = group.parentId || null;
            children.forEach(child => { child.parentId = parentId; });

            // Ungroup presets that were in this group
            directPresets.forEach(p => { p.group = null; });

            // Remove the group
            config.presetGroups = config.presetGroups.filter(g => g.id !== groupId);

            if (selectedPresetGroupId === groupId) selectedPresetGroupId = null;
            saveToStorage();
            renderPersistenceView(document.getElementById('viewContent'));
            showToast(`Group "${group.name}" removed`);
        }

        // ---- Drag & Drop for preset groups tree ----
        let _pgDragType = null;  // 'preset' or 'group'
        let _pgDragId = null;

        function pgDragStart(event, type, id) {
            _pgDragType = type;
            _pgDragId = id;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', `${type}:${id}`);
            // Add dragging class after a tick so the element renders before going transparent
            setTimeout(() => {
                event.target.classList.add('dragging');
                // Show root drop zone when dragging
                const rootZone = document.getElementById('pgRootDropZone');
                if (rootZone) rootZone.classList.add('visible');
            }, 0);
        }

        function pgDragEnd(event) {
            _pgDragType = null;
            _pgDragId = null;
            event.target.classList.remove('dragging');
            // Clean up all drag-over classes and hide root drop zone
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            const rootZone = document.getElementById('pgRootDropZone');
            if (rootZone) rootZone.classList.remove('visible');
        }

        function pgDragOver(event, targetType, targetId) {
            // Validate: can we drop here?
            if (!_pgDragType) return;

            // Can't drop on self
            if (_pgDragType === 'group' && targetType === 'group' && _pgDragId === targetId) return;

            // Can't drop group onto its own descendant (would create cycle)
            if (_pgDragType === 'group' && targetType === 'group' && targetId) {
                const descendants = getDescendantGroupIds(_pgDragId);
                if (descendants.includes(targetId)) return;
            }

            // Presets can drop on groups, root, or ungrouped
            // Groups can drop on other groups or root (reparent)
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';

            // Add visual feedback
            const el = event.currentTarget;
            if (!el.classList.contains('drag-over')) {
                el.classList.add('drag-over');
            }
        }

        function pgDragLeave(event) {
            event.currentTarget.classList.remove('drag-over');
        }

        function pgDrop(event, targetType, targetId) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');

            if (!_pgDragType || !_pgDragId) return;

            if (_pgDragType === 'preset') {
                pgDropPreset(_pgDragId, targetType, targetId);
            } else if (_pgDragType === 'group') {
                pgDropGroup(_pgDragId, targetType, targetId);
            }

            _pgDragType = null;
            _pgDragId = null;
        }

        function pgDropPreset(presetId, targetType, targetId) {
            const preset = (config.presets || []).find(p => p.id === presetId);
            if (!preset) return;

            if (targetType === 'group' && targetId) {
                // Move preset into this group
                const oldGroup = preset.group;
                preset.group = targetId;
                if (oldGroup !== targetId) {
                    saveToStorage();
                    renderPersistenceView(document.getElementById('viewContent'));
                    const group = (config.presetGroups || []).find(g => g.id === targetId);
                    showToast(`Moved "${preset.name}" â†’ ${group?.name || targetId}`);
                }
            } else if (targetType === 'root' || targetType === 'ungrouped') {
                // Remove from group
                if (preset.group) {
                    preset.group = null;
                    saveToStorage();
                    renderPersistenceView(document.getElementById('viewContent'));
                    showToast(`"${preset.name}" ungrouped`);
                }
            }
        }

        function pgDropGroup(groupId, targetType, targetId) {
            const group = (config.presetGroups || []).find(g => g.id === groupId);
            if (!group) return;

            if (targetType === 'group' && targetId) {
                // Reparent: make this group a child of the target
                if (group.parentId === targetId) return; // already there
                group.parentId = targetId;
                // Auto-expand the target so the moved group is visible
                if (window._expandedPresetGroups) {
                    window._expandedPresetGroups.add(targetId);
                }
                saveToStorage();
                renderPersistenceView(document.getElementById('viewContent'));
                const target = (config.presetGroups || []).find(g => g.id === targetId);
                showToast(`"${group.name}" â†’ child of "${target?.name || targetId}"`);
            } else if (targetType === 'root') {
                // Move to root level
                if (!group.parentId) return; // already root
                group.parentId = null;
                saveToStorage();
                renderPersistenceView(document.getElementById('viewContent'));
                showToast(`"${group.name}" moved to root`);
            }
        }

        // Initialize expanded state for preset groups
        if (!window._expandedPresetGroups) window._expandedPresetGroups = new Set();

        function togglePresetGroupExpand(groupId) {
            if (window._expandedPresetGroups.has(groupId)) {
                window._expandedPresetGroups.delete(groupId);
            } else {
                window._expandedPresetGroups.add(groupId);
            }
            renderPersistenceView(document.getElementById('viewContent'));
        }

        function selectPresetGroup(groupId) {
            selectedPresetGroupId = groupId;
            selectedPresetId = null;
            addingNewPreset = false;
            addingNewGroup = false;
            renderPersistenceView(document.getElementById('viewContent'));
        }

        function selectPresetInPersistence(presetId) {
            addingNewPreset = false;
            addingNewGroup = false;
            selectedPresetId = presetId;
            renderPersistenceView(document.getElementById('viewContent'));
        }

        // Group editor in detail panel
        function renderPresetGroupEditor() {
            const group = (config.presetGroups || []).find(g => g.id === selectedPresetGroupId);
            if (!group) return '<div class="presets-detail-empty"><div class="empty-icon">âš™</div><div>Group not found</div></div>';

            const groups = config.presetGroups || [];
            const presets = config.presets || [];
            const descendantIds = getDescendantGroupIds(group.id);
            const directPresets = presets.filter(p => p.group === group.id);
            const totalPresets = directPresets.length + presets.filter(p => descendantIds.includes(p.group)).length;
            const childGroups = getChildGroups(group.id);

            // Build parent group options â€” exclude self and descendants (can't be own parent)
            const excludeIds = [group.id, ...descendantIds];
            const availableParents = groups.filter(g => !excludeIds.includes(g.id));

            return `
                <div class="preset-detail-compact">
                    <div class="group-editor-header">
                        <span class="group-editor-icon">ðŸ“</span>
                        <span class="group-editor-title">Edit Group</span>
                    </div>

                    <div class="preset-detail-field">
                        <label>Name</label>
                        <input type="text" class="preset-name-input" value="${group.name || ''}"
                               onchange="updatePresetGroupField('${group.id}', 'name', this.value)">
                    </div>

                    <div class="preset-detail-field">
                        <label>Parent Group</label>
                        <select class="preset-detail-select" onchange="updatePresetGroupField('${group.id}', 'parentId', this.value || null)">
                            <option value="">None (root level)</option>
                            ${availableParents.map(g => `
                                <option value="${g.id}" ${(group.parentId || '') === g.id ? 'selected' : ''}>
                                    ${g.name}
                                </option>
                            `).join('')}
                        </select>
                    </div>

                    <div class="preset-detail-field">
                        <label>Description</label>
                        <textarea class="preset-detail-textarea" rows="3" placeholder="Optional description..."
                                  onchange="updatePresetGroupField('${group.id}', 'description', this.value)">${group.description || ''}</textarea>
                    </div>

                    <div class="group-editor-stats">
                        <div class="group-stat-row">
                            <span class="group-stat-label">Direct presets</span>
                            <span class="group-stat-value">${directPresets.length}</span>
                        </div>
                        ${childGroups.length > 0 ? `
                            <div class="group-stat-row">
                                <span class="group-stat-label">Sub-groups</span>
                                <span class="group-stat-value">${childGroups.length}</span>
                            </div>
                            <div class="group-stat-row">
                                <span class="group-stat-label">Total presets (incl. sub)</span>
                                <span class="group-stat-value">${totalPresets}</span>
                            </div>
                        ` : ''}
                    </div>

                    <div class="group-editor-actions">
                        <button class="btn btn-sm btn-danger" onclick="deletePresetGroup('${group.id}')" title="Delete group and move presets to ungrouped">
                            Delete Group
                        </button>
                    </div>
                </div>
            `;
        }

        function updatePresetGroupField(groupId, field, value) {
            const group = (config.presetGroups || []).find(g => g.id === groupId);
            if (!group) return;
            group[field] = value;
            saveToStorage();
            renderPersistenceView(document.getElementById('viewContent'));
        }

        // Inline add group â€” opens form in detail panel
        function startAddGroupInline(parentId) {
            addingNewGroup = true;
            addingNewGroupParentId = parentId || null;
            addingNewPreset = false;
            selectedPresetId = null;
            renderPersistenceView(document.getElementById('viewContent'));
            // Focus name input after render
            setTimeout(() => document.getElementById('inlineGroupName')?.focus(), 50);
        }

        function renderInlineAddGroupForm() {
            const groups = config.presetGroups || [];
            const parentGroup = addingNewGroupParentId ? groups.find(g => g.id === addingNewGroupParentId) : null;

            return `
                <div class="preset-detail-compact">
                    <div class="group-editor-header">
                        <span class="group-editor-icon">ðŸ“</span>
                        <span class="group-editor-title">New Group</span>
                        <button class="btn btn-xs" onclick="cancelAddGroup()" title="Cancel" style="margin-left: auto;">âœ•</button>
                    </div>

                    <div class="preset-detail-field">
                        <label>Name</label>
                        <input type="text" id="inlineGroupName" class="preset-name-input" placeholder="e.g., Bosses"
                               oninput="autoGenerateGroupId(this.value)">
                    </div>

                    <div class="preset-detail-field">
                        <label>ID</label>
                        <input type="text" id="inlineGroupId" class="preset-name-input" placeholder="auto-generated"
                               oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9_]/g, '_')"
                               style="font-size: 0.75rem; font-family: monospace; color: var(--text-muted);">
                    </div>

                    <div class="preset-detail-field">
                        <label>Parent Group</label>
                        <select id="inlineGroupParent">
                            <option value="">None (root level)</option>
                            ${groups.map(g => `
                                <option value="${g.id}" ${addingNewGroupParentId === g.id ? 'selected' : ''}>${g.name}</option>
                            `).join('')}
                        </select>
                    </div>

                    <div class="preset-detail-field">
                        <label>Description</label>
                        <textarea class="preset-detail-textarea" id="inlineGroupDesc" rows="2" placeholder="Optional description..."></textarea>
                    </div>

                    <div class="preset-detail-actions">
                        <button class="btn btn-sm" onclick="cancelAddGroup()">Cancel</button>
                        <button class="btn btn-sm btn-primary" onclick="submitInlineGroup()">Create Group</button>
                    </div>
                </div>
            `;
        }

        function autoGenerateGroupId(name) {
            const idInput = document.getElementById('inlineGroupId');
            if (idInput && !idInput._manuallyEdited) {
                idInput.value = name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
            }
        }

        function submitInlineGroup() {
            const name = document.getElementById('inlineGroupName')?.value.trim();
            const id = document.getElementById('inlineGroupId')?.value.trim();
            const parentId = document.getElementById('inlineGroupParent')?.value || null;
            const description = document.getElementById('inlineGroupDesc')?.value.trim();

            if (!name) { document.getElementById('inlineGroupName')?.focus(); return; }

            const groupId = id || name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');

            if (!config.presetGroups) config.presetGroups = [];
            if (config.presetGroups.some(g => g.id === groupId)) {
                alert('A group with this ID already exists.');
                return;
            }

            const newGroup = { id: groupId, name: name, parentId: parentId };
            if (description) newGroup.description = description;
            config.presetGroups.push(newGroup);

            // Auto-expand parent so new group is visible in tree
            if (parentId && window._expandedPresetGroups) {
                window._expandedPresetGroups.add(parentId);
            }

            addingNewGroup = false;
            addingNewGroupParentId = null;
            selectedPresetGroupId = groupId; // Select the new group
            saveToStorage();
            renderPersistenceView(document.getElementById('viewContent'));
        }

        function cancelAddGroup() {
            addingNewGroup = false;
            addingNewGroupParentId = null;
            renderPersistenceView(document.getElementById('viewContent'));
        }

        // Quick-add group popup â€” shows name + parent dropdown
        function showQuickAddGroupPopup(onCreated, onCancelled) {
            const groups = config.presetGroups || [];
            const overlay = document.createElement('div');
            overlay.className = 'quick-group-overlay';
            overlay.innerHTML = `
                <div class="quick-group-popup">
                    <div class="quick-group-title">New Group</div>
                    <div class="preset-detail-field">
                        <label>Name</label>
                        <input type="text" id="quickGroupName" class="preset-name-input" placeholder="Group name..." autofocus>
                    </div>
                    ${groups.length > 0 ? `
                        <div class="preset-detail-field">
                            <label>Parent Group</label>
                            <select id="quickGroupParent">
                                <option value="">None (root level)</option>
                                ${groups.map(g => `<option value="${g.id}">${g.name}</option>`).join('')}
                            </select>
                        </div>
                    ` : ''}
                    <div class="quick-group-buttons">
                        <button class="btn btn-sm" id="quickGroupCancel">Cancel</button>
                        <button class="btn btn-sm btn-primary" id="quickGroupSubmit">Create</button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);

            // Focus name input
            setTimeout(() => document.getElementById('quickGroupName')?.focus(), 50);

            // Cancel button
            document.getElementById('quickGroupCancel').addEventListener('click', () => {
                overlay.remove();
                onCancelled();
            });

            // Click outside to close
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                    onCancelled();
                }
            });

            // Submit
            document.getElementById('quickGroupSubmit').addEventListener('click', () => {
                const name = document.getElementById('quickGroupName')?.value.trim();
                if (!name) { document.getElementById('quickGroupName')?.focus(); return; }
                const parentId = document.getElementById('quickGroupParent')?.value || null;
                const groupId = name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');

                if (!config.presetGroups) config.presetGroups = [];
                if (!config.presetGroups.some(g => g.id === groupId)) {
                    config.presetGroups.push({ id: groupId, name: name, parentId: parentId });
                    // Auto-expand parent so new group is visible
                    if (parentId && window._expandedPresetGroups) {
                        window._expandedPresetGroups.add(parentId);
                    }
                }
                saveToStorage();
                overlay.remove();
                onCreated(groupId);
            });

            // Enter key to submit
            document.getElementById('quickGroupName').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') document.getElementById('quickGroupSubmit')?.click();
                if (e.key === 'Escape') { overlay.remove(); onCancelled(); }
            });
        }

        // Handle group dropdown changes â€” intercepts "+ New Group..." selection
        function handlePresetGroupChange(presetId, selectEl) {
            if (selectEl.value === '__new_group__') {
                showQuickAddGroupPopup(
                    (groupId) => {
                        updatePreset(presetId, 'group', groupId);
                        renderPersistenceView(document.getElementById('viewContent'));
                    },
                    () => {
                        const preset = (config.presets || []).find(p => p.id === presetId);
                        selectEl.value = preset?.group || '';
                    }
                );
            } else {
                updatePreset(presetId, 'group', selectEl.value || null);
                renderPersistenceView(document.getElementById('viewContent'));
            }
        }

        function spawnFromPresetInPersistence(presetId) {
            const entity = simulateSpawn(presetId);
            recalculatePreviewEntity(entity);
            // Apply preset overrides if any
            const preset = (config.presets || []).find(p => p.id === presetId);
            if (preset?.attributeOverrides) {
                Object.entries(preset.attributeOverrides).forEach(([attrId, override]) => {
                    if (override.enabled && entity.attributes[attrId]) {
                        entity.attributes[attrId].value = override.value;
                    }
                });
            }
            if (preset?.variableOverrides) {
                Object.entries(preset.variableOverrides).forEach(([varId, override]) => {
                    if (override.enabled && entity.variables[varId]) {
                        entity.variables[varId].value = override.value;
                    }
                });
            }
            recalculateEntityState(entity);
            previewEntities.unshift(entity);
            if (previewEntities.length > 50) previewEntities.pop();
            persistenceSection = 'saved';
            renderPersistenceView(document.getElementById('viewContent'));
            showToast('Entity spawned from preset');
        }

        // Preset detail with attribute/variable overrides
        function renderPresetDetailWithOverrides() {
            const preset = (config.presets || []).find(p => p.id === selectedPresetId);
            if (!preset) return '';

            const allTraits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
            const allAttributes = config.nodes.filter(n => n.type === 'attribute');
            const allVariables = config.nodes.filter(n => n.type === 'variable');

            return `
                <div class="preset-detail-compact">
                    <div class="preset-detail-header">
                        <input type="text" value="${preset.name}"
                               onchange="updatePreset('${preset.id}', 'name', this.value); renderPersistenceView(document.getElementById('viewContent'));"
                               class="preset-name-input">
                        <button class="btn btn-xs btn-danger" onclick="deletePreset('${preset.id}')" title="Delete preset">âœ•</button>
                    </div>
                    <div class="preset-detail-field">
                        <label>Description</label>
                        <textarea onchange="updatePreset('${preset.id}', 'description', this.value)"
                                  placeholder="Describe this preset...">${preset.description || ''}</textarea>
                    </div>

                    <div class="preset-detail-field">
                        <label>Group</label>
                        <select onchange="handlePresetGroupChange('${preset.id}', this)">
                            <option value="" ${!preset.group ? 'selected' : ''}>Ungrouped</option>
                            ${(config.presetGroups || []).map(g =>
                                `<option value="${g.id}" ${preset.group === g.id ? 'selected' : ''}>${g.name}</option>`
                            ).join('')}
                            <option value="__new_group__">+ New Group...</option>
                        </select>
                    </div>

                    <div class="preset-detail-field">
                        <label>Forced Traits (${(preset.forceTraits || []).length})</label>
                        <div class="preset-forced-traits">
                            ${allTraits.map(t => `
                                <label class="preset-trait-checkbox">
                                    <input type="checkbox" ${(preset.forceTraits || []).includes(t.id) ? 'checked' : ''}
                                           onchange="togglePresetTrait('${preset.id}', '${t.id}', this.checked)">
                                    <span>${t.name}</span>
                                </label>
                            `).join('')}
                        </div>
                    </div>

                    ${allAttributes.length > 0 ? `
                    <div class="preset-detail-field">
                        <label>Attribute Overrides</label>
                        <div class="preset-overrides-list">
                            ${allAttributes.map(attr => {
                                const override = preset.attributeOverrides?.[attr.id] || { enabled: false, value: attr.config?.defaultValue ?? 50 };
                                const defVal = attr.config?.defaultValue ?? null;
                                const defRange = attr.config?.defaultRange;
                                const defHint = defRange ? defRange.join('\u2013') : (defVal != null ? defVal : 'random');
                                return `
                                    <div class="preset-override-row ${override.enabled ? 'active' : ''}">
                                        <label class="preset-override-check">
                                            <input type="checkbox" ${override.enabled ? 'checked' : ''}
                                                   onchange="togglePresetAttrOverride('${preset.id}', '${attr.id}', this.checked)">
                                        </label>
                                        <span class="preset-override-name">${attr.name}</span>
                                        <span class="preset-override-hint">${!override.enabled ? 'def: ' + defHint : ''}</span>
                                        <input type="number" class="preset-override-value"
                                               ${override.enabled ? 'value="' + override.value + '"' : 'placeholder="' + defHint + '"'}
                                               min="${attr.config?.min || 0}" max="${attr.config?.max || 100}"
                                               ${!override.enabled ? 'disabled' : ''}
                                               onchange="setPresetAttrOverride('${preset.id}', '${attr.id}', parseFloat(this.value))">
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    ${allVariables.length > 0 ? `
                    <div class="preset-detail-field">
                        <label>Variable Overrides</label>
                        <div class="preset-overrides-list">
                            ${allVariables.map(varNode => {
                                const override = preset.variableOverrides?.[varNode.id] || { enabled: false, value: varNode.config?.initialValue ?? 50 };
                                const defVal = varNode.config?.initialValue ?? null;
                                const defMin = varNode.config?.initialMin ?? defVal;
                                const defMax = varNode.config?.initialMax ?? defVal;
                                const defHint = (defMin != null && defMax != null && defMin !== defMax) ? defMin + '\u2013' + defMax : (defVal != null ? defVal : 'random');
                                return `
                                    <div class="preset-override-row ${override.enabled ? 'active' : ''}">
                                        <label class="preset-override-check">
                                            <input type="checkbox" ${override.enabled ? 'checked' : ''}
                                                   onchange="togglePresetVarOverride('${preset.id}', '${varNode.id}', this.checked)">
                                        </label>
                                        <span class="preset-override-name">${varNode.name}</span>
                                        <span class="preset-override-hint">${!override.enabled ? 'def: ' + defHint : ''}</span>
                                        <input type="number" class="preset-override-value"
                                               ${override.enabled ? 'value="' + override.value + '"' : 'placeholder="' + defHint + '"'}
                                               min="${varNode.config?.min ?? 0}" max="${varNode.config?.max ?? 100}"
                                               ${!override.enabled ? 'disabled' : ''}
                                               onchange="setPresetVarOverride('${preset.id}', '${varNode.id}', parseFloat(this.value))">
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <div class="preset-detail-actions">
                        <button class="btn btn-success btn-test-sim" onclick="testPresetInSimulation('${preset.id}')">
                            ðŸ§ª Test in Simulation
                        </button>
                        <button class="btn" onclick="spawnFromPresetInPersistence('${preset.id}')">
                            â–¶ Spawn
                        </button>
                    </div>
                </div>
            `;
        }

        // Inline "Add New Preset" form (renders in detail panel instead of modal)
        function renderInlineAddPresetForm() {
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const layers = config.nodes.filter(n => n.type === 'layer');
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const groups = config.presetGroups || [];

            // Group traits by layer
            const traitsByLayer = {};
            const orphanTraits = [];
            traits.forEach(trait => {
                if (trait.config?.layerId) {
                    const layer = layers.find(l => l.id === trait.config.layerId);
                    const layerName = layer?.name || trait.config.layerId;
                    if (!traitsByLayer[layerName]) traitsByLayer[layerName] = { layer, traits: [] };
                    traitsByLayer[layerName].traits.push(trait);
                } else {
                    orphanTraits.push(trait);
                }
            });
            const sortedLayers = Object.entries(traitsByLayer).sort((a, b) =>
                (a[1].layer?.config?.order ?? 999) - (b[1].layer?.config?.order ?? 999)
            );

            return `
                <div class="preset-detail-compact">
                    <div class="preset-detail-header" style="border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; margin-bottom: 0.5rem;">
                        <span style="font-weight: 600; color: var(--accent-copper); font-family: 'Raleway', sans-serif;">New Preset</span>
                        <button class="btn btn-xs" onclick="cancelAddPreset()" title="Cancel">âœ•</button>
                    </div>

                    <div class="preset-detail-field">
                        <label>Name</label>
                        <input type="text" id="inlinePresetName" placeholder="e.g., Elite Variant"
                               oninput="autoGeneratePresetId(this.value)">
                    </div>
                    <div class="preset-detail-field">
                        <label>ID</label>
                        <input type="text" id="inlinePresetId" placeholder="auto-generated"
                               oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9_]/g, '_')"
                               style="font-size: 0.75rem; font-family: monospace; color: var(--text-muted);">
                    </div>
                    <div class="preset-detail-field">
                        <label>Group</label>
                        <div style="display: flex; gap: 0.3rem;">
                            <select id="inlinePresetGroup" style="flex: 1;" onchange="handleInlineGroupSelect(this)">
                                <option value="">Ungrouped</option>
                                ${groups.map(g => `<option value="${g.id}" ${selectedPresetGroupId === g.id ? 'selected' : ''}>${g.name}</option>`).join('')}
                                <option value="__new_group__">+ New Group...</option>
                            </select>
                        </div>
                    </div>
                    <div class="preset-detail-field">
                        <label>Description</label>
                        <textarea id="inlinePresetDesc" rows="2" placeholder="Optional description..."></textarea>
                    </div>

                    ${traits.length + modifiers.length > 0 ? `
                    <div class="preset-detail-field">
                        <label>Force Traits</label>
                        <div class="preset-forced-traits" style="max-height: 150px; overflow-y: auto;">
                            ${sortedLayers.map(([layerName, data]) => `
                                <div style="margin-bottom: 0.4rem;">
                                    <div style="font-size: 0.6rem; text-transform: uppercase; color: var(--accent-secondary); margin-bottom: 0.2rem;">${layerName}</div>
                                    ${data.traits.map(t => `
                                        <label class="preset-trait-checkbox">
                                            <input type="checkbox" id="inlinePresetTrait_${t.id}" value="${t.id}">
                                            <span>${t.name}</span>
                                        </label>
                                    `).join('')}
                                </div>
                            `).join('')}
                            ${modifiers.length > 0 ? `
                                <div style="margin-bottom: 0.4rem; padding-top: 0.3rem; border-top: 1px solid var(--border-color);">
                                    <div style="font-size: 0.6rem; text-transform: uppercase; color: var(--node-modifier); margin-bottom: 0.2rem;">Modifiers</div>
                                    ${modifiers.map(m => `
                                        <label class="preset-trait-checkbox">
                                            <input type="checkbox" id="inlinePresetTrait_${m.id}" value="${m.id}">
                                            <span>${m.name}</span>
                                        </label>
                                    `).join('')}
                                </div>
                            ` : ''}
                            ${orphanTraits.length > 0 ? `
                                <div>
                                    <div style="font-size: 0.6rem; text-transform: uppercase; color: var(--text-muted); margin-bottom: 0.2rem;">Other</div>
                                    ${orphanTraits.map(t => `
                                        <label class="preset-trait-checkbox">
                                            <input type="checkbox" id="inlinePresetTrait_${t.id}" value="${t.id}">
                                            <span>${t.name}</span>
                                        </label>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                    ` : ''}

                    ${attributes.length > 0 ? `
                    <div class="preset-detail-field">
                        <label>Attribute Overrides</label>
                        <div class="preset-overrides-list">
                            ${attributes.map(attr => {
                                const defVal = attr.config?.defaultValue ?? attr.config?.defaultRange?.[0] ?? null;
                                const defHint = attr.config?.defaultRange ? attr.config.defaultRange.join('â€“') : (defVal != null ? defVal : 'random');
                                return `
                                    <div class="preset-override-row">
                                        <label class="preset-override-check">
                                            <input type="checkbox" onchange="this.closest('.preset-override-row').classList.toggle('active', this.checked); this.closest('.preset-override-row').querySelector('.preset-override-value').disabled = !this.checked;">
                                        </label>
                                        <span class="preset-override-name">${attr.name}</span>
                                        <span class="preset-override-hint">def: ${defHint}</span>
                                        <input type="number" class="preset-override-value" id="inlinePresetAttr_${attr.id}"
                                               min="${attr.config?.min || 0}" max="${attr.config?.max || 100}"
                                               placeholder="${defHint}" disabled>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    ${variables.length > 0 ? `
                    <div class="preset-detail-field">
                        <label>Variable Overrides</label>
                        <div class="preset-overrides-list">
                            ${variables.map(varNode => {
                                const defVal = varNode.config?.initialValue ?? null;
                                const defMin = varNode.config?.initialMin ?? defVal;
                                const defMax = varNode.config?.initialMax ?? defVal;
                                const defHint = (defMin != null && defMax != null && defMin !== defMax) ? defMin + 'â€“' + defMax : (defVal != null ? defVal : 'random');
                                return `
                                    <div class="preset-override-row">
                                        <label class="preset-override-check">
                                            <input type="checkbox" onchange="this.closest('.preset-override-row').classList.toggle('active', this.checked); this.closest('.preset-override-row').querySelector('.preset-override-value').disabled = !this.checked;">
                                        </label>
                                        <span class="preset-override-name">${varNode.name}</span>
                                        <span class="preset-override-hint">def: ${defHint}</span>
                                        <input type="number" class="preset-override-value" id="inlinePresetVar_${varNode.id}"
                                               min="${varNode.config?.min ?? 0}" max="${varNode.config?.max ?? 100}"
                                               placeholder="${defHint}" disabled>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <div class="preset-detail-actions">
                        <button class="btn btn-primary" onclick="submitInlinePreset()">
                            âœ“ Create Preset
                        </button>
                        <button class="btn" onclick="cancelAddPreset()">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
        }

        function autoGeneratePresetId(name) {
            const idInput = document.getElementById('inlinePresetId');
            if (idInput && !idInput._manuallyEdited) {
                idInput.value = name.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
            }
        }

        function handleInlineGroupSelect(selectEl) {
            if (selectEl.value === '__new_group__') {
                showQuickAddGroupPopup(
                    (groupId) => {
                        // Add the option to the dropdown without losing form data
                        const group = (config.presetGroups || []).find(g => g.id === groupId);
                        const newOption = document.createElement('option');
                        newOption.value = groupId;
                        newOption.textContent = group?.name || groupId;
                        newOption.selected = true;
                        selectEl.insertBefore(newOption, selectEl.querySelector('option[value="__new_group__"]'));
                    },
                    () => {
                        selectEl.value = ''; // revert to Ungrouped
                    }
                );
            }
        }

        function cancelAddPreset() {
            addingNewPreset = false;
            renderPersistenceView(document.getElementById('viewContent'));
        }

        function submitInlinePreset() {
            const name = document.getElementById('inlinePresetName')?.value.trim();
            const id = document.getElementById('inlinePresetId')?.value.trim();
            let group = document.getElementById('inlinePresetGroup')?.value || null;
            const description = document.getElementById('inlinePresetDesc')?.value.trim() || '';

            if (!id) {
                showToast('Please enter a preset name', 'error');
                return;
            }

            if (!config.presets) config.presets = [];
            if (config.presets.some(p => p.id === id)) {
                showToast('A preset with this ID already exists', 'error');
                return;
            }

            // Handle "+ New Group..." selection
            if (group === '__new_group__') {
                group = null; // Will be ungrouped; user can reassign after
            }

            // Collect forced traits
            const forceTraits = [];
            const allForceables = config.nodes.filter(n => n.type === 'trait' || n.type === 'item' || n.type === 'modifier');
            allForceables.forEach(node => {
                const cb = document.getElementById(`inlinePresetTrait_${node.id}`);
                if (cb?.checked) forceTraits.push(node.id);
            });

            // Collect attribute overrides (only enabled ones)
            const attributeOverrides = {};
            config.nodes.filter(n => n.type === 'attribute').forEach(attr => {
                const row = document.getElementById(`inlinePresetAttr_${attr.id}`);
                if (row && !row.disabled && row.value !== '') {
                    attributeOverrides[attr.id] = { enabled: true, value: parseFloat(row.value) };
                }
            });

            // Collect variable overrides (only enabled ones)
            const variableOverrides = {};
            config.nodes.filter(n => n.type === 'variable').forEach(varNode => {
                const row = document.getElementById(`inlinePresetVar_${varNode.id}`);
                if (row && !row.disabled && row.value !== '') {
                    variableOverrides[varNode.id] = { enabled: true, value: parseFloat(row.value) };
                }
            });

            // Also collect old-style attributes for backwards compat
            const attributes = {};
            Object.entries(attributeOverrides).forEach(([attrId, o]) => {
                if (o.enabled) attributes[attrId] = o.value;
            });

            config.presets.push({
                id,
                name: name || id,
                description,
                group,
                tags: [],
                attributes,
                attributeOverrides,
                variableOverrides,
                contexts: {},
                forceTraits
            });

            addingNewPreset = false;
            selectedPresetId = id;
            saveToStorage();
            renderPersistenceView(document.getElementById('viewContent'));
            showToast(`Preset "${name || id}" created`);
        }

        // Preset override helpers
        function togglePresetAttrOverride(presetId, attrId, enabled) {
            const preset = (config.presets || []).find(p => p.id === presetId);
            if (!preset) return;
            if (!preset.attributeOverrides) preset.attributeOverrides = {};
            if (!preset.attributeOverrides[attrId]) {
                const attrNode = config.nodes.find(n => n.id === attrId);
                preset.attributeOverrides[attrId] = { enabled: false, value: attrNode?.config?.defaultValue ?? 50 };
            }
            preset.attributeOverrides[attrId].enabled = enabled;
            saveToStorage();
            renderPersistenceView(document.getElementById('viewContent'));
        }

        function setPresetAttrOverride(presetId, attrId, value) {
            const preset = (config.presets || []).find(p => p.id === presetId);
            if (!preset || !preset.attributeOverrides?.[attrId]) return;
            preset.attributeOverrides[attrId].value = value;
            saveToStorage();
        }

        function togglePresetVarOverride(presetId, varId, enabled) {
            const preset = (config.presets || []).find(p => p.id === presetId);
            if (!preset) return;
            if (!preset.variableOverrides) preset.variableOverrides = {};
            if (!preset.variableOverrides[varId]) {
                const varNode = config.nodes.find(n => n.id === varId);
                preset.variableOverrides[varId] = { enabled: false, value: varNode?.config?.initialValue ?? 50 };
            }
            preset.variableOverrides[varId].enabled = enabled;
            saveToStorage();
            renderPersistenceView(document.getElementById('viewContent'));
        }

        function setPresetVarOverride(presetId, varId, value) {
            const preset = (config.presets || []).find(p => p.id === presetId);
            if (!preset || !preset.variableOverrides?.[varId]) return;
            preset.variableOverrides[varId].value = value;
            saveToStorage();
        }

        // ----------------------------------------
        // Persistence: Pools Section (inline)
        // ----------------------------------------

        function renderPersistencePoolsSection() {
            const pools = Array.from(poolConfigs.values());

            return `
                <div class="persistence-pools-content">
                    <div class="pools-header">
                        <span class="pools-title">Pools</span>
                        <button class="btn btn-primary btn-sm" onclick="createNewPool(); renderPersistenceView(document.getElementById('viewContent'));">
                            + New Pool
                        </button>
                    </div>
                    ${pools.length <= 1 ? `
                        <div class="pools-explainer">
                            Pools are runtime containers for spawned entities. Use multiple pools to separate entity types
                            (e.g. "NPCs" vs "Enemies") with independent capacity limits and lifecycle rules.
                            The <strong>Default Pool</strong> is always available.
                        </div>
                    ` : ''}
                    <div class="pools-grid">
                        ${pools.map(pool => renderPoolCard(pool)).join('')}
                    </div>
                </div>
            `;
        }

        // ----------------------------------------
        // Persistence: Saved Entities Section
        // ----------------------------------------

        function renderPersistenceSavedSection() {
            const filtered = getEntitiesForCurrentConfig();
            const filteredCount = filtered.active.length + filtered.stored.length + filtered.starred.length;
            const pools = Array.from(poolConfigs.values());
            const tickRate = (config.engineConfig?.tickRate || 1000) / 1000;

            return `
                <div class="persistence-saved-content">
                    <div class="saved-controls">
                        <div class="pool-controls">
                            <div class="pool-selector">
                                <label>Pool:</label>
                                <select onchange="setPoolFilter(this.value); renderPersistenceView(document.getElementById('viewContent'));">
                                    <option value="all" ${selectedPoolFilter === 'all' ? 'selected' : ''}>All Pools</option>
                                    ${pools.map(p => {
                                        const stats = getPoolStats(p.id);
                                        return `<option value="${p.id}" ${selectedPoolFilter === p.id ? 'selected' : ''}>${p.name} (${stats.total})</option>`;
                                    }).join('')}
                                </select>
                            </div>
                        </div>

                        <div class="entity-tick-controls">
                            <button class="btn btn-sm ${autoTickEnabled ? 'btn-success' : ''}" onclick="toggleAutoTick()">
                                ${autoTickEnabled ? 'â¸ Pause' : 'â–¶ Auto-Tick'}
                            </button>
                            <span class="tick-status">
                                <span class="tick-indicator ${autoTickEnabled ? 'running' : ''}"></span>
                                ${tickRate}s/tick
                            </span>
                            <button class="btn btn-xs" onclick="tickAllActiveEntities()" ${autoTickEnabled ? 'disabled' : ''}>
                                â­ Tick Once
                            </button>
                        </div>

                        <button class="btn btn-sm" onclick="switchView('simulation')" title="Open Simulation to spawn entities">
                            â† Simulation
                        </button>
                    </div>

                    <div class="entities-content">
                        <div class="entities-list-panel">
                            ${renderEntityListSection('active', 'Active', filtered.active, 'â—')}
                            ${renderEntityListSection('stored', 'Stored', filtered.stored, 'â—‹')}
                            ${renderEntityListSection('starred', 'Starred', filtered.starred, 'â˜…')}

                            ${previewEntities.length > 0 ? `
                                <div class="entities-list-section">
                                    <div class="entities-section-header" onclick="toggleEntitySection('preview')">
                                        <span class="section-icon">â—‡</span>
                                        <span>Unsaved Preview</span>
                                        <span class="section-count">${previewEntities.length}</span>
                                    </div>
                                    <div class="entities-section-items" id="entitySection_preview">
                                        ${previewEntities.slice(0, 10).map((entity, idx) => `
                                            <div class="entity-list-item" onclick="selectEntity('${entity.id}')">
                                                <span class="entity-status preview"></span>
                                                <span class="entity-name">${entity.name || 'Preview #' + (idx + 1)}</span>
                                                <div class="entity-actions">
                                                    <button class="entity-action-btn" onclick="event.stopPropagation(); promotePreviewEntity(${idx}); renderPersistenceView(document.getElementById('viewContent'));" title="Promote to Active">âœ“</button>
                                                    <button class="entity-action-btn delete-btn" onclick="event.stopPropagation(); discardPreviewEntity(${idx}); renderPersistenceView(document.getElementById('viewContent'));" title="Discard">âœ•</button>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>

                        <div class="entities-detail-panel">
                            ${selectedEntityId ? renderSavedEntityDetail(findEntityById(selectedEntityId)) : `
                                <div class="entities-empty">
                                    <div class="entities-empty-icon">â—‡</div>
                                    <div class="entities-empty-text">
                                        ${filteredCount === 0 ? 'No Saved Entities' : 'Select an Entity'}
                                    </div>
                                    <div class="entities-empty-hint">
                                        ${filteredCount === 0
                                            ? 'Spawn entities in Simulation, then promote them here'
                                            : 'Click an entity in the list to view details'
                                        }
                                    </div>
                                </div>
                            `}
                        </div>
                    </div>
                </div>
            `;
        }

        // Saved entity detail â€” uses unified renderer with persistence options
        function renderSavedEntityDetail(entity) {
            if (!entity) return '';

            const status = getEntityStatus(entity.id);

            return `
                <div class="saved-entity-detail">
                    <div class="entity-detail-header">
                        <div class="entity-detail-name">
                            <input type="text" value="${entity.name || ''}"
                                   onchange="renameEntity('${entity.id}', this.value)"
                                   placeholder="Entity name...">
                        </div>
                        <div class="entity-detail-status">
                            <span class="entity-status-badge ${status}">${status.toUpperCase()}</span>
                        </div>
                        <button class="btn btn-xs" onclick="openEntityInSimulation('${entity.id}')" title="Open in Simulation State Mode">
                            ðŸ§ª Open in Sim
                        </button>
                    </div>
                    ${renderUnifiedEntityState(entity, {
                        editableAttributes: true,
                        editableTraits: true,
                        showModifierToggles: true,
                        showTickControls: true,
                        showPoolAssignment: true,
                        showSaveAsPreset: true,
                        showPromoteButton: false,
                        context: 'persistence'
                    })}
                </div>
            `;
        }

        // ----------------------------------------
        // Cross-Tab Navigation
        // ----------------------------------------

        function testPresetInSimulation(presetId) {
            spawnSimState.presetId = presetId;
            simulationMode = 'spawn';
            switchView('simulation');
            // Auto-select the preset in the dropdown after render
            setTimeout(() => {
                const selector = document.getElementById('spawnPresetSelector');
                if (selector) selector.value = presetId;
            }, 50);
            showToast('Preset loaded in Simulation');
        }

        function openEntityInSimulation(entityId) {
            // Clone entity to spawnLogicEntities so it appears in simulation
            const entity = findEntityById(entityId);
            if (!entity) return;

            // Check if already in spawn logic entities
            if (!spawnLogicEntities.find(e => e.id === entityId)) {
                const clone = JSON.parse(JSON.stringify(entity));
                spawnLogicEntities.unshift(clone);
                if (spawnLogicEntities.length > 10) spawnLogicEntities.pop();
            }

            switchView('simulation');
            enterStateMode(entityId);
            showToast('Entity loaded in Simulation');
        }

        // Legacy aliases
        function selectPresetGroupInEntities(groupId) { selectPresetGroup(groupId); }
        function selectPresetInEntities(presetId) { selectPresetInPersistence(presetId); }

        // DEPRECATED v3.3: Replaced by renderPersistenceView(). Kept as delegate for Session 4 cleanup.
        // All callers (entity management functions) that call renderEntitiesView() will be
        // redirected to renderPersistenceView() when on the persistence tab.
        // v3.3: renderEntitiesView is kept as a delegate â€” all 30+ entity management
        // functions call it to re-render. It always delegates to renderPersistenceView.
        function renderEntitiesView(container) {
            return renderPersistenceView(container);
        }

        // v3.3 Session 4 â€” Old Entities tab UI deleted. Functions removed:
        //   old renderEntitiesView body, switchEntitiesSubTab, renderEntitiesPresetsSubTab,
        //   selectPresetGroupInEntities (duplicate at line ~38369), selectPresetInEntities (duplicate),
        //   spawnFromPresetInEntities, renderPresetDetailCompact, renderEntityDetail
        // Replaced by: renderPersistenceView â†’ renderPersistencePresetsSection/PoolsSection/SavedSection

        // v3.3 Session 4: Old Entities tab UI cluster deleted.
        // Removed: old renderEntitiesView body, switchEntitiesSubTab, renderEntitiesPresetsSubTab,
        //   selectPresetGroupInEntities (duplicate), selectPresetInEntities (duplicate),
        //   spawnFromPresetInEntities, renderPresetDetailCompact, renderEntityDetail
        // renderEntityListSection() and renderEntityListItem() kept â€” used by Persistence saved section.
        function renderEntityListSection(status, label, entities, icon) {
            const isCollapsed = entities.length === 0;
            const tooltips = {
                active: 'Entities currently in use - they tick and respond to events',
                stored: 'Inactive entities saved for later - click â†‘ to reactivate',
                starred: 'Favorited entities - protected from auto-cleanup'
            };
            return `
                <div class="entities-list-section">
                    <div class="entities-section-header" onclick="toggleEntitySection('${status}')" title="${tooltips[status] || ''}">
                        <span class="section-icon">${icon}</span>
                        <span>${label}</span>
                        <span class="section-count">${entities.length}</span>
                    </div>
                    <div class="entities-section-items ${isCollapsed ? 'collapsed' : ''}" id="entitySection_${status}">
                        ${entities.length === 0
                            ? '<div style="padding: 0.5rem 0.75rem; color: var(--text-muted); font-size: 0.75rem; font-style: italic;">None</div>'
                            : entities.map(e => renderEntityListItem(e, status)).join('')
                        }
                    </div>
                </div>
            `;
        }

        function renderEntityListItem(entity, status) {
            const isSelected = selectedEntityId === entity.id;
            return `
                <div class="entity-list-item ${isSelected ? 'selected' : ''}" onclick="selectEntity('${entity.id}')">
                    <span class="entity-status ${status}"></span>
                    <span class="entity-name">${entity.name || entity.id}</span>
                    <div class="entity-actions">
                        ${status === 'active' ? `
                            <button class="entity-action-btn star-btn" onclick="event.stopPropagation(); starEntity('${entity.id}')" title="Favorite (protect from auto-cleanup)">â˜…</button>
                            <button class="entity-action-btn" onclick="event.stopPropagation(); deactivateEntity('${entity.id}')" title="Store for later (stops ticking)">â†“</button>
                        ` : ''}
                        ${status === 'stored' ? `
                            <button class="entity-action-btn" onclick="event.stopPropagation(); activateEntity('${entity.id}')" title="Reactivate (resumes ticking)">â†‘</button>
                            <button class="entity-action-btn star-btn" onclick="event.stopPropagation(); starEntity('${entity.id}')" title="Favorite (protect from auto-cleanup)">â˜…</button>
                        ` : ''}
                        ${status === 'starred' ? `
                            <button class="entity-action-btn" onclick="event.stopPropagation(); unstarEntity('${entity.id}')" title="Remove from favorites">â˜†</button>
                        ` : ''}
                        <button class="entity-action-btn delete-btn" onclick="event.stopPropagation(); deleteEntity('${entity.id}')" title="Permanently delete">âœ•</button>
                    </div>
                </div>
            `;
        }

        // v3.3 Session 4: renderEntityDetail() deleted â€” replaced by renderSavedEntityDetail()
        function selectEntity(entityId) {
            selectedEntityId = entityId;
            if (currentView === 'persistence') {
                renderPersistenceView(document.getElementById('viewContent'));
            } else {
                renderEntitiesView(document.getElementById('viewContent'));
            }
        }

        function toggleEntitySection(status) {
            const section = document.getElementById(`entitySection_${status}`);
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        // ========================================
        // MODIFIER & COMPOUND MANAGEMENT
        // ========================================

        function renderModifiersSection(entity) {
            const allModifiers = config.nodes.filter(n => n.type === 'modifier');

            if (allModifiers.length === 0) {
                return '<div class="modifiers-empty">No modifiers defined in config</div>';
            }

            // Get active modifiers only (dropdown handles adding)
            const activeModifiers = (entity.modifiers || []).map(m => {
                const modId = m.id || m;
                const modNode = allModifiers.find(n => n.id === modId);
                const isThreshold = modNode?.config?.triggerType === 'threshold';
                return {
                    id: modId,
                    name: modNode?.name || modId,
                    isThreshold,
                    forced: m.forced
                };
            });

            if (activeModifiers.length === 0) {
                return '<div class="modifiers-empty">No active modifiers</div>';
            }

            return `
                <div class="modifiers-list">
                    ${activeModifiers.map(mod => `
                        <div class="modifier-item active">
                            <span class="modifier-icon" style="color: var(--node-modifier);">â—†</span>
                            <span class="modifier-name">${mod.name}</span>
                            ${mod.isThreshold ? '<span class="modifier-type" title="Threshold-triggered">âš¡</span>' : ''}
                            ${mod.forced ? '<span class="modifier-type" title="Force-applied" style="color: var(--accent-gold);">âš¡</span>' : ''}
                            <button class="btn btn-xs btn-danger" onclick="removeModifierFromEntity('${entity.id}', '${mod.id}')" title="Remove modifier" style="margin-left: auto;">âœ•</button>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function checkModifierEligibility(entity, modifier) {
            // Check eligibility gates
            const gates = config.relationships.filter(r =>
                r.type === 'eligibility_gate' && r.targetId === modifier.id
            );

            for (const gate of gates) {
                const sourceNode = config.nodes.find(n => n.id === gate.sourceId);
                if (!sourceNode) continue;

                // Check if source is active (blocks the modifier)
                if (sourceNode.type === 'trait' || sourceNode.type === 'item') {
                    const activeTrait = (entity.traits || []).find(t => t.id === gate.sourceId && t.active !== false);
                    if (activeTrait) {
                        return { eligible: false, reason: `Blocked by ${sourceNode.name}` };
                    }
                } else if (sourceNode.type === 'modifier') {
                    const activeModifier = (entity.modifiers || []).find(m => (m.id || m) === gate.sourceId);
                    if (activeModifier) {
                        return { eligible: false, reason: `Blocked by ${sourceNode.name}` };
                    }
                }
            }

            return { eligible: true };
        }

        function applyModifierToEntity(entityId, modifierId) {
            const entity = findEntityById(entityId);
            if (!entity) return;

            const modNode = config.nodes.find(n => n.id === modifierId);
            if (!modNode) return;

            if (!entity.modifiers) entity.modifiers = [];

            // Check if already active
            if (entity.modifiers.some(m => (m.id || m) === modifierId)) {
                showToast('Modifier already active', 'warning');
                return;
            }

            entity.modifiers.push({
                id: modifierId,
                name: modNode.name,
                manual: true
            });

            recalculateManagedEntity(entity);
            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
            showToast(`Applied: ${modNode.name}`);
        }

        function forceApplyModifier(entityId, modifierId) {
            const entity = findEntityById(entityId);
            if (!entity) return;

            const modNode = config.nodes.find(n => n.id === modifierId);
            if (!modNode) return;

            // Show warning for threshold modifiers
            const trigger = modNode.config?.trigger;
            const triggerText = trigger ? `${trigger.target} ${trigger.operator || '<='} ${trigger.value}` : '';

            if (!confirm(`This modifier normally auto-triggers when ${triggerText}.\n\nForce apply anyway?`)) {
                return;
            }

            if (!entity.modifiers) entity.modifiers = [];

            entity.modifiers.push({
                id: modifierId,
                name: modNode.name,
                threshold: true,
                forced: true,
                trigger: triggerText
            });

            recalculateManagedEntity(entity);
            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
            showToast(`Force applied: ${modNode.name}`);
        }

        function removeModifierFromEntity(entityId, modifierId) {
            const entity = findEntityById(entityId);
            if (!entity) return;

            entity.modifiers = (entity.modifiers || []).filter(m => (m.id || m) !== modifierId);

            recalculateManagedEntity(entity);
            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
            showToast('Modifier removed');
        }

        // Modifier menu state
        let addModifierMenuVisible = false;
        let addModifierTargetEntityId = null;
        let addModifierIsPreview = false;

        function showModifierMenu(event, entityId, isPreview = false) {
            event.stopPropagation();

            // Close any existing menu
            closeAddModifierMenu();

            const entity = isPreview ? previewEntities[entityId] : findEntityById(entityId);
            if (!entity) return;

            addModifierTargetEntityId = entityId;
            addModifierIsPreview = isPreview;
            addModifierMenuVisible = true;

            const allModifiers = config.nodes.filter(n => n.type === 'modifier');

            if (allModifiers.length === 0) {
                showToast('No modifiers defined in config', 'info');
                return;
            }

            const activeModIds = new Set((entity.modifiers || []).map(m => m.id || m));

            // Categorize modifiers
            const activeModifiers = [];
            const availableModifiers = [];
            const thresholdModifiers = [];
            const ineligibleModifiers = [];

            allModifiers.forEach(mod => {
                const isActive = activeModIds.has(mod.id);
                const isThreshold = mod.config?.triggerType === 'threshold';
                const eligibility = checkModifierEligibility(entity, mod);

                if (isActive) {
                    activeModifiers.push({ ...mod, isActive: true });
                } else if (isThreshold) {
                    const trigger = mod.config?.trigger;
                    const triggerText = trigger ? `${trigger.target} ${trigger.operator || '<='} ${trigger.value}` : '';
                    thresholdModifiers.push({ ...mod, triggerText, eligibility });
                } else if (!eligibility.eligible) {
                    ineligibleModifiers.push({ ...mod, eligibility });
                } else {
                    availableModifiers.push({ ...mod, eligibility });
                }
            });

            // Build menu HTML
            const menuHtml = `
                <div class="add-modifier-menu" id="addModifierMenu">
                    <div class="add-modifier-menu-header">â—† Add Modifier</div>

                    ${activeModifiers.length > 0 ? `
                        <div class="add-modifier-category">
                            <div class="add-modifier-category-title"><span class="cat-icon">â—</span> Active</div>
                            ${activeModifiers.map(mod => `
                                <div class="add-modifier-item already-active">
                                    <span class="mod-icon">â—†</span>
                                    <span class="mod-name">${mod.name}</span>
                                    <span class="mod-status">applied</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${availableModifiers.length > 0 ? `
                        <div class="add-modifier-category">
                            <div class="add-modifier-category-title"><span class="cat-icon">â—‹</span> Available</div>
                            ${availableModifiers.map(mod => `
                                <div class="add-modifier-item" onclick="applyModifierFromMenu('${entityId}', '${mod.id}', ${isPreview})">
                                    <span class="mod-icon">â—‡</span>
                                    <span class="mod-name">${mod.name}</span>
                                    <span class="mod-status">+ add</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${thresholdModifiers.length > 0 ? `
                        <div class="add-modifier-category">
                            <div class="add-modifier-category-title"><span class="cat-icon">âš¡</span> Threshold (Auto)</div>
                            ${thresholdModifiers.map(mod => `
                                <div class="add-modifier-item threshold">
                                    <span class="mod-icon">âš¡</span>
                                    <div style="flex: 1;">
                                        <span class="mod-name">${mod.name}</span>
                                        <span class="mod-trigger">${mod.triggerText || 'Auto-triggered'}</span>
                                    </div>
                                    <button class="force-btn" onclick="event.stopPropagation(); forceApplyModifierFromMenu('${entityId}', '${mod.id}', ${isPreview})">Force</button>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${ineligibleModifiers.length > 0 ? `
                        <div class="add-modifier-category">
                            <div class="add-modifier-category-title"><span class="cat-icon">ðŸ”’</span> Ineligible</div>
                            ${ineligibleModifiers.map(mod => `
                                <div class="add-modifier-item disabled" title="${mod.eligibility.reason || 'Blocked'}">
                                    <span class="mod-icon">ðŸ”’</span>
                                    <span class="mod-name">${mod.name}</span>
                                    <span class="mod-status">${mod.eligibility.reason || 'blocked'}</span>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${activeModifiers.length === 0 && availableModifiers.length === 0 && thresholdModifiers.length === 0 && ineligibleModifiers.length === 0 ? `
                        <div class="add-modifier-empty">No modifiers available</div>
                    ` : ''}
                </div>
            `;

            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', menuHtml);

            // Position menu near the button
            const menu = document.getElementById('addModifierMenu');
            const rect = event.target.getBoundingClientRect();
            menu.style.left = Math.min(rect.left, window.innerWidth - menu.offsetWidth - 10) + 'px';
            menu.style.top = Math.min(rect.bottom + 5, window.innerHeight - menu.offsetHeight - 10) + 'px';

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', closeAddModifierMenu);
            }, 0);
        }

        function closeAddModifierMenu() {
            const menu = document.getElementById('addModifierMenu');
            if (menu) menu.remove();
            addModifierMenuVisible = false;
            addModifierTargetEntityId = null;
            addModifierIsPreview = false;
            document.removeEventListener('click', closeAddModifierMenu);
        }

        function applyModifierFromMenu(entityId, modifierId, isPreview) {
            closeAddModifierMenu();

            if (isPreview) {
                addModifierToPreviewEntity(entityId, modifierId);
            } else {
                applyModifierToEntity(entityId, modifierId);
            }
        }

        function forceApplyModifierFromMenu(entityId, modifierId, isPreview) {
            closeAddModifierMenu();

            if (isPreview) {
                // For preview entities, just apply it directly
                addModifierToPreviewEntity(entityId, modifierId, true);
            } else {
                forceApplyModifier(entityId, modifierId);
            }
        }

        // ========================================
        // TRAIT ADD MENU (for managed entities)
        // ========================================
        // Note: Uses existing addTraitMenuVisible and closeAddTraitMenu from preview system

        function showTraitMenu(event, entityId) {
            event.stopPropagation();

            // Close any existing menus
            closeAddTraitMenu();
            closeAddModifierMenu();

            const entity = findEntityById(entityId);
            if (!entity) return;

            // Get all traits/items grouped by layer
            const layers = config.nodes.filter(n => n.type === 'layer')
                .sort((a, b) => (a.config?.order ?? 0) - (b.config?.order ?? 0));

            const allTraits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');

            if (allTraits.length === 0) {
                showToast('No traits defined in config');
                return;
            }

            // Get active trait IDs from entity
            const activeTraitIds = new Set((entity.traits || []).map(t => t.id || t));

            // Build menu HTML grouped by layer
            let menuHtml = `
                <div class="add-trait-menu" id="addTraitMenu">
                    <div class="add-trait-menu-header">â—† Add Trait</div>
            `;

            layers.forEach(layer => {
                const layerTraits = allTraits.filter(t => t.config?.layerId === layer.id);
                if (layerTraits.length === 0) return;

                menuHtml += `
                    <div class="add-trait-category">
                        <div class="add-trait-category-title"><span class="cat-icon" style="color: var(--node-layer);">â—ˆ</span> ${layer.name}</div>
                `;

                layerTraits.forEach(trait => {
                    const isActive = activeTraitIds.has(trait.id);
                    const isThreshold = trait.config?.selection?.mode === 'threshold';

                    if (isActive) {
                        menuHtml += `
                            <div class="add-trait-item already-active">
                                <span class="trait-icon">â—</span>
                                <span class="trait-name">${trait.name}</span>
                                <span class="trait-status">active</span>
                            </div>
                        `;
                    } else if (isThreshold) {
                        const trigger = trait.config?.selection?.threshold;
                        const triggerText = trigger ? `${trigger.target} ${trigger.operator || '<='} ${trigger.value}` : 'Auto-triggered';
                        menuHtml += `
                            <div class="add-trait-item threshold" onclick="applyTraitFromMenu('${entityId}', '${trait.id}')">
                                <span class="trait-icon">âš¡</span>
                                <span class="trait-name">${trait.name}</span>
                                <span class="trait-trigger">${triggerText}</span>
                            </div>
                        `;
                    } else {
                        menuHtml += `
                            <div class="add-trait-item" onclick="applyTraitFromMenu('${entityId}', '${trait.id}')">
                                <span class="trait-icon">â—‹</span>
                                <span class="trait-name">${trait.name}</span>
                                <span class="trait-status">+ add</span>
                            </div>
                        `;
                    }
                });

                menuHtml += `</div>`;
            });

            // Also show traits not in any layer
            const orphanTraits = allTraits.filter(t => !t.config?.layerId);
            if (orphanTraits.length > 0) {
                menuHtml += `
                    <div class="add-trait-category">
                        <div class="add-trait-category-title"><span class="cat-icon">â—‡</span> Other</div>
                `;
                orphanTraits.forEach(trait => {
                    const isActive = activeTraitIds.has(trait.id);
                    menuHtml += isActive ? `
                        <div class="add-trait-item already-active">
                            <span class="trait-icon">â—</span>
                            <span class="trait-name">${trait.name}</span>
                            <span class="trait-status">active</span>
                        </div>
                    ` : `
                        <div class="add-trait-item" onclick="applyTraitFromMenu('${entityId}', '${trait.id}')">
                            <span class="trait-icon">â—‹</span>
                            <span class="trait-name">${trait.name}</span>
                            <span class="trait-status">+ add</span>
                        </div>
                    `;
                });
                menuHtml += `</div>`;
            }

            menuHtml += `</div>`;

            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', menuHtml);

            // Position menu near the button
            const menu = document.getElementById('addTraitMenu');
            const rect = event.target.getBoundingClientRect();
            menu.style.left = Math.min(rect.left, window.innerWidth - menu.offsetWidth - 10) + 'px';
            menu.style.top = Math.min(rect.bottom + 5, window.innerHeight - menu.offsetHeight - 10) + 'px';

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', closeAddTraitMenu);
            }, 0);
        }

        function closeAddTraitMenu() {
            const menu = document.getElementById('addTraitMenu');
            if (menu) menu.remove();
            addTraitMenuVisible = false;
            addTraitTargetEntityId = null;
            document.removeEventListener('click', closeAddTraitMenu);
        }

        function applyTraitFromMenu(entityId, traitId) {
            closeAddTraitMenu();

            const entity = findEntityById(entityId);
            if (!entity) return;

            const traitNode = config.nodes.find(n => n.id === traitId);
            if (!traitNode) return;

            if (!entity.traits) entity.traits = [];

            // Check if already active
            if (entity.traits.some(t => (t.id || t) === traitId)) {
                showToast('Trait already active');
                return;
            }

            // Get layer info
            const layer = config.nodes.find(n => n.id === traitNode.config?.layerId);

            entity.traits.push({
                id: traitId,
                name: traitNode.name,
                layer: layer?.name || 'Unknown',
                layerId: layer?.id,
                active: true,
                manual: true
            });

            // Recalculate compounds
            recalculateManagedEntityCompounds(entity);

            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
            showToast(`Added: ${traitNode.name}`);
        }

        function addModifierToPreviewEntity(entityIndex, modifierId, forced = false) {
            const entity = previewEntities[entityIndex];
            if (!entity) return;

            const modNode = config.nodes.find(n => n.id === modifierId);
            if (!modNode) return;

            if (!entity.modifiers) entity.modifiers = [];

            // Check if already active
            if (entity.modifiers.some(m => (m.id || m) === modifierId)) {
                showToast('Modifier already active', 'warning');
                return;
            }

            // Show warning for threshold modifiers
            if (forced && modNode.config?.triggerType === 'threshold') {
                const trigger = modNode.config?.trigger;
                const triggerText = trigger ? `${trigger.target} ${trigger.operator || '<='} ${trigger.value}` : '';
                if (!confirm(`This modifier normally auto-triggers when ${triggerText}.\n\nForce apply anyway?`)) {
                    return;
                }
            }

            entity.modifiers.push({
                id: modifierId,
                name: modNode.name,
                manual: !forced,
                forced: forced
            });

            recalculatePreviewEntity(entity);
            renderPreviewEntities();
            showToast(`Applied: ${modNode.name}`);
        }

        function renderCompoundsSection(entity) {
            const allCompounds = config.nodes.filter(n => n.type === 'compound');

            if (allCompounds.length === 0) {
                return '<div class="compounds-empty">No compounds defined in config</div>';
            }

            // Get active compounds only (dropdown handles adding)
            const activeCompounds = (entity.compounds || []).map(c => {
                const compoundNode = allCompounds.find(n => n.id === c.id);
                return {
                    id: c.id,
                    name: compoundNode?.name || c.name || c.id,
                    forced: c.forced,
                    requires: c.requires || []
                };
            });

            if (activeCompounds.length === 0) {
                return '<div class="compounds-empty">No active compounds</div>';
            }

            return `
                <div class="compounds-list">
                    ${activeCompounds.map(cmp => `
                        <div class="compound-item active">
                            <div class="compound-header">
                                <span class="compound-icon" style="color: var(--node-compound);">â—†</span>
                                <span class="compound-name">${cmp.name}</span>
                                ${cmp.forced ? '<span class="compound-type" title="Force-activated" style="color: var(--accent-gold); font-size: 0.7rem;">âš¡</span>' : ''}
                                <button class="btn btn-xs btn-danger" onclick="forceDeactivateCompound('${entity.id}', '${cmp.id}')" title="Deactivate" style="margin-left: auto;">âœ•</button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function forceActivateCompound(entityId, compoundId) {
            const entity = findEntityById(entityId);
            if (!entity) return;

            const compound = config.nodes.find(n => n.id === compoundId);
            if (!compound) return;

            if (!confirm(`Force activate "${compound.name}"?\n\nThis bypasses normal requirement checks.`)) {
                return;
            }

            if (!entity.compounds) entity.compounds = [];

            entity.compounds.push({
                id: compoundId,
                name: compound.name,
                forced: true,
                requires: compound.config?.requires?.map(r => r.item || r.trait || r.modifier) || []
            });

            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
            showToast(`Force activated: ${compound.name}`);
        }

        function forceDeactivateCompound(entityId, compoundId) {
            const entity = findEntityById(entityId);
            if (!entity) return;

            entity.compounds = (entity.compounds || []).filter(c => c.id !== compoundId);

            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
            showToast('Compound deactivated');
        }

        // Compound menu state
        let addCompoundMenuVisible = false;
        let addCompoundTargetEntityId = null;
        let addCompoundIsPreview = false;

        function showCompoundMenu(event, entityId, isPreview = false) {
            event.stopPropagation();

            // Close any existing menu
            closeCompoundMenu();

            const entity = isPreview ? previewEntities[entityId] : findEntityById(entityId);
            if (!entity) return;

            addCompoundTargetEntityId = entityId;
            addCompoundIsPreview = isPreview;
            addCompoundMenuVisible = true;

            const allCompounds = config.nodes.filter(n => n.type === 'compound');

            if (allCompounds.length === 0) {
                showToast('No compounds defined in config', 'info');
                return;
            }

            const activeCompoundIds = new Set((entity.compounds || []).map(c => c.id));
            const activeTraitIds = new Set((entity.traits || []).filter(t => t.active !== false).map(t => t.id));
            const activeModifierIds = new Set((entity.modifiers || []).map(m => m.id || m));

            // Categorize compounds
            const activeCompounds = [];
            const readyCompounds = [];
            const unavailableCompounds = [];

            allCompounds.forEach(compound => {
                const isActive = activeCompoundIds.has(compound.id);
                const requires = compound.config?.requires || [];
                const logic = compound.config?.requirementLogic || 'all';

                // Check each requirement
                const reqStatus = requires.map(req => {
                    const reqId = req.item || req.trait || req.modifier;
                    const isMet = activeTraitIds.has(reqId) || activeModifierIds.has(reqId);
                    const reqNode = config.nodes.find(n => n.id === reqId);
                    return { id: reqId, name: reqNode?.name || reqId, met: isMet };
                });

                const allMet = reqStatus.every(r => r.met);
                const anyMet = reqStatus.some(r => r.met);
                const requirementsMet = logic === 'all' ? allMet : anyMet;

                if (isActive) {
                    activeCompounds.push({ ...compound, reqStatus, logic });
                } else if (requirementsMet) {
                    readyCompounds.push({ ...compound, reqStatus, logic });
                } else {
                    unavailableCompounds.push({ ...compound, reqStatus, logic });
                }
            });

            // Build menu HTML
            const menuHtml = `
                <div class="add-compound-menu" id="addCompoundMenu">
                    <div class="add-compound-menu-header">â—† Add Compound</div>

                    ${activeCompounds.length > 0 ? `
                        <div class="add-compound-category">
                            <div class="add-compound-category-title"><span>â—</span> Active</div>
                            ${activeCompounds.map(cmp => `
                                <div class="add-compound-item already-active">
                                    <div class="add-compound-item-header">
                                        <span class="cmp-icon" style="color: var(--node-compound);">â—†</span>
                                        <span class="cmp-name">${cmp.name}</span>
                                        <span class="cmp-status">active</span>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${readyCompounds.length > 0 ? `
                        <div class="add-compound-category">
                            <div class="add-compound-category-title"><span>âœ“</span> Ready</div>
                            ${readyCompounds.map(cmp => `
                                <div class="add-compound-item ready" onclick="activateCompoundFromMenu('${entityId}', '${cmp.id}', ${isPreview})">
                                    <div class="add-compound-item-header">
                                        <span class="cmp-icon" style="color: var(--accent-success);">â—‡</span>
                                        <span class="cmp-name">${cmp.name}</span>
                                        <span class="cmp-status">+ activate</span>
                                    </div>
                                    <div class="cmp-reqs">
                                        ${cmp.reqStatus.map(r => `<span class="cmp-req met">âœ“ ${r.name}</span>`).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${unavailableCompounds.length > 0 ? `
                        <div class="add-compound-category">
                            <div class="add-compound-category-title"><span>â—‹</span> Unavailable</div>
                            ${unavailableCompounds.map(cmp => `
                                <div class="add-compound-item disabled">
                                    <div class="add-compound-item-header">
                                        <span class="cmp-icon">â—‡</span>
                                        <span class="cmp-name">${cmp.name}</span>
                                        <button class="force-btn" onclick="event.stopPropagation(); forceActivateCompoundFromMenu('${entityId}', '${cmp.id}', ${isPreview})">Force</button>
                                    </div>
                                    <div class="cmp-reqs">
                                        ${cmp.reqStatus.map(r => `<span class="cmp-req ${r.met ? 'met' : 'unmet'}">${r.met ? 'âœ“' : 'â—‹'} ${r.name}</span>`).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}

                    ${activeCompounds.length === 0 && readyCompounds.length === 0 && unavailableCompounds.length === 0 ? `
                        <div class="add-compound-empty">No compounds available</div>
                    ` : ''}
                </div>
            `;

            // Add to DOM
            document.body.insertAdjacentHTML('beforeend', menuHtml);

            // Position menu near the button
            const menu = document.getElementById('addCompoundMenu');
            const rect = event.target.getBoundingClientRect();
            menu.style.left = Math.min(rect.left, window.innerWidth - menu.offsetWidth - 10) + 'px';
            menu.style.top = Math.min(rect.bottom + 5, window.innerHeight - menu.offsetHeight - 10) + 'px';

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', closeCompoundMenu);
            }, 0);
        }

        function closeCompoundMenu() {
            const menu = document.getElementById('addCompoundMenu');
            if (menu) menu.remove();
            addCompoundMenuVisible = false;
            addCompoundTargetEntityId = null;
            addCompoundIsPreview = false;
            document.removeEventListener('click', closeCompoundMenu);
        }

        function activateCompoundFromMenu(entityId, compoundId, isPreview) {
            closeCompoundMenu();

            if (isPreview) {
                activateCompoundOnPreviewEntity(entityId, compoundId);
            } else {
                activateCompoundOnEntity(entityId, compoundId);
            }
        }

        function forceActivateCompoundFromMenu(entityId, compoundId, isPreview) {
            closeCompoundMenu();

            if (isPreview) {
                activateCompoundOnPreviewEntity(entityId, compoundId, true);
            } else {
                forceActivateCompound(entityId, compoundId);
            }
        }

        function activateCompoundOnEntity(entityId, compoundId) {
            const entity = findEntityById(entityId);
            if (!entity) return;

            const compound = config.nodes.find(n => n.id === compoundId);
            if (!compound) return;

            if (!entity.compounds) entity.compounds = [];

            // Check if already active
            if (entity.compounds.some(c => c.id === compoundId)) {
                showToast('Compound already active', 'warning');
                return;
            }

            entity.compounds.push({
                id: compoundId,
                name: compound.name,
                requires: compound.config?.requires?.map(r => r.item || r.trait || r.modifier) || []
            });

            saveEntitiesToStorage();
            renderEntitiesView(document.getElementById('viewContent'));
            showToast(`Activated: ${compound.name}`);
        }

        function activateCompoundOnPreviewEntity(entityIndex, compoundId, forced = false) {
            const entity = previewEntities[entityIndex];
            if (!entity) return;

            const compound = config.nodes.find(n => n.id === compoundId);
            if (!compound) return;

            if (!entity.compounds) entity.compounds = [];

            // Check if already active
            if (entity.compounds.some(c => c.id === compoundId)) {
                showToast('Compound already active', 'warning');
                return;
            }

            // Show warning for force activation
            if (forced) {
                if (!confirm(`Force activate "${compound.name}"?\n\nThis bypasses normal requirement checks.`)) {
                    return;
                }
            }

            entity.compounds.push({
                id: compoundId,
                name: compound.name,
                forced: forced,
                requires: compound.config?.requires?.map(r => r.item || r.trait || r.modifier) || []
            });

            recalculatePreviewEntity(entity);
            renderPreviewEntities();
            showToast(`${forced ? 'Force activated' : 'Activated'}: ${compound.name}`);
        }

        // ========================================
        // SAVE ENTITY AS PRESET
        // ========================================

        let saveAsPresetEntityId = null;

        function openSaveAsPresetModal(entityId) {
            const entity = findEntityById(entityId);
            if (!entity) {
                showToast('Entity not found', 'error');
                return;
            }

            saveAsPresetEntityId = entityId;
            const groups = config.presetGroups || [];

            // Build attributes overrides from entity
            const attributeOverrides = {};
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            attributes.forEach(attr => {
                const value = entity.attributes?.[attr.id];
                if (value !== undefined) {
                    attributeOverrides[attr.id] = { value, name: attr.name };
                }
            });

            // Build forced traits from active traits
            const activeTraitIds = (entity.traits || [])
                .filter(t => t.active !== false)
                .map(t => t.id);

            // Build modal content
            const modalContent = `
                <div style="max-height: 70vh; overflow-y: auto;">
                    <div class="form-group">
                        <label>Preset Name</label>
                        <input type="text" id="presetName" class="form-control"
                               value="${entity.name || 'New Preset'}" placeholder="Enter preset name">
                    </div>

                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="presetDescription" class="form-control"
                                  placeholder="Optional description" rows="2"></textarea>
                    </div>

                    <div class="form-group">
                        <label>Group</label>
                        <select id="presetGroup" class="form-control">
                            <option value="">No Group</option>
                            ${groups.map(g => `<option value="${g.id}">${g.name}</option>`).join('')}
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Attribute Overrides</label>
                        <div class="help-text" style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                            Check attributes to include their current values in the preset
                        </div>
                        <div style="max-height: 150px; overflow-y: auto; background: var(--bg-input); padding: 0.5rem; border-radius: 4px;">
                            ${Object.entries(attributeOverrides).map(([id, data]) => `
                                <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem;">
                                    <input type="checkbox" class="preset-attr-check" data-id="${id}" checked>
                                    <span>${data.name}: ${data.value}</span>
                                </label>
                            `).join('')}
                            ${Object.keys(attributeOverrides).length === 0 ? '<div style="color: var(--text-muted); font-style: italic;">No attributes</div>' : ''}
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Forced Traits</label>
                        <div class="help-text" style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                            These traits will always be active when spawning from this preset
                        </div>
                        <div style="max-height: 150px; overflow-y: auto; background: var(--bg-input); padding: 0.5rem; border-radius: 4px;">
                            ${activeTraitIds.map(id => {
                                const trait = config.nodes.find(n => n.id === id);
                                return trait ? `
                                    <label style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem;">
                                        <input type="checkbox" class="preset-trait-check" data-id="${id}" checked>
                                        <span>${trait.name}</span>
                                    </label>
                                ` : '';
                            }).join('')}
                            ${activeTraitIds.length === 0 ? '<div style="color: var(--text-muted); font-style: italic;">No active traits</div>' : ''}
                        </div>
                    </div>
                </div>
            `;

            showModal('Save Entity as Preset', modalContent, [
                { label: 'Cancel', class: 'btn-secondary', action: 'closeModal()' },
                { label: 'Save Preset', class: 'btn-primary', action: 'saveEntityAsPreset()' }
            ]);
        }

        function saveEntityAsPreset() {
            const entity = findEntityById(saveAsPresetEntityId);
            if (!entity) {
                showToast('Entity not found', 'error');
                closeModal();
                return;
            }

            const name = document.getElementById('presetName').value.trim();
            if (!name) {
                showToast('Please enter a preset name', 'error');
                return;
            }

            const description = document.getElementById('presetDescription').value.trim();
            const group = document.getElementById('presetGroup').value || null;

            // Gather checked attributes
            const attributeOverrides = {};
            document.querySelectorAll('.preset-attr-check:checked').forEach(cb => {
                const attrId = cb.dataset.id;
                attributeOverrides[attrId] = entity.attributes?.[attrId];
            });

            // Gather checked traits
            const forceTraits = [];
            document.querySelectorAll('.preset-trait-check:checked').forEach(cb => {
                forceTraits.push(cb.dataset.id);
            });

            // Generate preset ID
            const presetId = 'preset_' + name.toLowerCase().replace(/[^a-z0-9]+/g, '_') + '_' + Date.now().toString(36);

            // Create preset object
            const preset = {
                id: presetId,
                name,
                description: description || undefined,
                group: group || undefined,
                attributeOverrides: Object.keys(attributeOverrides).length > 0 ? attributeOverrides : undefined,
                forceTraits: forceTraits.length > 0 ? forceTraits : undefined,
                createdAt: Date.now(),
                fromEntity: entity.id
            };

            // Add to config
            if (!config.presets) config.presets = [];
            config.presets.push(preset);

            closeModal();
            saveAsPresetEntityId = null;
            showToast(`Preset "${name}" created!`);

            // Switch to Presets section if we're in Persistence/Entities view
            if (currentView === 'persistence' || currentView === 'entities') {
                persistenceSection = 'presets';
                renderPersistenceView(document.getElementById('viewContent'));
            }
        }

        // ========================================
        // VALIDATE VIEW
        // ========================================

        let validationResults = null;
        let quickSpawnResults = null;
        let dismissedIssues = new Set(); // Persisted dismissed issues

        // Try to load dismissed issues from localStorage
        try {
            const saved = localStorage.getItem(`dismissedIssues_${config.id || 'default'}`);
            if (saved) dismissedIssues = new Set(JSON.parse(saved));
        } catch (e) { /* ignore */ }

        function saveDismissedIssues() {
            try {
                localStorage.setItem(`dismissedIssues_${config.id || 'default'}`, JSON.stringify([...dismissedIssues]));
            } catch (e) { /* ignore */ }
        }

        function dismissIssue(issueId) {
            dismissedIssues.add(issueId);
            saveDismissedIssues();
            runValidation(); // Re-run to update display
        }

        function restoreIssue(issueId) {
            dismissedIssues.delete(issueId);
            saveDismissedIssues();
            runValidation();
        }

        function restoreAllIssues() {
            dismissedIssues.clear();
            saveDismissedIssues();
            runValidation();
        }

        // ========================================
        // CODE REFERENCE VIEW
        // ========================================

        function renderCodeView(container) {
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');
            const compounds = config.nodes.filter(n => n.type === 'compound');

            container.innerHTML = `
                <div class="code-view" style="padding: 1rem; max-width: 1000px;">
                    <div style="margin-bottom: 1.5rem;">
                        <h2 style="color: var(--copper); margin: 0 0 0.5rem 0;">Code Reference</h2>
                        <p style="color: var(--text-secondary); margin: 0;">Copy-paste these snippets into your game code. Click any snippet to copy.</p>
                    </div>

                    <!-- Quick Start -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--text-primary); margin: 0 0 0.75rem 0; font-size: 1rem;">ðŸš€ Quick Start</h3>
                        <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">
                            <div class="snippet-header">Initialize Engine</div>
                            <pre class="snippet-code">// Load your config and create engine
const engine = new SpawnEngine(myConfig);

// Spawn an entity
const entity = engine.spawn();
console.log(entity.id, entity.attributes);

// Start ticking (for variable changes)
engine.startAutoTick(); // or call engine.tick(entityId) manually</pre>
                        </div>
                    </div>

                    ${modifiers.length > 0 ? `
                    <!-- Modifiers Section -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--node-modifier); margin: 0 0 0.5rem 0; font-size: 1rem;">âš¡ Modifiers (Status Effects)</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0 0 0.75rem 0;">
                            Modifiers are NOT automatic - call these functions from your game when events happen (enemy attacks, item use, etc).
                        </p>
                        <div class="code-snippets-grid" style="display: grid; gap: 0.75rem;">
                            ${modifiers.map(mod => {
                                const bindings = mod.config?.tickBindings || [];
                                const bindingInfo = bindings.length > 0
                                    ? bindings.map(b => {
                                        const ts = tickSystems.find(t => t.id === b.tickSystemId);
                                        return ts ? `${b.duration} ${ts.config?.tickUnit?.label || 'tick'}s (${ts.name})` : '';
                                    }).filter(Boolean).join(', ')
                                    : '';
                                return `
                                <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">
                                    <div class="snippet-header">${mod.name}${bindingInfo ? ` <span style="font-weight: normal; color: var(--node-ticksystem); font-size: 0.75rem;">â± ${bindingInfo}</span>` : ''}</div>
                                    <pre class="snippet-code">// Apply "${mod.name}"
engine.applyModifier(entity.id, '${mod.id}');

// Remove "${mod.name}"
engine.removeModifier(entity.id, '${mod.id}');
${bindings.length > 0 ? `
// Check remaining duration
const remaining = engine.getModifierDuration(entity.id, '${mod.id}');` : ''}</pre>
                                </div>
                            `}).join('')}
                        </div>
                    </div>
                    ` : ''}

                    ${variables.length > 0 ? `
                    <!-- Variables Section -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--node-variable); margin: 0 0 0.5rem 0; font-size: 1rem;">ðŸ“Š Variables</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0 0 0.75rem 0;">
                            Variables auto-tick if rate â‰  0, but you can also modify them directly from game events.
                        </p>
                        <div class="code-snippets-grid" style="display: grid; gap: 0.75rem;">
                            ${variables.map(v => `
                                <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">
                                    <div class="snippet-header">${v.name}</div>
                                    <pre class="snippet-code">// Modify "${v.name}" (add/subtract)
engine.modifyVariable(entity.id, '${v.id}', -20); // subtract 20
engine.modifyVariable(entity.id, '${v.id}', +10); // add 10

// Set "${v.name}" to exact value
engine.setVariable(entity.id, '${v.id}', 50);

// Get current value
const ${v.id.replace(/^var_/, '')} = engine.getVariable(entity.id, '${v.id}');</pre>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}

                    ${traits.length > 0 ? `
                    <!-- Traits Section -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--node-trait); margin: 0 0 0.5rem 0; font-size: 1rem;">ðŸ·ï¸ Traits</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0 0 0.75rem 0;">
                            Traits are selected at spawn, but you can toggle them manually if needed.
                        </p>
                        <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">
                            <div class="snippet-header">Trait Operations</div>
                            <pre class="snippet-code">// Check if entity has a trait
const hasWarrior = engine.hasTrait(entity.id, 'trait_warrior');

// Get all active traits
const traits = engine.getActiveTraits(entity.id);

// Force activate/deactivate a trait
engine.activateTrait(entity.id, 'trait_id');
engine.deactivateTrait(entity.id, 'trait_id');</pre>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                            <strong>Your traits:</strong> ${traits.map(t => `<code>${t.id}</code>`).join(', ')}
                        </div>
                    </div>
                    ` : ''}

                    ${compounds.length > 0 ? `
                    <!-- Compounds Section -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--node-compound); margin: 0 0 0.5rem 0; font-size: 1rem;">ðŸ”® Compounds (Emergent States)</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0 0 0.75rem 0;">
                            Compounds activate automatically when their requirements are met. Use events to react to them.
                        </p>
                        <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer; margin-bottom: 0.75rem;">
                            <div class="snippet-header">Compound Operations</div>
                            <pre class="snippet-code">// Check if compound is active
const isHangry = engine.hasCompound(entity.id, 'comp_hangry');

// Get all active compounds
const activeCompounds = engine.getActiveCompounds(entity.id);

// Listen for compound changes
engine.on('compoundActivated', ({ entityId, compoundId }) => {
    if (compoundId === 'comp_berserk') {
        triggerBerserkBehavior(entityId);
    }
});
engine.on('compoundDeactivated', ({ entityId, compoundId }) => {
    clearSpecialBehavior(entityId, compoundId);
});</pre>
                        </div>
                        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                            <strong>Your compounds:</strong> ${compounds.map(c => `<code>${c.id}</code>`).join(', ')}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Events Section -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--accent-primary); margin: 0 0 0.5rem 0; font-size: 1rem;">ðŸ“¡ Events</h3>
                        <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0 0 0.75rem 0;">
                            Listen for state changes to update your game UI or trigger behaviors.
                        </p>
                        <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">
                            <div class="snippet-header">Event Listeners</div>
                            <pre class="snippet-code">// Variable changed (hunger depleted, rage built up, etc)
engine.on('variableChanged', ({ entityId, varId, oldValue, newValue }) => {
    console.log(varId + ': ' + oldValue + ' â†’ ' + newValue);
    updateHealthBar(entityId, newValue); // your UI code
});

// Modifier applied/removed
engine.on('modifierApplied', ({ entityId, modifierId }) => {
    showStatusIcon(entityId, modifierId); // your UI code
});
engine.on('modifierRemoved', ({ entityId, modifierId }) => {
    hideStatusIcon(entityId, modifierId);
});

// Compound activated (emergent states like "Hangry")
engine.on('compoundActivated', ({ entityId, compoundId }) => {
    triggerSpecialBehavior(entityId, compoundId); // your AI code
});

// Tick system events
engine.on('tickAdvanced', ({ entityId, tickSystemId, currentTick }) => {
    console.log(tickSystemId + ' advanced to tick ' + currentTick);
});
engine.on('tickSystemStarted', ({ entityId, tickSystemId }) => {
    console.log(tickSystemId + ' started');
});
engine.on('tickSystemStopped', ({ entityId, tickSystemId }) => {
    console.log(tickSystemId + ' stopped');
});</pre>
                        </div>
                    </div>

                    ${renderTickSystemsCodeSection(tickSystems, modifiers)}

                    <!-- State Queries Section -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--text-primary); margin: 0 0 0.5rem 0; font-size: 1rem;">ðŸ” State Queries</h3>
                        <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">
                            <div class="snippet-header">Get Entity State</div>
                            <pre class="snippet-code">// Get full state snapshot
const state = engine.getState(entity.id);
console.log(state.attributes);      // { attr_strength: 7, ... }
console.log(state.variables);       // { var_health: 85, ... }
console.log(state.activeTraits);    // ['trait_warrior', ...]
console.log(state.activeModifiers); // ['mod_poisoned', ...]
console.log(state.activeCompounds); // ['comp_berserk', ...]

// Check specific states
const health = engine.getVariable(entity.id, 'var_health');
const isPoisoned = engine.hasModifier(entity.id, 'mod_poisoned');
const isBerserk = engine.hasCompound(entity.id, 'comp_berserk');</pre>
                        </div>
                    </div>

                    <!-- Save/Load Section -->
                    <div class="code-section" style="margin-bottom: 2rem;">
                        <h3 style="color: var(--text-primary); margin: 0 0 0.5rem 0; font-size: 1rem;">ðŸ’¾ Save & Load</h3>
                        <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">
                            <div class="snippet-header">Persist Entity State</div>
                            <pre class="snippet-code">// Save all entities to localStorage
const saveData = engine.export();
localStorage.setItem('gameEntities', JSON.stringify(saveData));

// Load entities from save
const loaded = JSON.parse(localStorage.getItem('gameEntities'));
if (loaded) engine.import(loaded);</pre>
                        </div>
                    </div>
                </div>

                <style>
                    .code-snippet-card {
                        background: var(--bg-card);
                        border: 1px solid var(--border-color);
                        border-radius: 6px;
                        overflow: hidden;
                        transition: border-color 0.2s;
                    }
                    .code-snippet-card:hover {
                        border-color: var(--accent-primary);
                    }
                    .code-snippet-card:active {
                        background: var(--bg-hover);
                    }
                    .snippet-header {
                        padding: 0.5rem 0.75rem;
                        background: var(--bg-tertiary);
                        border-bottom: 1px solid var(--border-color);
                        font-weight: 600;
                        font-size: 0.85rem;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }
                    .snippet-header::after {
                        content: 'ðŸ“‹ Click to copy';
                        font-size: 0.75rem;
                        font-weight: normal;
                        color: var(--text-secondary);
                    }
                    .snippet-code {
                        margin: 0;
                        padding: 0.75rem;
                        font-family: 'Consolas', 'Monaco', monospace;
                        font-size: 0.8rem;
                        line-height: 1.4;
                        overflow-x: auto;
                        white-space: pre;
                        color: var(--text-primary);
                    }
                    .code-snippet-card.copied .snippet-header::after {
                        content: 'âœ“ Copied!';
                        color: var(--accent-success);
                    }
                </style>
            `;
        }

        function renderTickSystemsCodeSection(tickSystems, modifiers) {
            if (tickSystems.length === 0) return '';

            const tickSystemCards = tickSystems.map(ts => {
                const tickLabel = ts.config?.tickUnit?.label || 'tick';
                const isManual = ts.config?.tickUnit?.type === 'manual';
                const isTimed = ts.config?.tickUnit?.type === 'timed';
                const interval = ts.config?.tickUnit?.value || 1000;

                // Find modifiers bound to this tick system
                const boundMods = modifiers.filter(m =>
                    m.config?.tickBindings?.some(b => b.tickSystemId === ts.id)
                );

                let codeContent = '// "' + ts.name + '" - ' + (ts.description || 'Tick system') + '\n';

                if (isManual) {
                    codeContent += '// Manual system: advance on game events\n';
                    codeContent += "engine.advanceTick(entity.id, '" + ts.id + "'); // +1 " + tickLabel + '\n\n';
                    codeContent += '// Example: advance on combat action\n';
                    codeContent += 'function onPlayerAttack() {\n';
                    codeContent += "    engine.advanceTick(entity.id, '" + ts.id + "');\n";
                    codeContent += '}';
                } else if (isTimed) {
                    codeContent += '// Timed system: auto-advances every ' + interval + 'ms\n';
                    codeContent += "engine.startTickSystem(entity.id, '" + ts.id + "'); // start\n";
                    codeContent += "engine.stopTickSystem(entity.id, '" + ts.id + "');  // pause\n\n";
                    codeContent += '// Check elapsed time\n';
                    codeContent += 'const ' + ts.id.replace(/^tick_/, '') + "Tick = engine.getCurrentTick(entity.id, '" + ts.id + "');";
                } else {
                    codeContent += '// Event-triggered system\n';
                    codeContent += "engine.startTickSystem(entity.id, '" + ts.id + "');\n";
                    codeContent += "engine.stopTickSystem(entity.id, '" + ts.id + "');";
                }

                if (boundMods.length > 0) {
                    codeContent += '\n\n// Bound modifiers that tick down:\n';
                    codeContent += '// ' + boundMods.map(m => m.name).join(', ');
                }

                const typeLabel = isManual ? 'manual' : isTimed ? interval + 'ms' : 'event';

                return '<div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer;">' +
                    '<div class="snippet-header">' + ts.name + ' <span style="font-weight: normal; color: var(--text-muted);">(' + typeLabel + ')</span></div>' +
                    '<pre class="snippet-code">' + codeContent + '</pre>' +
                    '</div>';
            }).join('');

            return `
                <!-- Tick Systems Section -->
                <div class="code-section" style="margin-bottom: 2rem;">
                    <h3 style="color: var(--node-ticksystem); margin: 0 0 0.5rem 0; font-size: 1rem;">â±ï¸ Tick Systems</h3>
                    <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0 0 0.75rem 0;">
                        Control time-based mechanics. Manual tick systems require explicit calls; timed systems auto-advance.
                    </p>

                    <!-- General Tick Controls -->
                    <div class="code-snippet-card" onclick="copyCodeSnippet(this)" style="cursor: pointer; margin-bottom: 0.75rem;">
                        <div class="snippet-header">Tick System Control</div>
                        <pre class="snippet-code">// Start a tick system (begins tracking time/turns)
engine.startTickSystem(entity.id, 'tick_combat');

// Stop a tick system (pauses, preserves state)
engine.stopTickSystem(entity.id, 'tick_combat');

// Reset a tick system (stops and resets to tick 0)
engine.resetTickSystem(entity.id, 'tick_combat');

// Advance a manual tick system by 1
engine.advanceTick(entity.id, 'tick_combat');

// Advance by multiple ticks
engine.advanceTick(entity.id, 'tick_combat', 3); // advance 3 turns

// Get current tick count
const turn = engine.getCurrentTick(entity.id, 'tick_combat');

// Check if tick system is active
const inCombat = engine.isTickSystemActive(entity.id, 'tick_combat');</pre>
                    </div>

                    <!-- Per-system snippets -->
                    <div class="code-snippets-grid" style="display: grid; gap: 0.75rem;">
                        ${tickSystemCards}
                    </div>
                </div>
            `;
        }

        function copyCodeSnippet(card) {
            const code = card.querySelector('.snippet-code').textContent;
            navigator.clipboard.writeText(code).then(() => {
                card.classList.add('copied');
                setTimeout(() => card.classList.remove('copied'), 1500);
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback: select text
                const range = document.createRange();
                range.selectNode(card.querySelector('.snippet-code'));
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
            });
        }

        function renderValidateView(container) {
            container.innerHTML = `
                <div class="validate-view" style="padding: 1rem; max-width: 900px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h2 style="color: var(--copper); margin: 0;">Configuration Health Check</h2>
                        <div style="display: flex; gap: 0.5rem;">
                            <button class="btn btn-primary" onclick="runValidation()">Run Validation</button>
                            <button class="btn btn-secondary" onclick="runQuickSpawnTest()">Quick Spawn Test</button>
                        </div>
                    </div>

                    <!-- Config Source Toggle -->
                    <div style="background: var(--bg-medium); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                        <div style="display: flex; gap: 1rem; align-items: center; margin-bottom: 0.75rem;">
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="radio" name="validateSource" value="current" checked onchange="setValidateSource('current')" style="accent-color: var(--copper);">
                                <span style="color: var(--text-light);">Current Config</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="radio" name="validateSource" value="external" onchange="setValidateSource('external')" style="accent-color: var(--copper);">
                                <span style="color: var(--text-light);">Import External Config</span>
                            </label>
                        </div>
                        <div id="externalConfigPanel" style="display: none;">
                            <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 0.75rem;">
                                <div style="flex: 1; min-width: 200px;">
                                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-muted); font-size: 0.85rem;">Upload JSON file:</label>
                                    <input type="file" id="validateImportFile" accept=".json" onchange="handleValidateFileImport(event)" style="background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.5rem; width: 100%; color: var(--text-light); font-size: 0.85rem;">
                                </div>
                                <div style="flex: 2; min-width: 250px;">
                                    <label style="display: block; margin-bottom: 0.5rem; color: var(--text-muted); font-size: 0.85rem;">Or paste JSON:</label>
                                    <textarea id="validateImportJson" placeholder="Paste your config JSON here..." style="background: var(--bg-dark); border: 1px solid var(--border-color); border-radius: 6px; padding: 0.5rem; width: 100%; height: 60px; color: var(--text-light); font-family: monospace; font-size: 0.8rem; resize: vertical;"></textarea>
                                </div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <button class="btn btn-secondary" onclick="importExternalConfig()" style="padding: 0.4rem 0.8rem; font-size: 0.85rem;">Load & Validate</button>
                                <span id="validateImportStatus" style="color: var(--text-muted); font-size: 0.85rem;"></span>
                            </div>
                        </div>
                        <div id="currentConfigInfo" style="color: var(--text-muted); font-size: 0.85rem;">
                            Validating: <strong style="color: var(--copper-light);">${config.name || config.id || 'Current Config'}</strong>
                            (${config.nodes?.length || 0} nodes, ${config.relationships?.length || 0} relationships)
                        </div>
                    </div>

                    <!-- Health Score -->
                    <div class="validate-health-card" style="background: var(--bg-medium); border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 1.5rem;">
                        <div id="healthScoreCircle" class="health-circle" style="width: 80px; height: 80px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: bold; background: var(--bg-dark); color: var(--text-muted);">
                            -
                        </div>
                        <div>
                            <div style="font-size: 1.2rem; color: var(--text-light); margin-bottom: 0.25rem;">Config Health Score</div>
                            <div id="healthSummary" style="color: var(--text-muted); font-size: 0.9rem;">
                                Click "Run Validation" to check your configuration
                            </div>
                        </div>
                    </div>

                    <!-- Issues List -->
                    <div style="margin-bottom: 1.5rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                            <h3 style="color: var(--copper-light); font-size: 1rem; margin: 0;">Issues & Suggestions</h3>
                            <div id="dismissedCount" style="display: none;">
                                <button class="btn btn-sm" onclick="restoreAllIssues()" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">
                                    Show dismissed (<span id="dismissedCountNum">0</span>)
                                </button>
                            </div>
                        </div>
                        <div id="validationIssues" style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <div style="color: var(--text-muted); padding: 2rem; text-align: center; background: var(--bg-medium); border-radius: 8px;">
                                No validation results yet
                            </div>
                        </div>
                    </div>

                    <!-- Quick Spawn Results -->
                    <div>
                        <h3 style="color: var(--copper-light); margin-bottom: 1rem; font-size: 1rem;">Quick Spawn Test Results</h3>
                        <div id="quickSpawnResults" style="background: var(--bg-medium); border-radius: 8px; padding: 1rem;">
                            <div style="color: var(--text-muted); text-align: center;">
                                Click "Quick Spawn Test" to spawn 100 entities and see trait distributions
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Validation source: 'current' or 'external'
        let validateSource = 'current';
        let externalConfig = null;

        function setValidateSource(source) {
            validateSource = source;
            const externalPanel = document.getElementById('externalConfigPanel');
            const currentInfo = document.getElementById('currentConfigInfo');

            if (source === 'external') {
                externalPanel.style.display = 'block';
                currentInfo.style.display = 'none';
            } else {
                externalPanel.style.display = 'none';
                currentInfo.style.display = 'block';
                externalConfig = null;
                // Reset status
                const statusEl = document.getElementById('validateImportStatus');
                if (statusEl) statusEl.textContent = '';
            }
        }

        function validateExternalConfigStructure(cfg) {
            const errors = [];

            if (!cfg || typeof cfg !== 'object') {
                errors.push('Config must be a valid JSON object');
                return errors;
            }

            if (!cfg.nodes || !Array.isArray(cfg.nodes)) {
                errors.push('Config must have a "nodes" array');
            } else if (cfg.nodes.length === 0) {
                errors.push('Config has empty "nodes" array');
            }

            if (!cfg.relationships || !Array.isArray(cfg.relationships)) {
                errors.push('Config must have a "relationships" array (can be empty)');
            }

            // Check for required node properties
            if (cfg.nodes && Array.isArray(cfg.nodes)) {
                const nodeIds = new Set();
                for (let i = 0; i < cfg.nodes.length; i++) {
                    const node = cfg.nodes[i];
                    if (!node.id) errors.push(`Node ${i} is missing "id"`);
                    if (!node.type) errors.push(`Node ${i} is missing "type"`);
                    if (node.id && nodeIds.has(node.id)) errors.push(`Duplicate node id: ${node.id}`);
                    if (node.id) nodeIds.add(node.id);
                }
            }

            return errors;
        }

        function handleValidateFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('validateImportJson').value = e.target.result;
                importExternalConfig();
            };
            reader.onerror = () => {
                document.getElementById('validateImportStatus').innerHTML = '<span style="color: #f44336;">Failed to read file</span>';
            };
            reader.readAsText(file);
        }

        function importExternalConfig() {
            const jsonText = document.getElementById('validateImportJson').value.trim();
            const statusEl = document.getElementById('validateImportStatus');

            if (!jsonText) {
                statusEl.innerHTML = '<span style="color: #ff9800;">Please paste JSON or select a file</span>';
                return;
            }

            try {
                const cfg = JSON.parse(jsonText);

                // Validate structure
                const errors = validateExternalConfigStructure(cfg);
                if (errors.length > 0) {
                    statusEl.innerHTML = `<span style="color: #f44336;">Invalid: ${errors[0]}</span>`;
                    externalConfig = null;
                    return;
                }

                externalConfig = cfg;
                const name = cfg.name || cfg.id || 'Imported Config';
                statusEl.innerHTML = `<span style="color: #81c784;">Loaded: ${name} (${cfg.nodes.length} nodes)</span>`;

                // Auto-run validation
                runValidation();

            } catch (e) {
                statusEl.innerHTML = `<span style="color: #f44336;">JSON error: ${e.message}</span>`;
                externalConfig = null;
            }
        }

        function getValidationConfig() {
            if (validateSource === 'external' && externalConfig) {
                return externalConfig;
            }
            return config;
        }

        function runValidation() {
            const validationConfig = getValidationConfig();
            const validator = new ConfigValidator(validationConfig, { dismissedIssues });
            validationResults = validator.validate();

            // Update health score
            const scoreCircle = document.getElementById('healthScoreCircle');
            const score = validationResults.score;
            scoreCircle.textContent = score;
            scoreCircle.style.background = score >= 80 ? '#1b5e20' : score >= 50 ? '#e65100' : '#b71c1c';
            scoreCircle.style.color = score >= 80 ? '#81c784' : score >= 50 ? '#ffcc80' : '#ef9a9a';

            // Update summary
            const summary = document.getElementById('healthSummary');
            const s = validationResults.summary;
            const dismissedText = s.dismissed > 0 ? `, ${s.dismissed} dismissed` : '';
            summary.innerHTML = `${s.errors} errors, ${s.warnings} warnings, ${s.info} suggestions${dismissedText}`;

            // Update dismissed count button
            const dismissedCountEl = document.getElementById('dismissedCount');
            const dismissedCountNum = document.getElementById('dismissedCountNum');
            if (s.dismissed > 0) {
                dismissedCountEl.style.display = 'block';
                dismissedCountNum.textContent = s.dismissed;
            } else {
                dismissedCountEl.style.display = 'none';
            }

            // Render issues (only active ones by default)
            const issuesContainer = document.getElementById('validationIssues');
            const activeIssues = validationResults.activeIssues || validationResults.issues.filter(i => !i.dismissed);

            if (activeIssues.length === 0) {
                issuesContainer.innerHTML = `
                    <div style="color: #81c784; padding: 1rem; text-align: center; background: var(--bg-medium); border-radius: 8px;">
                        &#10003; No active issues. Configuration looks healthy!
                        ${s.dismissed > 0 ? `<div style="color: var(--text-muted); font-size: 0.85rem; margin-top: 0.5rem;">(${s.dismissed} issues dismissed)</div>` : ''}
                    </div>
                `;
            } else {
                issuesContainer.innerHTML = activeIssues.map(issue => {
                    const bgColor = issue.severity === 'error' ? 'rgba(244, 67, 54, 0.1)' :
                                   issue.severity === 'warning' ? 'rgba(255, 152, 0, 0.1)' : 'rgba(33, 150, 243, 0.1)';
                    const borderColor = issue.severity === 'error' ? '#f44336' :
                                       issue.severity === 'warning' ? '#ff9800' : '#2196f3';
                    const icon = issue.severity === 'error' ? '&#10060;' :
                                issue.severity === 'warning' ? '&#9888;' : '&#8505;';

                    // Only show dismiss button for dismissable issues (not errors)
                    const dismissBtn = issue.dismissable || issue.severity !== 'error' ?
                        `<button onclick="dismissIssue('${issue.id}')" style="background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 0.75rem; padding: 0.25rem 0.5rem; margin-left: auto; opacity: 0.7;" title="Dismiss (this is intentional)">dismiss</button>` : '';

                    return `
                        <div style="background: ${bgColor}; border-left: 3px solid ${borderColor}; padding: 0.75rem 1rem; border-radius: 0 6px 6px 0;">
                            <div style="display: flex; align-items: flex-start; color: var(--text-light);">
                                <span style="margin-right: 0.5rem;">${icon}</span>
                                <span style="flex: 1;">${issue.message}</span>
                                ${dismissBtn}
                            </div>
                            ${issue.suggestion ? `<div style="color: var(--text-muted); font-size: 0.85rem; margin-top: 0.25rem; font-style: italic; margin-left: 1.5rem;">${issue.suggestion}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }
        }

        function runQuickSpawnTest() {
            const results = {};
            const sampleSize = 100;

            // Use external config if selected, otherwise use current engine
            const validationConfig = getValidationConfig();
            let testEngine = engine;

            // If using external config, create a temporary engine
            if (validateSource === 'external' && externalConfig) {
                try {
                    testEngine = new SpawnEngine(externalConfig);
                } catch (e) {
                    const container = document.getElementById('quickSpawnResults');
                    container.innerHTML = `<div style="color: #f44336; text-align: center;">Failed to create engine: ${e.message}</div>`;
                    return;
                }
            }

            // Initialize counters for all traits
            const layers = testEngine.getLayers();
            for (const layer of layers) {
                results[layer.id] = { name: layer.name, traits: {} };
                const traits = testEngine.getLayerTraits(layer.id);
                for (const trait of traits) {
                    results[layer.id].traits[trait.id] = { name: trait.name, count: 0 };
                }
            }

            // Spawn and count
            for (let i = 0; i < sampleSize; i++) {
                const entity = testEngine.generate();
                for (const [layerId, layerData] of Object.entries(entity.layers)) {
                    if (results[layerId]) {
                        for (const traitId of layerData.active || []) {
                            if (results[layerId].traits[traitId]) {
                                results[layerId].traits[traitId].count++;
                            }
                        }
                    }
                }
            }

            // Render results
            const container = document.getElementById('quickSpawnResults');
            const configName = validationConfig.name || validationConfig.id || 'Config';
            const isExternal = validateSource === 'external' && externalConfig;
            let html = `<div style="color: var(--text-muted); margin-bottom: 1rem;">Spawned ${sampleSize} entities from <strong style="color: var(--copper-light);">${configName}</strong>${isExternal ? ' (imported)' : ''}:</div>`;

            for (const [layerId, layerData] of Object.entries(results)) {
                const traits = Object.values(layerData.traits);
                if (traits.length === 0) continue;

                html += `<div style="margin-bottom: 1rem;"><div style="color: var(--copper-light); font-weight: 600; margin-bottom: 0.5rem;">${layerData.name}</div>`;
                html += `<div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">`;

                for (const trait of traits) {
                    const percent = (trait.count / sampleSize * 100).toFixed(0);
                    const isNever = trait.count === 0;
                    const isAlways = trait.count === sampleSize;
                    const flagColor = isNever ? '#f44336' : isAlways ? '#ff9800' : 'var(--text-light)';

                    html += `
                        <div style="background: var(--bg-dark); padding: 0.5rem 0.75rem; border-radius: 4px; display: flex; align-items: center; gap: 0.5rem;">
                            <span style="color: ${flagColor};">${trait.name}</span>
                            <span style="background: var(--bg-medium); padding: 0.125rem 0.5rem; border-radius: 10px; font-size: 0.8rem; color: var(--copper);">${percent}%</span>
                            ${isNever ? '<span style="color: #f44336; font-size: 0.75rem;">never</span>' : ''}
                            ${isAlways ? '<span style="color: #ff9800; font-size: 0.75rem;">always</span>' : ''}
                        </div>
                    `;
                }

                html += `</div></div>`;
            }

            container.innerHTML = html;
            quickSpawnResults = results;
        }

        // ConfigValidator class (inline for editor)
        class ConfigValidator {
            constructor(config, options = {}) {
                this.config = config;
                this.issues = [];
                this.nodeIndex = new Map();
                this.relationshipsBySource = new Map();
                this.relationshipsByTarget = new Map();
                this.layerTraits = new Map();
                this.dismissedIssues = options.dismissedIssues || new Set();
                this.buildIndexes();
            }

            generateIssueId(category, message, nodeId) {
                const content = `${category}:${message}:${nodeId || ''}`;
                let hash = 0;
                for (let i = 0; i < content.length; i++) {
                    const char = content.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return `issue_${Math.abs(hash).toString(36)}`;
            }

            isTypicallyDismissable(category, message) {
                if (category === 'info' || category === 'coverage' || category === 'semantic') return true;
                const patterns = [/has no outgoing relationships/i, /no weight influences.*purely random/i, /has rate 0 and no rate modifiers/i, /doesn't affect anything/i, /no opposite trait/i];
                return patterns.some(p => p.test(message));
            }

            buildIndexes() {
                for (const node of this.config.nodes || []) {
                    this.nodeIndex.set(node.id, node);
                }
                for (const rel of this.config.relationships || []) {
                    if (!this.relationshipsBySource.has(rel.sourceId)) {
                        this.relationshipsBySource.set(rel.sourceId, []);
                    }
                    this.relationshipsBySource.get(rel.sourceId).push(rel);
                    if (!this.relationshipsByTarget.has(rel.targetId)) {
                        this.relationshipsByTarget.set(rel.targetId, []);
                    }
                    this.relationshipsByTarget.get(rel.targetId).push(rel);
                }
                for (const node of this.config.nodes || []) {
                    if (node.type === 'layer' && node.config?.traitIds) {
                        this.layerTraits.set(node.id, new Set(node.config.traitIds));
                    }
                }
            }

            validate() {
                this.issues = [];
                this.checkOrphanedTraits();
                this.checkBrokenRelationships();
                this.checkMissingPolarities();
                this.checkUnbalancedLayers();
                this.checkRedundantRelationships();
                this.checkUnusedAttributes();
                this.checkZeroWeightTraits();
                return this.getResults();
            }

            addIssue(severity, category, message, details = {}) {
                const issueId = this.generateIssueId(category, message, details.nodeId);
                const dismissed = this.dismissedIssues.has(issueId);
                this.issues.push({
                    id: issueId,
                    severity, category, message, details,
                    nodeId: details.nodeId || null,
                    suggestion: details.suggestion || null,
                    dismissed,
                    dismissable: this.isTypicallyDismissable(category, message)
                });
            }

            checkOrphanedTraits() {
                for (const [nodeId, node] of this.nodeIndex) {
                    if (node.type !== 'item') continue;
                    const layerId = node.config?.layerId;
                    if (!layerId) {
                        this.addIssue('error', 'structural', `Trait '${node.name}' has no layerId`, { nodeId, suggestion: 'Assign this trait to a layer' });
                        continue;
                    }
                    if (!this.nodeIndex.has(layerId)) {
                        this.addIssue('error', 'structural', `Trait '${node.name}' references non-existent layer`, { nodeId, suggestion: 'Fix the layerId or create the missing layer' });
                    }
                }
            }

            checkBrokenRelationships() {
                for (const rel of this.config.relationships || []) {
                    if (!this.nodeIndex.has(rel.sourceId)) {
                        this.addIssue('error', 'structural', `Relationship has non-existent source '${rel.sourceId}'`, { suggestion: 'Fix or remove this relationship' });
                    }
                    if (!this.nodeIndex.has(rel.targetId)) {
                        this.addIssue('error', 'structural', `Relationship has non-existent target '${rel.targetId}'`, { suggestion: 'Fix or remove this relationship' });
                    }
                }
            }

            checkMissingPolarities() {
                const patterns = [
                    { positive: /happy|cheerful|optimist/i, negative: /sad|grumpy|pessimist/i },
                    { positive: /brave|courageous/i, negative: /coward|fearful/i },
                    { positive: /calm|peaceful/i, negative: /angry|agitated/i }
                ];
                for (const [layerId, traitIds] of this.layerTraits) {
                    const layer = this.nodeIndex.get(layerId);
                    const traitNames = [...traitIds].map(id => ({ id, name: this.nodeIndex.get(id)?.name || id }));
                    for (const pattern of patterns) {
                        const hasPositive = traitNames.some(t => pattern.positive.test(t.name));
                        const hasNegative = traitNames.some(t => pattern.negative.test(t.name));
                        if (hasPositive && !hasNegative) {
                            const match = traitNames.find(t => pattern.positive.test(t.name));
                            this.addIssue('info', 'semantic', `Layer '${layer?.name}' has '${match.name}' but no opposite trait`, { nodeId: layerId, suggestion: 'Consider adding an opposite trait for balance' });
                        } else if (hasNegative && !hasPositive) {
                            const match = traitNames.find(t => pattern.negative.test(t.name));
                            this.addIssue('info', 'semantic', `Layer '${layer?.name}' has '${match.name}' but no opposite trait`, { nodeId: layerId, suggestion: 'Consider adding an opposite trait for balance' });
                        }
                    }
                }
            }

            checkUnbalancedLayers() {
                for (const [layerId, traitIds] of this.layerTraits) {
                    const layer = this.nodeIndex.get(layerId);
                    if (traitIds.size === 0) {
                        this.addIssue('error', 'semantic', `Layer '${layer?.name}' has no traits`, { nodeId: layerId, suggestion: 'Add traits to this layer' });
                    } else if (traitIds.size === 1) {
                        this.addIssue('warning', 'semantic', `Layer '${layer?.name}' has only 1 trait (will always be selected)`, { nodeId: layerId, suggestion: 'Consider adding more variety' });
                    }
                }
            }

            checkRedundantRelationships() {
                const seen = new Map();
                for (const rel of this.config.relationships || []) {
                    const key = `${rel.sourceId}->${rel.targetId}->${rel.type}`;
                    if (seen.has(key)) {
                        this.addIssue('warning', 'semantic', `Duplicate relationship from ${rel.sourceId} to ${rel.targetId}`, { suggestion: 'Consider merging these relationships' });
                    } else {
                        seen.set(key, rel);
                    }
                }
            }

            checkUnusedAttributes() {
                const attributes = [...this.nodeIndex.values()].filter(n => n.type === 'attribute');
                for (const attr of attributes) {
                    const outgoing = this.relationshipsBySource.get(attr.id) || [];
                    if (outgoing.length === 0) {
                        this.addIssue('info', 'coverage', `Attribute '${attr.name}' has no outgoing relationships`, { nodeId: attr.id, suggestion: 'Is this intentional? Consider adding relationships' });
                    }
                }
            }

            checkZeroWeightTraits() {
                const items = [...this.nodeIndex.values()].filter(n => n.type === 'item');
                for (const item of items) {
                    const baseWeight = item.config?.selection?.baseWeight || 0;
                    if (baseWeight === 0) {
                        const incoming = this.relationshipsByTarget.get(item.id) || [];
                        const hasPositiveInfluence = incoming.some(r => r.type === 'weight_influence' && r.config?.operation === 'add' && r.config?.value > 0);
                        if (!hasPositiveInfluence) {
                            this.addIssue('warning', 'coverage', `Trait '${item.name}' has 0 base weight and no positive influences`, { nodeId: item.id, suggestion: 'This trait will never be selected' });
                        }
                    }
                }
            }

            getResults() {
                const activeIssues = this.issues.filter(i => !i.dismissed);
                const errors = activeIssues.filter(i => i.severity === 'error');
                const warnings = activeIssues.filter(i => i.severity === 'warning');
                const infos = activeIssues.filter(i => i.severity === 'info');
                const dismissed = this.issues.filter(i => i.dismissed);
                const score = Math.max(0, 100 - (errors.length * 20) - (warnings.length * 5) - (infos.length * 1));
                return {
                    score, issues: this.issues, activeIssues,
                    summary: { errors: errors.length, warnings: warnings.length, info: infos.length, dismissed: dismissed.length, total: this.issues.length, activeTotal: activeIssues.length },
                    passed: errors.length === 0
                };
            }
        }

        // ========================================
        // PRESETS VIEW
        // ========================================

        let selectedPresetId = null;
        let selectedPresetGroupId = null;
        let addingNewPreset = false; // When true, detail panel shows "add new preset" form
        let addingNewGroup = false; // When true, detail panel shows "add new group" form
        let addingNewGroupParentId = null; // Parent group ID for new group (null = root)

        // v3.3 Session 4: renderPresetsView() deleted â€” replaced by renderPersistencePresetsSection()

        function renderPresetCards() {
            const presets = config.presets || [];
            let filtered = presets;

            if (selectedPresetGroupId === '__ungrouped') {
                filtered = presets.filter(p => !p.group);
            } else if (selectedPresetGroupId) {
                filtered = presets.filter(p => p.group === selectedPresetGroupId);
            }

            if (filtered.length === 0) {
                return `<div style="color: var(--text-muted); padding: 2rem; text-align: center;">No presets in this group</div>`;
            }

            return filtered.map(preset => `
                <div class="preset-card ${selectedPresetId === preset.id ? 'selected' : ''}"
                     onclick="selectPreset('${preset.id}')"
                     style="background: var(--bg-medium); border: 1px solid ${selectedPresetId === preset.id ? 'var(--copper)' : 'var(--border-color)'}; border-radius: 8px; padding: 1rem; cursor: pointer;">
                    <div style="font-weight: 600; color: var(--text-light); margin-bottom: 0.5rem;">${preset.name}</div>
                    ${preset.description ? `<div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.5rem;">${preset.description}</div>` : ''}
                    ${preset.tags && preset.tags.length > 0 ? `
                        <div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
                            ${preset.tags.map(tag => `<span class="tag" style="font-size: 0.7rem;">${tag}</span>`).join('')}
                        </div>
                    ` : ''}
                    ${preset.forceTraits && preset.forceTraits.length > 0 ? `
                        <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--copper);">
                            ${preset.forceTraits.length} forced trait${preset.forceTraits.length > 1 ? 's' : ''}
                        </div>
                    ` : ''}
                </div>
            `).join('');
        }

        function renderPresetDetail() {
            const preset = (config.presets || []).find(p => p.id === selectedPresetId);
            if (!preset) return '';

            const groups = config.presetGroups || [];
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const layers = config.nodes.filter(n => n.type === 'layer');
            // Include items (in layers), modifiers, and standalone traits as forceable
            const traits = config.nodes.filter(n => n.type === 'item' || n.type === 'trait' || n.type === 'modifier');

            return `
                <div style="font-weight: 600; color: var(--copper); margin-bottom: 1rem;">${preset.name}</div>

                <div class="detail-section">
                    <div class="detail-section-title">Basic Info</div>
                    <div class="form-group">
                        <label>ID</label>
                        <input type="text" value="${preset.id}" onchange="updatePreset('${preset.id}', 'id', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Name</label>
                        <input type="text" value="${preset.name}" onchange="updatePreset('${preset.id}', 'name', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Group</label>
                        <select onchange="updatePreset('${preset.id}', 'group', this.value || null)">
                            <option value="">No Group</option>
                            ${groups.map(g => `<option value="${g.id}" ${preset.group === g.id ? 'selected' : ''}>${g.name}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea rows="2" onchange="updatePreset('${preset.id}', 'description', this.value)">${preset.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label>Tags (comma-separated)</label>
                        <input type="text" value="${(preset.tags || []).join(', ')}"
                               onchange="updatePreset('${preset.id}', 'tags', this.value.split(',').map(t => t.trim()).filter(Boolean))">
                    </div>
                </div>

                <div class="detail-section">
                    <div class="detail-section-title">Attribute Overrides</div>
                    ${attributes.map(attr => {
                        const attrVal = preset.attributes?.[attr.id];
                        const mode = getPresetAttrMode(attrVal);
                        const range = attr.config.defaultRange || [attr.config.min, attr.config.max];
                        return `
                        <div class="form-group preset-attr-row" style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
                            <label style="min-width: 90px; margin: 0;">${attr.name}</label>
                            <select style="width: 80px;" onchange="setPresetAttrMode('${preset.id}', '${attr.id}', this.value)">
                                <option value="default" ${mode === 'default' ? 'selected' : ''}>Default</option>
                                <option value="fixed" ${mode === 'fixed' ? 'selected' : ''}>Fixed</option>
                                <option value="range" ${mode === 'range' ? 'selected' : ''}>Range</option>
                                <option value="variance" ${mode === 'variance' ? 'selected' : ''}>Variance</option>
                            </select>
                            ${mode === 'fixed' ? `
                                <input type="number" style="width: 70px;"
                                       value="${typeof attrVal === 'number' ? attrVal : (attrVal?.value ?? '')}"
                                       placeholder="${range[0]}-${range[1]}"
                                       onchange="updatePresetAttrFixed('${preset.id}', '${attr.id}', this.value)">
                            ` : ''}
                            ${mode === 'range' ? `
                                <input type="number" style="width: 55px;" placeholder="min"
                                       value="${attrVal?.min ?? ''}"
                                       onchange="updatePresetAttrRange('${preset.id}', '${attr.id}', 'min', this.value)">
                                <span style="color: var(--text-muted);">-</span>
                                <input type="number" style="width: 55px;" placeholder="max"
                                       value="${attrVal?.max ?? ''}"
                                       onchange="updatePresetAttrRange('${preset.id}', '${attr.id}', 'max', this.value)">
                            ` : ''}
                            ${mode === 'variance' ? `
                                <input type="number" style="width: 55px;" placeholder="base"
                                       value="${attrVal?.base ?? ''}"
                                       onchange="updatePresetAttrVariance('${preset.id}', '${attr.id}', 'base', this.value)">
                                <span style="color: var(--text-muted);">Â±</span>
                                <input type="number" style="width: 45px;" placeholder="var"
                                       value="${attrVal?.variance ?? ''}"
                                       onchange="updatePresetAttrVariance('${preset.id}', '${attr.id}', 'variance', this.value)">
                            ` : ''}
                            ${mode === 'default' ? `
                                <span style="color: var(--text-muted); font-size: 0.8rem;">(${range[0]}-${range[1]})</span>
                            ` : ''}
                        </div>
                    `;}).join('')}
                    ${attributes.length === 0 ? '<div style="color: var(--text-muted); font-size: 0.8rem;">No attributes defined</div>' : ''}
                </div>

                <div class="detail-section">
                    <div class="detail-section-title">Forced Traits <span style="color: var(--text-muted); font-weight: normal; font-size: 0.8rem;">(always applied)</span></div>
                    ${(() => {
                        // Group traits by layer
                        const traitsByLayer = {};
                        const modifiers = traits.filter(t => t.type === 'modifier');
                        const layerTraits = traits.filter(t => t.type !== 'modifier');

                        layerTraits.forEach(trait => {
                            const layerId = trait.config?.layerId;
                            if (layerId) {
                                const layer = layers.find(l => l.id === layerId);
                                const key = layer?.id || layerId;
                                if (!traitsByLayer[key]) traitsByLayer[key] = { layer, traits: [] };
                                traitsByLayer[key].traits.push(trait);
                            }
                        });

                        // Sort by layer order
                        const sortedGroups = Object.values(traitsByLayer).sort((a, b) => {
                            const orderA = a.layer?.config?.order ?? 999;
                            const orderB = b.layer?.config?.order ?? 999;
                            return orderA - orderB;
                        });

                        if (traits.length === 0) return '<div style="color: var(--text-muted); font-size: 0.8rem;">No traits defined</div>';

                        return `
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${sortedGroups.map(group => `
                                <div style="margin-bottom: 0.5rem;">
                                    <div style="font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--accent-secondary); margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.4rem;">
                                        <span class="dot layer" style="width: 5px; height: 5px;"></span>
                                        ${group.layer?.name || 'Unknown Layer'}
                                    </div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.25rem 0.5rem; padding-left: 0.5rem;">
                                        ${group.traits.map(trait => `
                                            <label style="display: flex; align-items: center; gap: 0.35rem; cursor: pointer; font-size: 0.8rem;">
                                                <input type="checkbox" ${(preset.forceTraits || []).includes(trait.id) ? 'checked' : ''}
                                                       onchange="togglePresetForceTrait('${preset.id}', '${trait.id}', this.checked)">
                                                <span class="dot ${trait.type}" style="width: 6px; height: 6px;"></span>
                                                ${trait.name}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            `).join('')}
                            ${modifiers.length > 0 ? `
                                <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border-color);">
                                    <div style="font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--node-modifier); margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.4rem;">
                                        <span class="dot modifier" style="width: 5px; height: 5px;"></span>
                                        Modifiers
                                    </div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.25rem 0.5rem; padding-left: 0.5rem;">
                                        ${modifiers.map(mod => `
                                            <label style="display: flex; align-items: center; gap: 0.35rem; cursor: pointer; font-size: 0.8rem;">
                                                <input type="checkbox" ${(preset.forceTraits || []).includes(mod.id) ? 'checked' : ''}
                                                       onchange="togglePresetForceTrait('${preset.id}', '${mod.id}', this.checked)">
                                                <span class="dot modifier" style="width: 6px; height: 6px;"></span>
                                                ${mod.name}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        `;
                    })()}
                </div>

                <div class="detail-section">
                    <div class="detail-section-title">Layer-Specific Selection <span style="color: var(--text-muted); font-weight: normal; font-size: 0.8rem;">(variable)</span></div>
                    <div style="display: flex; flex-direction: column; gap: 0.75rem;">
                        ${layers.map(layer => {
                            const layerTraits = traits.filter(t => t.config?.layerId === layer.id);
                            if (layerTraits.length === 0) return '';
                            const traitSpec = preset.traits?.[layer.id];
                            const mode = getPresetTraitMode(traitSpec);
                            return `
                            <div class="preset-layer-selection" style="border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem;">
                                <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                                    <span class="dot layer" style="width: 8px; height: 8px;"></span>
                                    <strong style="flex: 1;">${layer.name}</strong>
                                    <select style="width: 90px;" onchange="setPresetTraitMode('${preset.id}', '${layer.id}', this.value)">
                                        <option value="none" ${mode === 'none' ? 'selected' : ''}>None</option>
                                        <option value="fixed" ${mode === 'fixed' ? 'selected' : ''}>Fixed</option>
                                        <option value="weighted" ${mode === 'weighted' ? 'selected' : ''}>Weighted</option>
                                        <option value="chance" ${mode === 'chance' ? 'selected' : ''}>Chance</option>
                                        <option value="pickN" ${mode === 'pickN' ? 'selected' : ''}>Pick N</option>
                                    </select>
                                </div>
                                ${mode === 'fixed' ? `
                                    <select style="width: 100%;" onchange="setPresetTraitFixed('${preset.id}', '${layer.id}', this.value)">
                                        <option value="">-- Select trait --</option>
                                        ${layerTraits.map(t => `
                                            <option value="${t.id}" ${traitSpec === t.id ? 'selected' : ''}>${t.name}</option>
                                        `).join('')}
                                    </select>
                                ` : ''}
                                ${mode === 'weighted' ? `
                                    <div style="display: flex; flex-direction: column; gap: 0.25rem; max-height: 120px; overflow-y: auto;">
                                        ${(traitSpec?.pool || []).map((p, idx) => `
                                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                                <span style="flex: 1; font-size: 0.85rem;">${config.nodes.find(n => n.id === (typeof p === 'string' ? p : p.id))?.name || p.id || p}</span>
                                                <input type="number" style="width: 50px;" value="${typeof p === 'object' ? (p.weight || 1) : 1}"
                                                       placeholder="wt" onchange="updatePresetTraitPoolWeight('${preset.id}', '${layer.id}', ${idx}, this.value)">
                                                <button class="btn btn-icon btn-sm" onclick="removePresetTraitFromPool('${preset.id}', '${layer.id}', ${idx})">âœ•</button>
                                            </div>
                                        `).join('')}
                                        ${(traitSpec?.pool || []).length === 0 ? '<div style="color: var(--text-muted); font-size: 0.8rem;">No traits in pool</div>' : ''}
                                    </div>
                                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                                        <select id="addTraitPool_${preset.id}_${layer.id}" style="flex: 1;">
                                            <option value="">Add trait...</option>
                                            ${layerTraits.filter(t => !(traitSpec?.pool || []).some(p => (typeof p === 'string' ? p : p.id) === t.id)).map(t => `
                                                <option value="${t.id}">${t.name}</option>
                                            `).join('')}
                                        </select>
                                        <button class="btn btn-secondary btn-sm" onclick="addPresetTraitToPool('${preset.id}', '${layer.id}')">+</button>
                                    </div>
                                ` : ''}
                                ${mode === 'chance' ? `
                                    <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                                        <label style="margin: 0;">Chance:</label>
                                        <input type="number" style="width: 60px;" min="0" max="100" step="5"
                                               value="${Math.round((traitSpec?.chance || 0.5) * 100)}"
                                               onchange="updatePresetTraitChance('${preset.id}', '${layer.id}', this.value / 100)">
                                        <span>%</span>
                                    </div>
                                    <select style="width: 100%;" onchange="setPresetTraitChancePool('${preset.id}', '${layer.id}', this.value)">
                                        <option value="">-- Select trait (if chance succeeds) --</option>
                                        ${layerTraits.map(t => {
                                            const poolItem = (traitSpec?.pool || [])[0];
                                            const selected = poolItem && (typeof poolItem === 'string' ? poolItem : poolItem.id) === t.id;
                                            return `<option value="${t.id}" ${selected ? 'selected' : ''}>${t.name}</option>`;
                                        }).join('')}
                                    </select>
                                ` : ''}
                                ${mode === 'pickN' ? `
                                    <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;">
                                        <label style="margin: 0;">Pick:</label>
                                        <input type="number" style="width: 50px;" min="1" max="10"
                                               value="${traitSpec?.count || 1}"
                                               onchange="updatePresetTraitPickCount('${preset.id}', '${layer.id}', this.value)">
                                        <span>from pool</span>
                                    </div>
                                    <div style="display: flex; flex-direction: column; gap: 0.25rem; max-height: 100px; overflow-y: auto;">
                                        ${(traitSpec?.pool || []).map((p, idx) => `
                                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                                <span style="flex: 1; font-size: 0.85rem;">${config.nodes.find(n => n.id === (typeof p === 'string' ? p : p.id))?.name || p}</span>
                                                <button class="btn btn-icon btn-sm" onclick="removePresetTraitFromPool('${preset.id}', '${layer.id}', ${idx})">âœ•</button>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem;">
                                        <select id="addTraitPool_${preset.id}_${layer.id}" style="flex: 1;">
                                            <option value="">Add trait...</option>
                                            ${layerTraits.filter(t => !(traitSpec?.pool || []).some(p => (typeof p === 'string' ? p : p.id) === t.id)).map(t => `
                                                <option value="${t.id}">${t.name}</option>
                                            `).join('')}
                                        </select>
                                        <button class="btn btn-secondary btn-sm" onclick="addPresetTraitToPool('${preset.id}', '${layer.id}')">+</button>
                                    </div>
                                ` : ''}
                            </div>
                        `;}).join('')}
                        ${layers.length === 0 ? '<div style="color: var(--text-muted); font-size: 0.8rem;">No layers defined</div>' : ''}
                    </div>
                </div>

                ${(() => {
                    const actions = config.nodes.filter(n => n.type === 'action');
                    if (actions.length === 0) return '';
                    const presetActions = preset.actions || {};
                    return `
                    <div class="detail-section">
                        <div class="detail-section-title">Action Weights <span style="color: var(--text-muted); font-weight: normal; font-size: 0.8rem;">(override defaults)</span></div>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem; max-height: 200px; overflow-y: auto;">
                            ${actions.map(action => {
                                const actionOverride = presetActions[action.id];
                                const hasOverride = actionOverride !== undefined;
                                const weight = hasOverride ? (actionOverride.weight ?? action.config.baseWeight ?? 50) : null;
                                return `
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <input type="checkbox" ${hasOverride ? 'checked' : ''}
                                           onchange="togglePresetActionOverride('${preset.id}', '${action.id}', this.checked)"
                                           title="Enable weight override">
                                    <span class="dot action"></span>
                                    <span style="flex: 1;">${action.name}</span>
                                    ${hasOverride ? `
                                        <input type="number" style="width: 60px;" value="${weight}" min="0"
                                               onchange="updatePresetActionWeight('${preset.id}', '${action.id}', this.value)"
                                               placeholder="weight">
                                    ` : `
                                        <span style="color: var(--text-muted); font-size: 0.8rem;">(default: ${action.config.baseWeight ?? 50})</span>
                                    `}
                                </div>
                            `;}).join('')}
                        </div>
                    </div>
                    `;
                })()}

                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                    <button class="btn btn-danger" onclick="deletePreset('${preset.id}')">Delete Preset</button>
                </div>
            `;
        }

        // DEPRECATED v3.3: selectPresetGroup is now defined in Persistence section
        // Legacy alias kept for old Presets view callers
        // function selectPresetGroup â€” see line ~36653

        function selectPreset(presetId) {
            selectedPresetId = presetId;
            render();
        }

        function updatePreset(presetId, field, value) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (field === 'id') {
                // Update all references
                const oldId = presetId;
                preset.id = value;
                selectedPresetId = value;
            } else {
                preset[field] = value;
            }

            render();
        }

        function togglePresetTrait(presetId, traitId, checked) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.forceTraits) preset.forceTraits = [];

            if (checked) {
                if (!preset.forceTraits.includes(traitId)) {
                    preset.forceTraits.push(traitId);
                }
            } else {
                preset.forceTraits = preset.forceTraits.filter(t => t !== traitId);
            }

            renderEntitiesView(document.getElementById('viewContent'));
        }

        function updatePresetAttribute(presetId, attrId, value) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.attributes) preset.attributes = {};

            if (value === '' || value === null || value === undefined) {
                delete preset.attributes[attrId];
            } else {
                preset.attributes[attrId] = parseFloat(value) || 0;
            }

            render();
        }

        // Get the mode of a preset attribute value
        function getPresetAttrMode(attrVal) {
            if (attrVal === undefined || attrVal === null) return 'default';
            if (typeof attrVal === 'number') return 'fixed';
            if (typeof attrVal === 'object') {
                if (attrVal.min !== undefined && attrVal.max !== undefined) return 'range';
                if (attrVal.base !== undefined) return 'variance';
                if (attrVal.value !== undefined) return 'fixed';
            }
            return 'default';
        }

        // Set the mode for a preset attribute (switches between default/fixed/range/variance)
        function setPresetAttrMode(presetId, attrId, mode) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.attributes) preset.attributes = {};
            const attr = config.nodes.find(n => n.id === attrId);
            const range = attr?.config?.defaultRange || [attr?.config?.min || 0, attr?.config?.max || 100];
            const mid = Math.round((range[0] + range[1]) / 2);

            if (mode === 'default') {
                delete preset.attributes[attrId];
            } else if (mode === 'fixed') {
                preset.attributes[attrId] = mid;
            } else if (mode === 'range') {
                preset.attributes[attrId] = { min: range[0], max: range[1] };
            } else if (mode === 'variance') {
                const variance = Math.round((range[1] - range[0]) / 4);
                preset.attributes[attrId] = { base: mid, variance: variance };
            }

            render();
        }

        // Update a fixed preset attribute value
        function updatePresetAttrFixed(presetId, attrId, value) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.attributes) preset.attributes = {};

            if (value === '' || value === null || value === undefined) {
                delete preset.attributes[attrId];
            } else {
                preset.attributes[attrId] = parseFloat(value) || 0;
            }

            render();
        }

        // Update a range preset attribute (min/max)
        function updatePresetAttrRange(presetId, attrId, field, value) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.attributes) preset.attributes = {};
            if (!preset.attributes[attrId] || typeof preset.attributes[attrId] !== 'object') {
                preset.attributes[attrId] = { min: 0, max: 100 };
            }

            preset.attributes[attrId][field] = parseFloat(value) || 0;
            render();
        }

        // Update a variance preset attribute (base/variance)
        function updatePresetAttrVariance(presetId, attrId, field, value) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.attributes) preset.attributes = {};
            if (!preset.attributes[attrId] || typeof preset.attributes[attrId] !== 'object') {
                preset.attributes[attrId] = { base: 50, variance: 10 };
            }

            preset.attributes[attrId][field] = parseFloat(value) || 0;
            render();
        }

        // ========================================
        // PRESET TRAIT SELECTION HELPERS
        // ========================================

        // Get the selection mode for a layer's trait spec
        function getPresetTraitMode(traitSpec) {
            if (!traitSpec) return 'none';
            if (typeof traitSpec === 'string') return 'fixed';
            if (Array.isArray(traitSpec)) return 'fixed';
            if (typeof traitSpec === 'object') {
                return traitSpec.mode || 'weighted';
            }
            return 'none';
        }

        // Set the selection mode for a layer
        function setPresetTraitMode(presetId, layerId, mode) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.traits) preset.traits = {};

            if (mode === 'none') {
                delete preset.traits[layerId];
            } else if (mode === 'fixed') {
                preset.traits[layerId] = '';  // Empty until they select
            } else if (mode === 'weighted') {
                preset.traits[layerId] = { mode: 'weighted', pool: [] };
            } else if (mode === 'chance') {
                preset.traits[layerId] = { mode: 'chance', chance: 0.5, pool: [] };
            } else if (mode === 'pickN') {
                preset.traits[layerId] = { mode: 'pickN', count: 1, pool: [] };
            }

            render();
        }

        // Set a fixed trait for a layer
        function setPresetTraitFixed(presetId, layerId, traitId) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.traits) preset.traits = {};
            preset.traits[layerId] = traitId || null;
            if (!traitId) delete preset.traits[layerId];

            render();
        }

        // Add a trait to a pool (weighted or pickN mode)
        function addPresetTraitToPool(presetId, layerId) {
            const select = document.getElementById(`addTraitPool_${presetId}_${layerId}`);
            const traitId = select?.value;
            if (!traitId) return;

            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset || !preset.traits || !preset.traits[layerId]) return;

            const spec = preset.traits[layerId];
            if (typeof spec !== 'object' || !spec.pool) return;

            // Add with default weight of 1
            spec.pool.push({ id: traitId, weight: 1 });
            select.value = '';
            render();
        }

        // Remove a trait from pool
        function removePresetTraitFromPool(presetId, layerId, index) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset || !preset.traits || !preset.traits[layerId]) return;

            const spec = preset.traits[layerId];
            if (typeof spec !== 'object' || !spec.pool) return;

            spec.pool.splice(index, 1);
            render();
        }

        // Update weight for a pool item
        function updatePresetTraitPoolWeight(presetId, layerId, index, weight) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset || !preset.traits || !preset.traits[layerId]) return;

            const spec = preset.traits[layerId];
            if (typeof spec !== 'object' || !spec.pool || !spec.pool[index]) return;

            // Ensure pool item is object format
            if (typeof spec.pool[index] === 'string') {
                spec.pool[index] = { id: spec.pool[index], weight: parseFloat(weight) || 1 };
            } else {
                spec.pool[index].weight = parseFloat(weight) || 1;
            }
            render();
        }

        // Update chance value for chance mode
        function updatePresetTraitChance(presetId, layerId, chance) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset || !preset.traits || !preset.traits[layerId]) return;

            const spec = preset.traits[layerId];
            if (typeof spec !== 'object') return;

            spec.chance = Math.max(0, Math.min(1, parseFloat(chance) || 0));
            render();
        }

        // Set the pool trait for chance mode (single item)
        function setPresetTraitChancePool(presetId, layerId, traitId) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset || !preset.traits || !preset.traits[layerId]) return;

            const spec = preset.traits[layerId];
            if (typeof spec !== 'object') return;

            spec.pool = traitId ? [traitId] : [];
            render();
        }

        // Update pick count for pickN mode
        function updatePresetTraitPickCount(presetId, layerId, count) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset || !preset.traits || !preset.traits[layerId]) return;

            const spec = preset.traits[layerId];
            if (typeof spec !== 'object') return;

            spec.count = Math.max(1, parseInt(count) || 1);
            render();
        }

        function togglePresetForceTrait(presetId, traitId, checked) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.forceTraits) preset.forceTraits = [];

            if (checked && !preset.forceTraits.includes(traitId)) {
                preset.forceTraits.push(traitId);
            } else if (!checked) {
                preset.forceTraits = preset.forceTraits.filter(t => t !== traitId);
            }

            render();
        }

        // Toggle action weight override in preset
        function togglePresetActionOverride(presetId, actionId, enabled) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.actions) preset.actions = {};

            if (enabled) {
                const action = config.nodes.find(n => n.id === actionId);
                preset.actions[actionId] = { weight: action?.config?.baseWeight ?? 50 };
            } else {
                delete preset.actions[actionId];
            }

            render();
        }

        // Update action weight in preset
        function updatePresetActionWeight(presetId, actionId, weight) {
            const presets = config.presets || [];
            const preset = presets.find(p => p.id === presetId);
            if (!preset) return;

            if (!preset.actions) preset.actions = {};
            if (!preset.actions[actionId]) preset.actions[actionId] = {};

            preset.actions[actionId].weight = parseFloat(weight) || 0;

            render();
        }

        function deletePreset(presetId) {
            if (!confirm('Delete this preset?')) return;

            config.presets = (config.presets || []).filter(p => p.id !== presetId);
            if (selectedPresetId === presetId) selectedPresetId = null;
            render();
        }

        function openAddPresetModal() {
            // On persistence tab, use inline detail panel instead of full-screen modal
            if (currentView === 'persistence') {
                addingNewPreset = true;
                addingNewGroup = false;
                selectedPresetId = null;
                renderPersistenceView(document.getElementById('viewContent'));
                return;
            }
            const modal = document.getElementById('addNodeModal');
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const layers = config.nodes.filter(n => n.type === 'layer');
            // Include items (in layers), modifiers, and standalone traits as forceable
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item' || n.type === 'modifier');

            // Build force traits HTML organized by layer
            let forceTraitsHtml = '';
            if (traits.length > 0) {
                // Group traits by layer
                const traitsByLayer = {};
                const modifiersList = [];
                const orphanTraits = [];

                traits.forEach(trait => {
                    if (trait.type === 'modifier') {
                        modifiersList.push(trait);
                    } else if (trait.config?.layerId) {
                        const layer = layers.find(l => l.id === trait.config.layerId);
                        const layerName = layer?.name || trait.config.layerId;
                        if (!traitsByLayer[layerName]) traitsByLayer[layerName] = { layer, traits: [] };
                        traitsByLayer[layerName].traits.push(trait);
                    } else {
                        orphanTraits.push(trait);
                    }
                });

                // Sort layers by order
                const sortedLayers = Object.entries(traitsByLayer).sort((a, b) => {
                    const orderA = a[1].layer?.config?.order ?? 999;
                    const orderB = b[1].layer?.config?.order ?? 999;
                    return orderA - orderB;
                });

                forceTraitsHtml = `
                    <div class="form-group">
                        <label>Force Traits <span style="color: var(--text-muted); font-weight: normal;">(always apply these)</span></label>
                        <div style="max-height: 200px; overflow-y: auto; margin-top: 0.5rem; border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem;">
                            ${sortedLayers.map(([layerName, data]) => `
                                <div style="margin-bottom: 0.75rem;">
                                    <div style="font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--accent-secondary); margin-bottom: 0.35rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span class="dot layer" style="width: 6px; height: 6px;"></span>
                                        ${layerName}
                                    </div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.4rem 0.75rem; padding-left: 0.5rem;">
                                        ${data.traits.map(trait => `
                                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.8rem; cursor: pointer;">
                                                <input type="checkbox" id="newPresetTrait_${trait.id}" value="${trait.id}">
                                                <span class="dot ${trait.type}" style="width: 6px; height: 6px;"></span>
                                                ${trait.name}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            `).join('')}
                            ${modifiersList.length > 0 ? `
                                <div style="margin-bottom: 0.75rem; padding-top: 0.5rem; border-top: 1px solid var(--border-color);">
                                    <div style="font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--node-modifier); margin-bottom: 0.35rem; display: flex; align-items: center; gap: 0.5rem;">
                                        <span class="dot modifier" style="width: 6px; height: 6px;"></span>
                                        Modifiers
                                    </div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.4rem 0.75rem; padding-left: 0.5rem;">
                                        ${modifiersList.map(mod => `
                                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.8rem; cursor: pointer;">
                                                <input type="checkbox" id="newPresetTrait_${mod.id}" value="${mod.id}">
                                                <span class="dot modifier" style="width: 6px; height: 6px;"></span>
                                                ${mod.name}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                            ${orphanTraits.length > 0 ? `
                                <div style="margin-bottom: 0.5rem; padding-top: 0.5rem; border-top: 1px solid var(--border-color);">
                                    <div style="font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.1em; color: var(--text-muted); margin-bottom: 0.35rem;">
                                        Unassigned
                                    </div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 0.4rem 0.75rem; padding-left: 0.5rem;">
                                        ${orphanTraits.map(trait => `
                                            <label style="display: flex; align-items: center; gap: 0.3rem; font-size: 0.8rem; cursor: pointer;">
                                                <input type="checkbox" id="newPresetTrait_${trait.id}" value="${trait.id}">
                                                ${trait.name}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            modal.innerHTML = `
                <div class="modal-content" style="max-width: 550px;">
                    <h2>Add New Preset</h2>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-group">
                            <label>Preset ID</label>
                            <input type="text" id="newPresetId" placeholder="e.g., elite_variant" oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9_]/g, '_')">
                        </div>
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" id="newPresetName" placeholder="Elite Variant">
                        </div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <div class="form-group">
                            <label>Group</label>
                            <select id="newPresetGroup">
                                <option value="">No Group</option>
                                ${(config.presetGroups || []).map(g => `<option value="${g.id}">${g.name}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Tags (comma-separated)</label>
                            <input type="text" id="newPresetTags" placeholder="elite, boss, rare">
                        </div>
                    </div>

                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="newPresetDesc" rows="2" placeholder="A specialized entity variant..."></textarea>
                    </div>

                    ${attributes.length > 0 ? `
                        <div class="form-group">
                            <label>Attribute Overrides <span style="color: var(--text-muted); font-weight: normal;">(leave blank for default)</span></label>
                            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem; margin-top: 0.5rem;">
                                ${attributes.map(attr => `
                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                        <label style="font-size: 0.8rem; min-width: 60px;">${attr.name}</label>
                                        <input type="number" id="newPresetAttr_${attr.id}"
                                               placeholder="${attr.config?.defaultRange ? attr.config.defaultRange.join('-') : 'auto'}"
                                               style="width: 60px;">
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}

                    ${forceTraitsHtml}

                    <div class="modal-actions">
                        <button class="btn" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="addNewPreset()">Add Preset</button>
                    </div>
                </div>
            `;
            modal.classList.add('active');
        }

        function addNewPreset() {
            const id = document.getElementById('newPresetId').value.trim();
            const name = document.getElementById('newPresetName').value.trim();
            const group = document.getElementById('newPresetGroup').value || null;
            const tagsInput = document.getElementById('newPresetTags').value.trim();
            const description = document.getElementById('newPresetDesc').value.trim();

            if (!id) {
                alert('Please enter a preset ID');
                return;
            }

            if (!config.presets) config.presets = [];

            if (config.presets.some(p => p.id === id)) {
                alert('A preset with this ID already exists');
                return;
            }

            // Parse tags
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim()).filter(t => t) : [];

            // Collect attribute overrides
            const attributes = {};
            config.nodes.filter(n => n.type === 'attribute').forEach(attr => {
                const input = document.getElementById(`newPresetAttr_${attr.id}`);
                if (input && input.value !== '') {
                    attributes[attr.id] = parseFloat(input.value);
                }
            });

            // Collect forced traits (items, modifiers, standalone traits)
            const forceTraits = [];
            config.nodes.filter(n => n.type === 'trait' || n.type === 'item' || n.type === 'modifier').forEach(trait => {
                const checkbox = document.getElementById(`newPresetTrait_${trait.id}`);
                if (checkbox && checkbox.checked) {
                    forceTraits.push(trait.id);
                }
            });

            config.presets.push({
                id,
                name: name || id,
                description,
                group,
                tags,
                attributes,
                contexts: {},
                forceTraits
            });

            selectedPresetId = id;
            closeModal();
            render();
        }

        function openAddPresetGroupModal() {
            const modal = document.getElementById('addNodeModal');
            const groups = config.presetGroups || [];
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 400px;">
                    <h2>Add Preset Group</h2>
                    <div class="form-group">
                        <label>Group ID</label>
                        <input type="text" id="newGroupId" placeholder="e.g., enemies" oninput="this.value = this.value.toLowerCase().replace(/[^a-z0-9_]/g, '_')">
                    </div>
                    <div class="form-group">
                        <label>Name</label>
                        <input type="text" id="newGroupName" placeholder="Entity Templates">
                    </div>
                    <div class="form-group">
                        <label>Parent Group</label>
                        <select id="newGroupParent">
                            <option value="">(None â€” root level)</option>
                            ${groups.map(g => `<option value="${g.id}">${g.name}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="newGroupDesc" rows="2" placeholder="Optional description"></textarea>
                    </div>
                    <div class="modal-actions">
                        <button class="btn" onclick="closeModal()">Cancel</button>
                        <button class="btn btn-primary" onclick="addNewPresetGroup()">Add Group</button>
                    </div>
                </div>
            `;
            modal.classList.add('active');
        }

        function addNewPresetGroup() {
            const id = document.getElementById('newGroupId').value.trim();
            const name = document.getElementById('newGroupName').value.trim();
            const description = document.getElementById('newGroupDesc').value.trim();
            const parentId = document.getElementById('newGroupParent')?.value || null;

            if (!id) {
                alert('Please enter a group ID');
                return;
            }

            if (!config.presetGroups) config.presetGroups = [];

            if (config.presetGroups.some(g => g.id === id)) {
                alert('A group with this ID already exists');
                return;
            }

            config.presetGroups.push({
                id,
                name: name || id,
                description,
                parentId: parentId || null
            });

            // Auto-expand parent so new group is visible
            if (parentId && window._expandedPresetGroups) {
                window._expandedPresetGroups.add(parentId);
            }

            selectedPresetGroupId = id;
            closeModal();
            saveToStorage();
            if (currentView === 'persistence') {
                renderPersistenceView(document.getElementById('viewContent'));
            } else {
                render();
            }
        }

        function deletePresetGroup(groupId) {
            const childGroups = getChildGroups(groupId);
            const hasChildren = childGroups.length > 0;
            const msg = hasChildren
                ? 'Delete this group and all sub-groups? Presets will be moved to Ungrouped.'
                : 'Delete this group? Presets will be moved to Ungrouped.';
            if (!confirm(msg)) return;

            // Get all descendant group IDs to delete
            const allGroupIds = [groupId, ...getDescendantGroupIds(groupId)];

            // Move presets from all deleted groups to ungrouped
            (config.presets || []).forEach(p => {
                if (allGroupIds.includes(p.group)) p.group = null;
            });

            config.presetGroups = (config.presetGroups || []).filter(g => !allGroupIds.includes(g.id));

            if (allGroupIds.includes(selectedPresetGroupId)) selectedPresetGroupId = null;
            saveToStorage();
            if (currentView === 'persistence') {
                renderPersistenceView(document.getElementById('viewContent'));
            } else {
                render();
            }
        }

        // Get spawn order for a node (attributes use spawnOrder, layers use order)
        function getNodeSpawnOrder(node) {
            if (!node) return null;
            if (node.type === 'attribute') return node.config?.spawnOrder ?? 0;
            if (node.type === 'layer') return node.config?.order ?? 0;
            // Traits inherit their layer's order
            if (node.type === 'trait' || node.type === 'item') {
                const layer = config.nodes.find(n => n.id === node.config?.layerId);
                return layer ? (layer.config?.order ?? 0) : null;
            }
            // Variables, contexts, modifiers, etc. don't have spawn order
            return null;
        }

        // Check if a relationship is "upstream" (target spawns before source, so relationship has no effect)
        function isUpstreamRelationship(rel) {
            const source = config.nodes.find(n => n.id === rel.sourceId);
            const target = config.nodes.find(n => n.id === rel.targetId);
            if (!source || !target) return false;

            const sourceOrder = getNodeSpawnOrder(source);
            const targetOrder = getNodeSpawnOrder(target);

            // If either doesn't have spawn order, we can't determine direction
            if (sourceOrder === null || targetOrder === null) return false;

            // Upstream means target spawns before source (lower order = earlier)
            // For the relationship to work, source must spawn BEFORE target
            return sourceOrder > targetOrder;
        }

        function renderDetailPanel() {
            const titleEl = document.getElementById('detailTitle');
            const actionsEl = document.getElementById('detailActions');
            const contentEl = document.getElementById('detailContent');

            // Auto-collapse detail panel when nothing selected
            const mainLayout = document.querySelector('.main-layout');
            if (mainLayout) {
                mainLayout.classList.toggle('detail-collapsed', !selectedNodeId);
            }

            if (!selectedNodeId) {
                titleEl.textContent = 'No Selection';
                actionsEl.style.display = 'none';
                contentEl.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">â—‡</div>
                        <div class="empty-state-text">No node selected</div>
                        <div class="empty-state-hint">Click a node to view and edit its properties</div>
                    </div>
                `;
                return;
            }

            const node = config.nodes.find(n => n.id === selectedNodeId);
            if (!node) {
                selectedNodeId = null;
                renderDetailPanel();
                return;
            }

            titleEl.textContent = node.name;
            actionsEl.style.display = 'flex';

            const incomingRels = config.relationships.filter(r => r.targetId === node.id);
            const outgoingRels = config.relationships.filter(r => r.sourceId === node.id);

            contentEl.innerHTML = `
                <div style="display: flex; justify-content: flex-end; margin-bottom: 0.5rem;">
                    <button class="btn btn-sm btn-secondary" onclick="duplicateNode()" title="Duplicate this node" style="font-size: 0.7rem;">â§‰ Duplicate</button>
                </div>
                <div class="detail-section">
                    <div class="detail-section-title">Basic Info</div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>ID <span class="help-icon" title="Unique identifier. Changing this may break connections. Click lock to edit.">?</span></label>
                            <div style="display: flex; gap: 0.25rem;">
                                <input type="text" id="detailNodeId" value="${node.id}" disabled style="flex: 1; opacity: 0.7;"
                                       onchange="handleDetailIdChange('${node.id}', this.value)">
                                <button type="button" id="detailIdLockBtn" class="btn btn-icon" onclick="toggleDetailIdLock()" title="Toggle ID lock" style="min-width: 32px; padding: 0.25rem;">ðŸ”’</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Type</label>
                            <input type="text" value="${node.type}" disabled>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Name</label>
                        <input type="text" value="${node.name}" onchange="updateNode('${node.id}', 'name', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Description</label>
                        <textarea rows="2" onchange="updateNode('${node.id}', 'description', this.value)">${node.description || ''}</textarea>
                    </div>
                </div>

                ${['item', 'trait', 'modifier', 'action'].includes(node.type) ? `
                <div class="detail-section">
                    <div class="detail-section-title">Taxonomy <span style="color: var(--text-muted); font-weight: normal; font-size: 0.8rem;">(categorization)</span></div>
                    <div class="form-row" style="gap: 0.5rem;">
                        <div class="form-group" style="flex: 1;">
                            <label>Type</label>
                            <input type="text" value="${node.taxonomy?.type || ''}"
                                   placeholder="e.g., humanoid"
                                   onchange="updateNodeTaxonomy('${node.id}', 'type', this.value)">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label>Subtype</label>
                            <input type="text" value="${node.taxonomy?.subtype || ''}"
                                   placeholder="e.g., goblinoid"
                                   onchange="updateNodeTaxonomy('${node.id}', 'subtype', this.value)">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label>Variant</label>
                            <input type="text" value="${node.taxonomy?.variant || ''}"
                                   placeholder="e.g., scout"
                                   onchange="updateNodeTaxonomy('${node.id}', 'variant', this.value)">
                        </div>
                    </div>
                </div>
                ` : ''}

                ${renderNodeTypeConfig(node)}

                <div class="detail-section">
                    <div class="detail-section-title">Incoming Connections (${incomingRels.length})</div>
                    ${incomingRels.length > 0 ? `
                        <div class="relationship-list">
                            ${incomingRels.map(rel => {
                                const source = config.nodes.find(n => n.id === rel.sourceId);
                                const isUpstream = isUpstreamRelationship(rel);
                                return `
                                    <div class="relationship-item ${isUpstream ? 'upstream' : ''}">
                                        <span class="dot ${source?.type || ''}"></span>
                                        ${source?.name || rel.sourceId}
                                        <span class="arrow">â†’</span>
                                        ${rel.type}
                                        <span class="value">${rel.config.operation} ${rel.config.value}</span>
                                        ${isUpstream ? '<span class="upstream-warning" title="Upstream: Source spawns after target, so this relationship may not have effect at spawn time">âš </span>' : ''}
                                        <button class="btn btn-icon edit-btn" onclick="selectNode('${rel.sourceId}'); showEditRelationshipModal('${rel.id}')" title="Edit">âœŽ</button>
                                        <button class="btn btn-icon btn-danger delete-btn" onclick="deleteRelationship('${rel.id}')">âœ•</button>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : '<div style="color: var(--text-muted); font-size: 0.8rem;">None</div>'}
                    ${['derived', 'ticksystem'].includes(node.type) ? `
                        <button class="btn btn-secondary btn-sm" style="margin-top: 0.5rem;" onclick="showAddIncomingConnection('${node.id}')">+ add incoming connection</button>
                    ` : ''}
                </div>

                <div class="detail-section">
                    <div class="detail-section-title">Outgoing Connections (${outgoingRels.length})</div>
                    ${outgoingRels.length > 0 ? `
                        <div class="relationship-list">
                            ${outgoingRels.map(rel => {
                                const target = config.nodes.find(n => n.id === rel.targetId);
                                const isUpstream = isUpstreamRelationship(rel);
                                return `
                                    <div class="relationship-item ${isUpstream ? 'upstream' : ''}">
                                        ${rel.type}
                                        <span class="arrow">â†’</span>
                                        <span class="dot ${target?.type || ''}"></span>
                                        ${target?.name || rel.targetId}
                                        <span class="value">${rel.config.operation} ${rel.config.value}</span>
                                        ${isUpstream ? '<span class="upstream-warning" title="Upstream: Source spawns after target, so this relationship may not have effect at spawn time">âš </span>' : ''}
                                        <button class="btn btn-icon edit-btn" onclick="showEditRelationshipModal('${rel.id}')" title="Edit">âœŽ</button>
                                        <button class="btn btn-icon btn-danger delete-btn" onclick="deleteRelationship('${rel.id}')">âœ•</button>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : '<div style="color: var(--text-muted); font-size: 0.8rem;">None</div>'}
                    <button class="btn btn-secondary btn-sm" style="margin-top: 0.5rem;" onclick="showAddRelationshipModal()">+ define connection</button>
                </div>

                ${renderNodeCodeSnippet(node)}

                <div class="detail-section" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                    <button class="btn btn-sm btn-danger" onclick="deleteSelectedNode()" style="width: 100%; font-size: 0.75rem;">Delete ${node.name}</button>
                </div>
            `;
        }

        function renderNodeCodeSnippet(node) {
            const snippets = getNodeCodeSnippets(node);
            if (!snippets) return '';

            return `
                <div class="detail-section">
                    <div class="detail-section-title" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>ðŸ’» Code Snippet</span>
                        <button class="btn btn-sm" onclick="copyNodeSnippet('${node.id}')" style="padding: 0.2rem 0.5rem; font-size: 0.7rem;">
                            ðŸ“‹ Copy
                        </button>
                    </div>
                    <pre id="nodeSnippet_${node.id}" class="node-code-snippet" onclick="copyNodeSnippet('${node.id}')" style="
                        background: var(--bg-dark);
                        border: 1px solid var(--border-color);
                        border-radius: 4px;
                        padding: 0.75rem;
                        font-family: 'Consolas', 'Monaco', monospace;
                        font-size: 0.75rem;
                        line-height: 1.4;
                        overflow-x: auto;
                        cursor: pointer;
                        margin: 0;
                        color: var(--text-primary);
                        white-space: pre;
                    ">${snippets}</pre>
                </div>
            `;
        }

        function getNodeCodeSnippets(node) {
            const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');

            switch (node.type) {
                case 'attribute':
                    return `// Get ${node.name}
const ${node.id.replace(/^attr_/, '')} = engine.getAttribute(entity.id, '${node.id}');`;

                case 'variable':
                    return `// Get ${node.name}
const ${node.id.replace(/^var_/, '')} = engine.getVariable(entity.id, '${node.id}');

// Modify ${node.name}
engine.modifyVariable(entity.id, '${node.id}', -10); // subtract
engine.modifyVariable(entity.id, '${node.id}', +10); // add
engine.setVariable(entity.id, '${node.id}', 50);     // set exact`;

                case 'modifier': {
                    const bindings = node.config?.tickBindings || [];
                    let code = `// Apply ${node.name}
engine.applyModifier(entity.id, '${node.id}');

// Remove ${node.name}
engine.removeModifier(entity.id, '${node.id}');

// Check if active
const has${node.id.replace(/^mod_/, '').replace(/_/g, '').replace(/^\w/, c => c.toUpperCase())} = engine.hasModifier(entity.id, '${node.id}');`;

                    if (bindings.length > 0) {
                        code += `\n\n// Get remaining duration
const remaining = engine.getModifierDuration(entity.id, '${node.id}');`;
                    }
                    return code;
                }

                case 'compound': {
                    const requires = node.config?.requires || [];
                    const reqNames = requires.map(r => {
                        if (r.itemId) {
                            const item = config.nodes.find(n => n.id === r.itemId);
                            return item?.name || r.itemId;
                        }
                        return r.condition?.target || 'condition';
                    }).join(' + ');

                    return `// Check if ${node.name} is active
const is${node.id.replace(/^comp_/, '').replace(/_/g, '').replace(/^\w/, c => c.toUpperCase())} = engine.hasCompound(entity.id, '${node.id}');

// Listen for activation
engine.on('compoundActivated', ({ entityId, compoundId }) => {
    if (compoundId === '${node.id}') {
        // ${node.name} triggered! (${reqNames || 'requirements met'})
    }
});`;
                }

                case 'trait':
                case 'item':
                    return `// Check if ${node.name} is active
const has${node.id.replace(/^(trait_|item_)/, '').replace(/_/g, '').replace(/^\w/, c => c.toUpperCase())} = engine.hasTrait(entity.id, '${node.id}');

// Force activate/deactivate
engine.activateTrait(entity.id, '${node.id}');
engine.deactivateTrait(entity.id, '${node.id}');`;

                case 'ticksystem': {
                    const isManual = node.config?.tickUnit?.type === 'manual';
                    const tickLabel = node.config?.tickUnit?.label || 'tick';

                    // Find bound modifiers
                    const boundMods = config.nodes.filter(n =>
                        n.type === 'modifier' &&
                        n.config?.tickBindings?.some(b => b.tickSystemId === node.id)
                    );

                    let code = `// Start ${node.name}
engine.startTickSystem(entity.id, '${node.id}');

// Stop ${node.name}
engine.stopTickSystem(entity.id, '${node.id}');

// Reset to ${tickLabel} 0
engine.resetTickSystem(entity.id, '${node.id}');`;

                    if (isManual) {
                        code += `\n\n// Advance by 1 ${tickLabel}
engine.advanceTick(entity.id, '${node.id}');`;
                    }

                    code += `\n\n// Get current ${tickLabel}
const current = engine.getCurrentTick(entity.id, '${node.id}');`;

                    if (boundMods.length > 0) {
                        code += `\n\n// Bound modifiers: ${boundMods.map(m => m.name).join(', ')}`;
                    }

                    return code;
                }

                case 'derived':
                    return `// Get computed ${node.name}
const ${node.id.replace(/^derived_/, '')} = engine.getDerived(entity.id, '${node.id}');
// Formula: ${node.config?.formula || 'N/A'}`;

                case 'layer':
                    return `// Get active items from ${node.name} layer
const ${node.id.replace(/^layer_/, '')}Items = engine.getLayerItems(entity.id, '${node.id}');`;

                default:
                    return null;
            }
        }

        function copyNodeSnippet(nodeId) {
            const pre = document.getElementById('nodeSnippet_' + nodeId);
            if (!pre) return;

            navigator.clipboard.writeText(pre.textContent).then(() => {
                pre.style.borderColor = 'var(--accent-success)';
                pre.style.background = 'rgba(111, 156, 93, 0.1)';
                setTimeout(() => {
                    pre.style.borderColor = 'var(--border-color)';
                    pre.style.background = 'var(--bg-dark)';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        // Render the traits section for a layer's detail panel
        function renderLayerTraitsSection(layerNode) {
            // Get all traits that belong to this layer
            const traits = config.nodes.filter(n =>
                (n.type === 'trait' || n.type === 'item') && n.config.layerId === layerNode.id
            );

            if (traits.length === 0) {
                return `
                    <div class="detail-section">
                        <div class="detail-section-title">Contained Traits</div>
                        <div style="color: var(--text-muted); font-size: 0.85rem; padding: 0.5rem 0;">
                            No traits in this layer yet. Add traits and assign them to this layer.
                        </div>
                    </div>
                `;
            }

            // Calculate total weight for probability display
            const totalWeight = traits.reduce((sum, t) => sum + (t.config.selection?.baseWeight ?? 20), 0);

            // Build probability data for stacked bar
            const weightedTraitsForBar = traits
                .filter(t => t.config.selection?.mode !== 'threshold')
                .map((t, i) => {
                    const weight = t.config.selection?.baseWeight ?? 20;
                    const pct = totalWeight > 0 ? Math.round((weight / totalWeight) * 100) : 0;
                    return { name: t.name, pct, id: t.id };
                });

            // Build traits list HTML
            const traitsHtml = traits.map((trait, traitIdx) => {
                const weight = trait.config.selection?.baseWeight ?? 20;
                const probability = totalWeight > 0 ? ((weight / totalWeight) * 100).toFixed(1) : 0;
                const isThreshold = trait.config.selection?.mode === 'threshold';
                const tColor = getTraitColor(traitIdx);

                return `
                    <div class="layer-trait-item" onclick="selectNode('${trait.id}')" style="
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 0.5rem 0.75rem;
                        margin: 0.25rem 0;
                        background: var(--bg-card);
                        border-radius: 4px;
                        cursor: pointer;
                        border-left: 3px solid ${tColor};
                        transition: background 0.2s;
                    " onmouseover="this.style.background='var(--bg-hover)'" onmouseout="this.style.background='var(--bg-card)'">
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span class="prob-color-dot" style="background: ${tColor};"></span>
                            <span style="font-weight: 500;">${trait.name}</span>
                            ${isThreshold ? '<span style="font-size: 0.7rem; color: var(--node-variable); background: rgba(230, 162, 60, 0.15); padding: 0.1rem 0.35rem; border-radius: 3px;">threshold</span>' : ''}
                        </div>
                        <div style="display: flex; align-items: center; gap: 0.75rem; font-size: 0.85rem;">
                            ${!isThreshold ? `
                                <span style="color: var(--text-muted);">Weight: <strong style="color: var(--text-primary);">${weight}</strong></span>
                                <span style="color: var(--accent-secondary);">${probability}%</span>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            // Count weighted vs threshold traits
            const weightedTraits = traits.filter(t => t.config.selection?.mode !== 'threshold');
            const thresholdTraits = traits.filter(t => t.config.selection?.mode === 'threshold');

            return `
                <div class="detail-section">
                    <div class="detail-section-title" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>Contained Traits (${traits.length})</span>
                        ${weightedTraits.length > 1 ? `
                            <button class="btn btn-sm" onclick="equalizeLayerWeights('${layerNode.id}')"
                                    title="Set all weighted traits to equal probability (1/n)">
                                Even Weights
                            </button>
                        ` : ''}
                    </div>
                    ${weightedTraitsForBar.length > 1 ? renderStackedProbBar(weightedTraitsForBar, { height: 14 }) : ''}
                    ${weightedTraits.length > 0 ? `
                        <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                            Total weight: ${totalWeight} ${thresholdTraits.length > 0 ? `(${weightedTraits.length} weighted, ${thresholdTraits.length} threshold)` : ''}
                        </div>
                    ` : ''}
                    <div class="layer-traits-list" style="max-height: 200px; overflow-y: auto;">
                        ${traitsHtml}
                    </div>
                </div>
            `;
        }

        // Equalize weights for all weighted traits in a layer
        // silent = true skips the toast (for auto-equalize on trait add/remove)
        function equalizeLayerWeights(layerId, silent = false) {
            const layer = config.nodes.find(n => n.id === layerId && n.type === 'layer');
            if (!layer) return;

            const traits = config.nodes.filter(n =>
                (n.type === 'trait' || n.type === 'item') &&
                n.config.layerId === layerId &&
                n.config.selection?.mode !== 'threshold'
            );

            if (traits.length === 0) return;

            // Set all to the same weight (20 is a good default that leaves room for relationship modifiers)
            const equalWeight = 20;
            traits.forEach(trait => {
                if (!trait.config.selection) trait.config.selection = {};
                trait.config.selection.baseWeight = equalWeight;
            });

            // Save and refresh
            if (typeof saveToStorage === 'function') saveToStorage();
            renderDetailPanel();
            if (!silent) {
                showToast(`Equalized ${traits.length} trait weights to ${equalWeight}`, 'success');
            }
        }

        // Auto-equalize weights for a layer if setting is enabled
        function autoEqualizeLayerIfEnabled(layerId) {
            const layer = config.nodes.find(n => n.id === layerId && n.type === 'layer');
            if (layer && layer.config.autoEqualizeWeights !== false) {
                equalizeLayerWeights(layerId, true); // silent
            }
        }

        // Auto-equalize all layers that have the setting enabled (called on config load)
        function autoEqualizeAllLayers() {
            const layers = config.nodes.filter(n => n.type === 'layer');
            layers.forEach(layer => {
                if (layer.config.autoEqualizeWeights !== false) {
                    equalizeLayerWeights(layer.id, true);
                }
            });
        }

        function renderNodeTypeConfig(node) {
            switch (node.type) {
                case 'attribute':
                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Attribute Config</div>
                            <div class="form-row form-row-4">
                                <div class="form-group">
                                    <label>Min</label>
                                    <input type="number" value="${node.config.min ?? 1}"
                                           onchange="updateNodeConfig('${node.id}', 'min', parseFloat(this.value))">
                                </div>
                                <div class="form-group">
                                    <label>Max</label>
                                    <input type="number" value="${node.config.max ?? 10}"
                                           onchange="updateNodeConfig('${node.id}', 'max', parseFloat(this.value))">
                                </div>
                                <div class="form-group">
                                    <label>Precision</label>
                                    <input type="number" value="${node.config.precision ?? 0}" min="0" max="4"
                                           onchange="updateNodeConfig('${node.id}', 'precision', parseInt(this.value))">
                                </div>
                                <div class="form-group">
                                    <label>Spawn Order</label>
                                    <input type="number" value="${node.config.spawnOrder ?? 0}" min="0"
                                           onchange="updateNodeConfig('${node.id}', 'spawnOrder', parseInt(this.value))"
                                           title="Evaluation order at spawn (lower = earlier). Attributes can be influenced by traits that spawn first.">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Default Range (comma-separated)</label>
                                <input type="text" value="${(node.config.defaultRange || []).join(', ')}"
                                       placeholder="1, 10"
                                       onchange="updateNodeConfig('${node.id}', 'defaultRange', this.value.split(',').map(v => parseFloat(v.trim())))">
                            </div>
                        </div>
                    `;

                case 'variable':
                    // Support both legacy 'initial' (single value) and new 'initialRange' (array)
                    const initRange = node.config.initialRange || [node.config.initial ?? 80, node.config.initial ?? 80];
                    const varTickSystems = config.nodes.filter(n => n.type === 'ticksystem');
                    const showVarTickSystem = (node.config.changeMode === 'perTick') && varTickSystems.length > 0;
                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Variable Config</div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Bounds Min</label>
                                    <input type="number" value="${node.config.min ?? 0}"
                                           onchange="updateNodeConfig('${node.id}', 'min', parseFloat(this.value))">
                                </div>
                                <div class="form-group">
                                    <label>Bounds Max</label>
                                    <input type="number" value="${node.config.max ?? 100}"
                                           onchange="updateNodeConfig('${node.id}', 'max', parseFloat(this.value))">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Initial Min</label>
                                    <input type="number" value="${initRange[0] ?? 80}"
                                           onchange="updateVariableInitialRange('${node.id}', 0, parseFloat(this.value))">
                                </div>
                                <div class="form-group">
                                    <label>Initial Max</label>
                                    <input type="number" value="${initRange[1] ?? 80}"
                                           onchange="updateVariableInitialRange('${node.id}', 1, parseFloat(this.value))">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Change Mode</label>
                                <select onchange="updateNodeConfig('${node.id}', 'changeMode', this.value); render();">
                                    <option value="manual" ${node.config.changeMode === 'manual' ? 'selected' : ''}>Manual</option>
                                    <option value="timed" ${node.config.changeMode === 'timed' ? 'selected' : ''}>Timed (per second)</option>
                                    <option value="perTick" ${node.config.changeMode === 'perTick' ? 'selected' : ''}>Per Tick</option>
                                </select>
                            </div>
                            ${(node.config.changeMode === 'timed' || node.config.changeMode === 'perTick') ? `
                            <div class="form-group">
                                <label>Base Rate <span class="help-icon" title="Negative = depletes, Positive = accumulates, 0 = no change">?</span></label>
                                <input type="number" step="0.1" value="${node.config.baseRate ?? 0}"
                                       onchange="updateNodeConfig('${node.id}', 'baseRate', parseFloat(this.value))">
                            </div>
                            ` : ''}
                            ${showVarTickSystem ? `
                            <div class="form-group">
                                <label>Tick System <span class="help-icon" title="Which tick system drives this variable's per-tick changes">?</span></label>
                                <select onchange="updateNodeConfig('${node.id}', 'tickSystemId', this.value)">
                                    <option value="">-- Select tick system --</option>
                                    ${varTickSystems.map(ts => `
                                        <option value="${ts.id}" ${node.config.tickSystemId === ts.id ? 'selected' : ''}>${ts.name} (${ts.config?.tickUnit?.label || 'tick'})</option>
                                    `).join('')}
                                </select>
                            </div>
                            ` : ''}
                        </div>
                    `;

                case 'layer':
                    // Support both legacy single initialRolls and new range [min, max]
                    const rollRange = node.config.selection?.rollRange ||
                        [node.config.selection?.initialRolls ?? 1, node.config.selection?.initialRolls ?? 1];
                    const rollAt = node.config.timing?.rollAt || 'spawn';
                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Layer Config</div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Order</label>
                                    <input type="number" value="${node.config.order ?? 0}"
                                           onchange="updateNodeConfig('${node.id}', 'order', parseInt(this.value))"
                                           title="Layer evaluation order (lower = earlier)">
                                </div>
                                <div class="form-group">
                                    <label>Selection Mode</label>
                                    <select onchange="updateNodeConfigNested('${node.id}', 'selection', 'mode', this.value)">
                                        <option value="weighted" ${node.config.selection?.mode === 'weighted' ? 'selected' : ''}>Weighted</option>
                                        <option value="allMatching" ${node.config.selection?.mode === 'allMatching' ? 'selected' : ''}>All Matching</option>
                                        <option value="pickN" ${node.config.selection?.mode === 'pickN' ? 'selected' : ''}>Pick N</option>
                                        <option value="firstMatch" ${node.config.selection?.mode === 'firstMatch' ? 'selected' : ''}>First Match</option>
                                    </select>
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Roll Timing</label>
                                    <select onchange="updateNodeConfigNested('${node.id}', 'timing', 'rollAt', this.value)"
                                            title="When to roll this layer">
                                        <option value="spawn" ${rollAt === 'spawn' ? 'selected' : ''}>At Spawn</option>
                                        <option value="manual" ${rollAt === 'manual' ? 'selected' : ''}>Manual (Outcome)</option>
                                        <option value="never" ${rollAt === 'never' ? 'selected' : ''}>Never (Threshold Only)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Max Active</label>
                                    <input type="number" value="${node.config.selection?.maxItems ?? 10}" min="1"
                                           onchange="updateNodeConfigNested('${node.id}', 'selection', 'maxItems', parseInt(this.value))"
                                           title="Maximum traits that can be active from this layer at once">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Min Rolls</label>
                                    <input type="number" value="${rollRange[0]}" min="0"
                                           onchange="updateLayerRollRange('${node.id}', 0, parseInt(this.value))"
                                           title="Minimum traits to select from this layer">
                                </div>
                                <div class="form-group">
                                    <label>Max Rolls</label>
                                    <input type="number" value="${rollRange[1]}" min="0"
                                           onchange="updateLayerRollRange('${node.id}', 1, parseInt(this.value))"
                                           title="Maximum traits to select from this layer">
                                </div>
                            </div>
                            <div class="form-group" style="margin-top: 0.75rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;"
                                       title="When enabled, all traits in this layer have equal base probability (1/n where n = trait count). Relationships can still modify selection weights dynamically.">
                                    <input type="checkbox" ${node.config.autoEqualizeWeights !== false ? 'checked' : ''}
                                           onchange="updateNodeConfig('${node.id}', 'autoEqualizeWeights', this.checked); if(this.checked) equalizeLayerWeights('${node.id}', true);"
                                           style="width: auto;">
                                    Even Distribution
                                    <span class="help-icon" title="All traits have equal weight (1/n where n = trait count). Relationships can still modify probabilities.">?</span>
                                </label>
                            </div>
                            <div class="form-row" style="margin-top: 0.5rem;">
                                <div class="form-group" style="flex: 1;">
                                    <label>Weight Floor <span class="help-icon" title="Minimum weight after influences. Prevents traits from dropping to 0% when negative influences are strong. Default: 0.">?</span></label>
                                    <input type="number" value="${node.config.selection?.weightFloor ?? 0}" min="0" step="1"
                                           onchange="updateLayerSelectionConfig('${node.id}', 'weightFloor', parseFloat(this.value) || 0)"
                                           style="width: 70px;">
                                </div>
                                <div class="form-group" style="flex: 1;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;"
                                           title="Compresses large influence effects using square root scaling. Prevents extreme probability differentials when positive and negative influences compound.">
                                        <input type="checkbox" ${node.config.selection?.diminishingReturns ? 'checked' : ''}
                                               onchange="updateLayerSelectionConfig('${node.id}', 'diminishingReturns', this.checked)"
                                               style="width: auto;">
                                        Diminishing Returns
                                        <span class="help-icon" title="Uses sqrt scaling on influence effects. Large influences are compressed more than small ones, keeping probabilities more balanced.">?</span>
                                    </label>
                                </div>
                            </div>
                            ${rollAt === 'manual' ? `
                            <div class="layer-outcome-hint" style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(230, 162, 60, 0.1); border: 1px solid var(--node-action); border-radius: 4px;">
                                <div style="font-size: 0.75rem; color: var(--node-action);">
                                    <strong>Outcome Layer:</strong> Use <code>engine.rollOutcome(entity, '${node.id}')</code> to roll during gameplay (e.g., attack/defense results).
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        ${renderLayerTraitsSection(node)}
                    `;

                case 'item':
                case 'trait':
                    const layers = config.nodes.filter(n => n.type === 'layer');
                    const variables = config.nodes.filter(n => n.type === 'variable');
                    const isThreshold = node.config.selection?.mode === 'threshold';
                    const trigger = node.config.selection?.trigger || {};
                    const autoRemove = node.config.selection?.autoRemove || null;

                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Trait Config</div>
                            <div class="form-group">
                                <label>Parent Layer</label>
                                <select onchange="updateNodeConfig('${node.id}', 'layerId', this.value)">
                                    ${layers.map(l => `
                                        <option value="${l.id}" ${node.config.layerId === l.id ? 'selected' : ''}>${l.name}</option>
                                    `).join('')}
                                </select>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Base Weight</label>
                                    <input type="number" value="${node.config.selection?.baseWeight ?? 20}"
                                           onchange="updateNodeConfigNested('${node.id}', 'selection', 'baseWeight', parseFloat(this.value))">
                                </div>
                                <div class="form-group">
                                    <label>Selection Mode</label>
                                    <select onchange="handleSelectionModeChange('${node.id}', this.value)">
                                        <option value="weighted" ${node.config.selection?.mode === 'weighted' ? 'selected' : ''}>Weighted</option>
                                        <option value="threshold" ${node.config.selection?.mode === 'threshold' ? 'selected' : ''}>Threshold</option>
                                    </select>
                                </div>
                            </div>
                            ${node.config.layerId ? renderLayerProbabilityVisual(node.config.layerId) : ''}
                        </div>
                        ${isThreshold ? `
                        <div class="detail-section">
                            <div class="detail-section-title">Threshold Trigger</div>
                            <div class="form-group">
                                <label>Target Variable</label>
                                <select onchange="updateThresholdTrigger('${node.id}', 'target', this.value)">
                                    <option value="">-- Select Variable --</option>
                                    ${variables.map(v => `
                                        <option value="${v.id}" ${trigger.target === v.id ? 'selected' : ''}>${v.name}</option>
                                    `).join('')}
                                </select>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Operator</label>
                                    <select onchange="updateThresholdTrigger('${node.id}', 'operator', this.value)">
                                        <option value="<=" ${trigger.operator === '<=' ? 'selected' : ''}>\u2264 (less/equal)</option>
                                        <option value=">=" ${trigger.operator === '>=' ? 'selected' : ''}>\u2265 (greater/equal)</option>
                                        <option value="<" ${trigger.operator === '<' ? 'selected' : ''}>&lt; (less than)</option>
                                        <option value=">" ${trigger.operator === '>' ? 'selected' : ''}>&gt; (greater than)</option>
                                        <option value="==" ${trigger.operator === '==' ? 'selected' : ''}>== (equals)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Trigger Value</label>
                                    <input type="number" value="${trigger.value ?? 0}"
                                           onchange="updateThresholdTrigger('${node.id}', 'value', parseFloat(this.value))">
                                </div>
                            </div>
                            <div class="form-group" style="margin-top: 0.75rem;">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                    <input type="checkbox" ${autoRemove ? 'checked' : ''}
                                           onchange="toggleAutoRemove('${node.id}', this.checked)"
                                           style="width: auto;">
                                    Auto-remove when condition clears
                                </label>
                            </div>
                            ${autoRemove ? `
                            <div class="form-row" style="margin-top: 0.5rem; padding-left: 1rem; border-left: 2px solid var(--border-color);">
                                <div class="form-group">
                                    <label>Clear Operator</label>
                                    <select onchange="updateAutoRemove('${node.id}', 'operator', this.value)">
                                        <option value="<=" ${autoRemove.operator === '<=' ? 'selected' : ''}>\u2264 (less/equal)</option>
                                        <option value=">=" ${autoRemove.operator === '>=' ? 'selected' : ''}>\u2265 (greater/equal)</option>
                                        <option value="<" ${autoRemove.operator === '<' ? 'selected' : ''}>&lt; (less than)</option>
                                        <option value=">" ${autoRemove.operator === '>' ? 'selected' : ''}>&gt; (greater than)</option>
                                        <option value="==" ${autoRemove.operator === '==' ? 'selected' : ''}>== (equals)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Clear Value</label>
                                    <input type="number" value="${autoRemove.value ?? 0}"
                                           onchange="updateAutoRemove('${node.id}', 'value', parseFloat(this.value))">
                                </div>
                            </div>
                            ` : ''}
                        </div>
                        ` : ''}
                        ${(() => {
                            // Incompatibility section - get other traits
                            const otherTraits = config.nodes.filter(n =>
                                (n.type === 'item' || n.type === 'trait') && n.id !== node.id
                            );
                            const currentIncompat = node.config.incompatibleWith || [];
                            const incompatNodes = currentIncompat.map(id => {
                                const n = config.nodes.find(node => node.id === id);
                                const layer = n?.config?.layerId ? config.nodes.find(l => l.id === n.config.layerId) : null;
                                return { id, name: n?.name || id, layerName: layer?.name || '' };
                            });

                            // Group available traits by layer
                            const availableByLayer = {};
                            otherTraits.filter(t => !currentIncompat.includes(t.id)).forEach(t => {
                                const layer = config.nodes.find(n => n.id === t.config?.layerId);
                                const layerName = layer?.name || 'Unassigned';
                                if (!availableByLayer[layerName]) availableByLayer[layerName] = [];
                                availableByLayer[layerName].push(t);
                            });

                            return `
                        <div class="detail-section">
                            <div class="detail-section-title">
                                Incompatible Traits
                                <span class="help-icon" title="Mutually exclusive - cannot be selected together. Changes apply bidirectionally (â†”).">?</span>
                            </div>
                            <div class="incompatibility-list">
                                ${incompatNodes.length > 0 ? incompatNodes.map(inc => `
                                    <div class="incompat-item">
                                        <span class="incompat-icon">âŠ˜</span>
                                        <span>${inc.name}</span>
                                        ${inc.layerName ? `<span class="incompat-layer">${inc.layerName}</span>` : ''}
                                        <span class="incompat-sync-badge" title="Bidirectional - removing here removes from both">â†”</span>
                                        <button class="btn btn-icon delete-btn"
                                            onclick="removeIncompatibility('${node.id}', '${inc.id}')" title="Remove">âœ•</button>
                                    </div>
                                `).join('') : '<div class="empty-hint">No incompatibilities defined</div>'}
                            </div>
                            <div class="incompat-add">
                                <select id="incompatAdd_${node.id}">
                                    <option value="">Add incompatible trait...</option>
                                    ${Object.entries(availableByLayer).map(([layerName, traits]) =>
                                        traits.length > 0 ? `<optgroup label="${layerName}">${traits.map(t =>
                                            `<option value="${t.id}">${t.name}</option>`
                                        ).join('')}</optgroup>` : ''
                                    ).join('')}
                                </select>
                                <button class="btn btn-secondary btn-sm" onclick="addIncompatFromDropdown('${node.id}')">+ Add</button>
                            </div>
                        </div>
                        <div class="detail-section">
                            <div class="detail-section-title">
                                Quick Weight Influence
                                <span class="help-icon" title="Adjust probability of other traits. Positive = more likely, Negative = less likely. For fine control, use 'define connection' below.">?</span>
                            </div>
                            <div class="weight-influence-quick">
                                <select id="influenceTarget_${node.id}">
                                    <option value="">Select trait to influence...</option>
                                    ${Object.entries(availableByLayer).map(([layerName, traits]) =>
                                        traits.length > 0 ? `<optgroup label="${layerName}">${traits.map(t =>
                                            `<option value="${t.id}">${t.name}</option>`
                                        ).join('')}</optgroup>` : ''
                                    ).join('')}
                                </select>
                                <div class="influence-buttons">
                                    <button class="btn btn-sm btn-influence-pos" onclick="addQuickInfluence('${node.id}', 20)" title="+20 weight influence">+Likely</button>
                                    <button class="btn btn-sm btn-influence-neg" onclick="addQuickInfluence('${node.id}', -20)" title="-20 weight influence">âˆ’Likely</button>
                                </div>
                            </div>
                            <div class="influence-note">For fine control, use "+ define connection" below</div>
                        </div>
                            `;
                        })()}`;

                case 'compound':
                    // Get all potential required nodes (traits, modifiers, items, attributes, variables)
                    const requireableNodes = config.nodes.filter(n =>
                        ['trait', 'item', 'modifier', 'attribute', 'variable'].includes(n.type)
                    );

                    // Parse current requires array, handling both string and object formats
                    const currentRequires = (node.config.requires || []).map(req => {
                        // Handle both string and object formats
                        if (typeof req === 'string') {
                            const reqNode = config.nodes.find(n => n.id === req);
                            return { id: req, name: reqNode?.name || req, type: reqNode?.type || 'unknown', operator: null, value: null };
                        } else {
                            const nodeId = req.id || req.item || req.modifier || req.trait || req.attribute || req.variable;
                            const reqNode = config.nodes.find(n => n.id === nodeId);
                            return {
                                id: nodeId,
                                name: reqNode?.name || nodeId,
                                type: reqNode?.type || 'unknown',
                                operator: req.operator || null,
                                value: req.value ?? null
                            };
                        }
                    });

                    // Group available nodes by type
                    const availableByType = {};
                    requireableNodes.forEach(n => {
                        if (!currentRequires.some(r => r.id === n.id)) {
                            if (!availableByType[n.type]) availableByType[n.type] = [];
                            availableByType[n.type].push(n);
                        }
                    });

                    const typeLabels = { trait: 'Traits', item: 'Items', modifier: 'Modifiers', attribute: 'Attributes', variable: 'Variables' };
                    const operatorLabels = { '<': '<', '<=': 'â‰¤', '>': '>', '>=': 'â‰¥', '=': '=' };

                    // Helper to format requirement display
                    const formatReqDisplay = (req) => {
                        if (req.operator && req.value !== null) {
                            return `${req.name} ${operatorLabels[req.operator] || req.operator} ${req.value}`;
                        }
                        return `${req.name} is active`;
                    };

                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Compound Config</div>
                            <div class="form-group">
                                <label>Requirements (${currentRequires.length})</label>
                                <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem;">
                                    Compound activates when <strong>ALL</strong> requirements are met
                                </div>
                                <div class="compound-requires-list" id="compoundRequiresList_${node.id}">
                                    ${currentRequires.length > 0 ? currentRequires.map(req => `
                                        <div class="compound-require-item" style="display: flex; align-items: center; gap: 0.5rem;">
                                            <span class="dot ${req.type}"></span>
                                            <span style="flex: 1;">${formatReqDisplay(req)}</span>
                                            ${req.operator ? '<span class="threshold-badge" title="Threshold condition">âš¡</span>' : ''}
                                            <button class="btn btn-icon delete-btn"
                                                onclick="removeCompoundRequirement('${node.id}', '${req.id}')" title="Remove">âœ•</button>
                                        </div>
                                    `).join('') : '<div class="empty-hint">No requirements defined</div>'}
                                </div>
                                <div class="compound-add-require" style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <select id="compoundAddRequire_${node.id}" style="flex: 2;" onchange="updateCompoundRequireOperatorVisibility('${node.id}')">
                                            <option value="">Select node...</option>
                                            ${Object.entries(availableByType).map(([type, nodes]) =>
                                                nodes.length > 0 ? `<optgroup label="${typeLabels[type] || type}">${nodes.map(n =>
                                                    `<option value="${n.id}" data-type="${n.type}">${n.name}</option>`
                                                ).join('')}</optgroup>` : ''
                                            ).join('')}
                                        </select>
                                        <select id="compoundAddOp_${node.id}" style="flex: 1; display: none;">
                                            <option value="">is active</option>
                                            <option value="<">&lt;</option>
                                            <option value="<=">â‰¤</option>
                                            <option value=">">></option>
                                            <option value=">=">â‰¥</option>
                                            <option value="=">=</option>
                                        </select>
                                        <input type="number" id="compoundAddValue_${node.id}" placeholder="value" style="flex: 1; display: none; width: 60px;">
                                        <button class="btn btn-secondary btn-sm" onclick="addCompoundRequirement('${node.id}')">+ Add</button>
                                    </div>
                                    <div id="compoundAddHint_${node.id}" style="font-size: 0.75rem; color: var(--text-muted);">
                                        Select a node to add as requirement
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                case 'modifier':
                    const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');
                    const tickBindings = node.config.tickBindings || [];
                    const modTrigger = node.config.trigger || {};
                    const modTriggerType = modTrigger.type || node.config.triggerType || 'manual';
                    const modIsThreshold = modTriggerType === 'threshold';
                    const modIsStatic = modTrigger.static || false;
                    const showDuration = node.config.durationType !== 'permanent' && !modIsStatic;

                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Trigger Config</div>
                            <div class="form-group">
                                <label class="static-checkbox-label" style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                    <input type="checkbox" ${modIsThreshold ? 'checked' : ''} onchange="updateModifierTriggerTypeDetail('${node.id}', this.checked ? 'threshold' : 'manual')">
                                    <span>Threshold Trigger</span>
                                    <span class="help-icon" title="When enabled, modifier auto-applies when variable conditions are met. When disabled, modifier is applied manually via game code.">?</span>
                                </label>
                            </div>
                            ${modIsThreshold ? `
                                <div class="threshold-config-section">
                                    <div class="form-group static-mode-row">
                                        <label class="static-checkbox-label">
                                            <input type="checkbox" ${modIsStatic ? 'checked' : ''} onchange="updateModifierStaticModeDetail('${node.id}', this.checked)">
                                            <span>Static (reactive)</span>
                                            <span class="help-icon" title="Auto-removes when conditions no longer met">?</span>
                                        </label>
                                    </div>
                                    <div class="form-group" style="margin-top: 0.5rem;">
                                        <label style="display: flex; justify-content: space-between; align-items: center;">
                                            <span>Apply Conditions</span>
                                            <button class="btn btn-xs" onclick="addDetailCondition('${node.id}')">+ Add</button>
                                        </label>
                                        <div id="detailConditionsList_${node.id}" class="detail-conditions-list">
                                            ${renderEditableDetailConditions(node.id, modTrigger.conditions || [])}
                                        </div>
                                    </div>
                                    ${modIsStatic ? `
                                        <div class="reactive-note">
                                            <span class="reactive-icon">â†º</span> Reactive: auto-removes when conditions no longer met
                                        </div>
                                    ` : ''}
                                    <!-- Exclusive With (detail panel) -->
                                    <div style="margin-top: 0.75rem; padding: 0.6rem; background: rgba(0,0,0,0.15); border-radius: 4px; border-left: 3px solid var(--copper);">
                                        <label style="display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.4rem; font-size: 0.8rem;">
                                            <span>Exclusive With</span>
                                            <span class="help-icon" title="Mutually exclusive modifiers. When multiple trigger, the most specific wins.">?</span>
                                        </label>
                                        <div style="display: flex; flex-wrap: wrap; gap: 0.3rem; margin-bottom: 0.4rem;">
                                            ${(node.config.exclusiveWith || []).map(exId => {
                                                const exNode = config.nodes.find(n => n.id === exId);
                                                return `<span class="exclusive-chip" style="display: inline-flex; align-items: center; gap: 0.3rem; padding: 0.15rem 0.5rem; background: rgba(167,141,182,0.2); border: 1px solid var(--copper-dark); border-radius: 12px; font-size: 0.75rem;">
                                                    <span class="dot modifier" style="width: 6px; height: 6px;"></span>
                                                    ${exNode?.name || exId}
                                                    <button class="btn-icon" onclick="removeDetailExclusive('${node.id}', '${exId}')" style="background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 0; font-size: 0.7rem;" title="Remove">&times;</button>
                                                </span>`;
                                            }).join('')}
                                        </div>
                                        <select onchange="addDetailExclusive('${node.id}', this.value); this.value='';" style="font-size: 0.8rem; width: 100%;">
                                            <option value="">+ Add exclusive modifier...</option>
                                            ${config.nodes.filter(n => n.type === 'modifier' && n.id !== node.id && !(node.config.exclusiveWith || []).includes(n.id)).map(n =>
                                                `<option value="${n.id}">${n.name}</option>`
                                            ).join('')}
                                        </select>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div class="detail-section" ${modIsStatic ? 'style="display: none;"' : ''}>
                            <div class="detail-section-title">Duration Config</div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Duration Type</label>
                                    <select onchange="updateNodeConfig('${node.id}', 'durationType', this.value); render();">
                                        <option value="ticks" ${node.config.durationType === 'ticks' ? 'selected' : ''}>Tick-based</option>
                                        <option value="permanent" ${node.config.durationType === 'permanent' ? 'selected' : ''}>Permanent</option>
                                    </select>
                                </div>
                                <div class="form-group" style="${showDuration ? '' : 'display: none;'}">
                                    <label>Default Duration</label>
                                    <input type="number" value="${node.config.duration ?? 10}" min="0"
                                           onchange="updateNodeConfig('${node.id}', 'duration', parseInt(this.value))">
                                </div>
                            </div>
                        </div>
                        <div class="detail-section">
                            <div class="detail-section-title">Stacking</div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Stacking Mode</label>
                                    <select onchange="updateNodeConfig('${node.id}', 'stacking', this.value)">
                                        <option value="refresh" ${node.config.stacking === 'refresh' ? 'selected' : ''}>Refresh (reset duration)</option>
                                        <option value="stack" ${node.config.stacking === 'stack' ? 'selected' : ''}>Stack (add stacks)</option>
                                        <option value="ignore" ${node.config.stacking === 'ignore' ? 'selected' : ''}>Ignore (no effect)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Max Stacks</label>
                                    <input type="number" value="${node.config.maxStacks ?? 1}" min="1"
                                           onchange="updateNodeConfig('${node.id}', 'maxStacks', parseInt(this.value))">
                                </div>
                            </div>
                        </div>
                        <div class="detail-section">
                            <div class="detail-section-title">
                                Tick System Bindings
                                <span class="help-icon" title="Connect this modifier to tick systems for duration tracking">?</span>
                            </div>
                            ${tickSystems.length === 0 ? `
                                <div class="empty-hint">No tick systems defined. <a href="#" onclick="switchView('ticks'); return false;">Create one</a> to bind modifier duration.</div>
                            ` : `
                                <div class="tick-bindings-list">
                                    ${tickBindings.length > 0 ? tickBindings.map((binding, idx) => {
                                        const ts = config.nodes.find(n => n.id === binding.tickSystemId);
                                        return `
                                            <div class="tick-binding-item">
                                                <div class="tick-binding-header">
                                                    <span class="dot ticksystem"></span>
                                                    <span class="binding-system">${ts?.name || binding.tickSystemId}</span>
                                                    <button class="btn btn-icon btn-danger btn-sm" onclick="removeTickBinding('${node.id}', ${idx})" title="Remove">âœ•</button>
                                                </div>
                                                <div class="tick-binding-config">
                                                    <div class="form-group">
                                                        <label>Duration</label>
                                                        <input type="number" value="${binding.duration || 3}" min="1"
                                                               onchange="updateTickBinding('${node.id}', ${idx}, 'duration', parseInt(this.value))">
                                                        <span class="unit-label">${ts?.config?.tickUnit?.label || 'ticks'}</span>
                                                    </div>
                                                    <div class="form-group">
                                                        <label>When System Stops</label>
                                                        <select onchange="updateTickBinding('${node.id}', ${idx}, 'fallbackBehavior', this.value)">
                                                            <option value="pause" ${binding.fallbackBehavior === 'pause' ? 'selected' : ''}>Pause (resume later)</option>
                                                            <option value="expire" ${binding.fallbackBehavior === 'expire' ? 'selected' : ''}>Expire (remove immediately)</option>
                                                            <option value="continue" ${binding.fallbackBehavior === 'continue' ? 'selected' : ''}>Continue (tick anyway)</option>
                                                        </select>
                                                    </div>
                                                </div>
                                            </div>
                                        `;
                                    }).join('') : '<div class="empty-hint">No tick bindings. Add one below to track duration.</div>'}
                                </div>
                                <div class="tick-binding-add">
                                    <select id="tickBindingAdd_${node.id}">
                                        <option value="">Add tick system binding...</option>
                                        ${tickSystems.filter(ts => !tickBindings.some(b => b.tickSystemId === ts.id)).map(ts => `
                                            <option value="${ts.id}">${ts.name} (${ts.config?.tickUnit?.label || 'tick'})</option>
                                        `).join('')}
                                    </select>
                                    <button class="btn btn-secondary btn-sm" onclick="addTickBinding('${node.id}')">+ Add</button>
                                </div>
                            `}
                        </div>
                    `;

                case 'ticksystem':
                    // Tick system detail is rendered in the Ticks tab, but show basic info here
                    const tickConfig = node.config || {};
                    const tickUnit = tickConfig.tickUnit || { type: 'manual', value: 1000, label: 'tick' };
                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Tick System Config</div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Tick Type</label>
                                    <select onchange="updateTickSystemConfig('${node.id}', 'tickUnit.type', this.value)">
                                        <option value="manual" ${tickUnit.type === 'manual' ? 'selected' : ''}>Manual (API/Turn-based)</option>
                                        <option value="timed" ${tickUnit.type === 'timed' ? 'selected' : ''}>Timed (Auto-advance)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Label</label>
                                    <input type="text" value="${tickUnit.label || 'tick'}"
                                           onchange="updateTickSystemConfig('${node.id}', 'tickUnit.label', this.value)">
                                </div>
                            </div>
                            ${tickUnit.type === 'timed' ? `
                                <div class="form-group">
                                    <label>Interval (ms)</label>
                                    <input type="number" value="${tickUnit.value || 1000}" min="100"
                                           onchange="updateTickSystemConfig('${node.id}', 'tickUnit.value', parseInt(this.value))">
                                </div>
                            ` : ''}
                            <div class="tick-system-link">
                                <a href="#" onclick="switchView('ticks'); selectNode('${node.id}'); return false;">
                                    Open in Ticks Tab for full configuration â†’
                                </a>
                            </div>
                        </div>
                    `;

                case 'action':
                    const actionVariables = config.nodes.filter(n => n.type === 'variable');
                    const actionTraits = config.nodes.filter(n => ['item', 'trait', 'modifier'].includes(n.type));
                    const actionCosts = node.config.costs || {};
                    const actionRequirements = node.config.requirements || [];
                    const actionBlockedBy = node.config.blockedBy || [];
                    const actionEffects = node.config.effects || {};

                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Action Config</div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Base Weight</label>
                                    <input type="number" value="${node.config.baseWeight ?? 50}" min="0"
                                           onchange="updateNodeConfig('${node.id}', 'baseWeight', parseFloat(this.value))"
                                           title="Base probability weight for action selection">
                                </div>
                                <div class="form-group">
                                    <label>Cooldown (seconds)</label>
                                    <input type="number" value="${node.config.cooldown ?? 0}" min="0" step="0.1"
                                           onchange="updateNodeConfig('${node.id}', 'cooldown', parseFloat(this.value))"
                                           title="Time before action can be used again">
                                </div>
                            </div>
                        </div>
                        <div class="detail-section">
                            <div class="detail-section-title">
                                Costs
                                <span class="help-icon" title="Variable costs deducted when action executes. Action unavailable if cost can't be paid.">?</span>
                            </div>
                            <div class="action-costs-list" id="actionCostsList_${node.id}">
                                ${Object.keys(actionCosts).length > 0 ? Object.entries(actionCosts).map(([varId, cost]) => {
                                    const varNode = config.nodes.find(n => n.id === varId);
                                    return `
                                        <div class="action-cost-item">
                                            <span class="dot variable"></span>
                                            <span class="cost-var-name">${varNode?.name || varId}</span>
                                            <input type="number" value="${cost}" min="0" step="1"
                                                   onchange="updateActionCost('${node.id}', '${varId}', parseFloat(this.value))"
                                                   class="cost-value-input">
                                            <button class="btn btn-icon delete-btn"
                                                onclick="removeActionCost('${node.id}', '${varId}')" title="Remove">âœ•</button>
                                        </div>
                                    `;
                                }).join('') : '<div class="empty-hint">No costs defined (free action)</div>'}
                            </div>
                            <div class="action-cost-add">
                                <select id="actionCostAdd_${node.id}">
                                    <option value="">Add cost variable...</option>
                                    ${actionVariables.filter(v => !actionCosts[v.id]).map(v => `
                                        <option value="${v.id}">${v.name}</option>
                                    `).join('')}
                                </select>
                                <button class="btn btn-secondary btn-sm" onclick="addActionCost('${node.id}')">+ Add</button>
                            </div>
                        </div>
                        <div class="detail-section">
                            <div class="detail-section-title">
                                Requirements
                                <span class="help-icon" title="Traits/items that must be active for this action to be available.">?</span>
                            </div>
                            <div class="action-requirements-list" id="actionRequirementsList_${node.id}">
                                ${actionRequirements.length > 0 ? actionRequirements.map(reqId => {
                                    const reqNode = config.nodes.find(n => n.id === reqId);
                                    return `
                                        <div class="action-requirement-item">
                                            <span class="dot ${reqNode?.type || 'item'}"></span>
                                            <span>${reqNode?.name || reqId}</span>
                                            <button class="btn btn-icon delete-btn"
                                                onclick="removeActionRequirement('${node.id}', '${reqId}')" title="Remove">âœ•</button>
                                        </div>
                                    `;
                                }).join('') : '<div class="empty-hint">No requirements (always available if costs met)</div>'}
                            </div>
                            <div class="action-requirement-add">
                                <select id="actionRequirementAdd_${node.id}">
                                    <option value="">Add requirement...</option>
                                    ${actionTraits.filter(t => !actionRequirements.includes(t.id)).map(t => `
                                        <option value="${t.id}">${t.name} (${t.type})</option>
                                    `).join('')}
                                </select>
                                <button class="btn btn-secondary btn-sm" onclick="addActionRequirement('${node.id}')">+ Add</button>
                            </div>
                        </div>
                        <div class="detail-section">
                            <div class="detail-section-title">
                                Blocked By
                                <span class="help-icon" title="Traits/items that prevent this action from being used when active.">?</span>
                            </div>
                            <div class="action-blockedby-list" id="actionBlockedByList_${node.id}">
                                ${actionBlockedBy.length > 0 ? actionBlockedBy.map(blockId => {
                                    const blockNode = config.nodes.find(n => n.id === blockId);
                                    return `
                                        <div class="action-blockedby-item">
                                            <span class="dot ${blockNode?.type || 'item'}"></span>
                                            <span>${blockNode?.name || blockId}</span>
                                            <button class="btn btn-icon delete-btn"
                                                onclick="removeActionBlockedBy('${node.id}', '${blockId}')" title="Remove">âœ•</button>
                                        </div>
                                    `;
                                }).join('') : '<div class="empty-hint">No blockers defined</div>'}
                            </div>
                            <div class="action-blockedby-add">
                                <select id="actionBlockedByAdd_${node.id}">
                                    <option value="">Add blocker...</option>
                                    ${actionTraits.filter(t => !actionBlockedBy.includes(t.id)).map(t => `
                                        <option value="${t.id}">${t.name} (${t.type})</option>
                                    `).join('')}
                                </select>
                                <button class="btn btn-secondary btn-sm" onclick="addActionBlockedBy('${node.id}')">+ Add</button>
                            </div>
                        </div>
                        <div class="detail-section">
                            <div class="detail-section-title">
                                Effects (User-Defined)
                                <span class="help-icon" title="Custom data returned when action executes. Engine stores but doesn't interpret - your game code handles these.">?</span>
                            </div>
                            <div class="form-group">
                                <label>Effects JSON</label>
                                <textarea class="effects-json-input"
                                    placeholder='{"damage": "1d6+attr_attack", "type": "physical"}'
                                    onchange="updateActionEffects('${node.id}', this.value)">${JSON.stringify(actionEffects, null, 2)}</textarea>
                            </div>
                            <div class="effects-note">Define effect data your game code will interpret when this action executes.</div>
                        </div>
                    `;

                case 'derived':
                    const derivedSourceNodes = config.nodes.filter(n =>
                        ['attribute', 'variable', 'derived'].includes(n.type) && n.id !== node.id
                    );
                    initFormulaBlocksEditor(node.id, node.config?.formula, node.config?.formulaGroups, node.config?.formulaBlocks);
                    return `
                        <div class="detail-section">
                            <div class="detail-section-title">Derived Value Config</div>
                            <div class="form-group">
                                <label>Formula <span class="help-icon" title="Build formulas from blocks. Each block has 1-2 values. Blocks evaluate internally, then left-to-right across the formula. Drag to reorder, click to edit.">?</span></label>
                                ${renderFBSection(node.id, derivedSourceNodes, node.config?.formula || '', node.config?.formulaGroups, node.config?.formulaBlocks)}
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Min <span class="help-icon" title="Clamp result to this minimum. Leave empty for no limit.">?</span></label>
                                    <input type="number" value="${node.config?.min ?? ''}"
                                           placeholder="none"
                                           onchange="updateNodeConfig('${node.id}', 'min', this.value ? parseFloat(this.value) : null)">
                                </div>
                                <div class="form-group">
                                    <label>Max <span class="help-icon" title="Clamp result to this maximum. Leave empty for no limit.">?</span></label>
                                    <input type="number" value="${node.config?.max ?? ''}"
                                           placeholder="none"
                                           onchange="updateNodeConfig('${node.id}', 'max', this.value ? parseFloat(this.value) : null)">
                                </div>
                            </div>
                        </div>
                    `;

                default:
                    return '';
            }
        }

        function updateStatusBar() {
            document.getElementById('nodeCount').textContent = config.nodes.length;
            document.getElementById('relationshipCount').textContent = config.relationships.length;
            document.getElementById('tierDisplay').textContent = config.tier;
        }

        // ========================================
        // INTERACTIONS
        // ========================================
        function selectNode(nodeId) {
            selectedNodeId = nodeId;
            render();
        }

        function closeDetailPanel() {
            document.querySelector('.main-layout').classList.add('detail-collapsed');
            // Deselect node so toolbar actions don't use stale selection
            selectedNodeId = null;
            // Remove selection highlight from graph and tree
            document.querySelectorAll('.graph-node.selected').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll('.tree-item.selected').forEach(el => el.classList.remove('selected'));
        }

        function toggleTreeSection(header) {
            header.classList.toggle('collapsed');
            const items = header.nextElementSibling;
            items.classList.toggle('collapsed');
        }

        function switchView(view) {
            // Legacy aliases
            if (view === 'spawn-logic' || view === 'preview') view = 'simulation';
            if (view === 'entities' || view === 'presets') view = 'persistence';

            currentView = view;
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.view === view);
            });
            renderMainView();
        }

        function updateConfigMeta() {
            config.name = document.getElementById('configName').value;
            config.id = document.getElementById('configId').value;
            updateHeaderTitle();
            saveToStorage();
        }

        function updateHeaderTitle() {
            const headerTitle = document.getElementById('headerTitle');
            if (headerTitle) {
                const configName = config.name || '';
                headerTitle.textContent = configName ? configName : 'Spawn Engine Editor';
            }
        }

        function updateNode(nodeId, field, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (node) {
                node[field] = value;
                engine.loadConfig(config);
                saveToStorage();
                // Partial re-render for ticks view to avoid jumping
                if (currentView === 'ticks' && node.type === 'ticksystem') {
                    updateTicksDetailPanel();
                } else {
                    render();
                }
            }
        }

        function updateNodeConfig(nodeId, field, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (node) {
                // Track old layer for auto-equalize when changing trait's layer assignment
                const oldLayerId = (field === 'layerId' && (node.type === 'trait' || node.type === 'item')) ? node.config.layerId : null;

                node.config[field] = value;
                engine.loadConfig(config);
                saveToStorage();
                render();

                // Auto-equalize both old and new layers when trait moves between layers
                if (field === 'layerId' && (node.type === 'trait' || node.type === 'item')) {
                    if (oldLayerId) autoEqualizeLayerIfEnabled(oldLayerId);
                    if (value) autoEqualizeLayerIfEnabled(value);
                }
            }
        }

        function updateNodeTaxonomy(nodeId, field, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.taxonomy) node.taxonomy = {};

            if (value === '' || value === null || value === undefined) {
                delete node.taxonomy[field];
                // Clean up empty taxonomy object
                if (Object.keys(node.taxonomy).length === 0) {
                    node.taxonomy = null;
                }
            } else {
                node.taxonomy[field] = value.trim().toLowerCase();
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function updateNodeConfigNested(nodeId, parent, field, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (node) {
                if (!node.config[parent]) node.config[parent] = {};
                node.config[parent][field] = value;
                engine.loadConfig(config);
                saveToStorage();
                render();
            }
        }

        // Threshold trigger helpers
        function handleSelectionModeChange(nodeId, mode) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.selection) node.config.selection = {};
            node.config.selection.mode = mode;

            // Initialize trigger with defaults when switching to threshold mode
            if (mode === 'threshold' && !node.config.selection.trigger) {
                const variables = config.nodes.filter(n => n.type === 'variable');
                node.config.selection.trigger = {
                    target: variables.length > 0 ? variables[0].id : '',
                    operator: '<=',
                    value: 20
                };
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function updateThresholdTrigger(nodeId, field, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.selection) node.config.selection = {};
            if (!node.config.selection.trigger) node.config.selection.trigger = {};

            node.config.selection.trigger[field] = value;

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function toggleAutoRemove(nodeId, enabled) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node || !node.config.selection) return;

            if (enabled) {
                // Initialize with inverse of trigger by default
                const trigger = node.config.selection.trigger || {};
                const inverseOp = {
                    '<=': '>',
                    '>=': '<',
                    '<': '>=',
                    '>': '<=',
                    '==': '!='
                };
                node.config.selection.autoRemove = {
                    target: trigger.target || '',
                    operator: inverseOp[trigger.operator] || '>',
                    value: (trigger.value ?? 0) + 20 // Default to trigger value + 20
                };
            } else {
                delete node.config.selection.autoRemove;
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function updateAutoRemove(nodeId, field, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node || !node.config.selection?.autoRemove) return;

            node.config.selection.autoRemove[field] = value;

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        // Variable initial range helper
        function updateVariableInitialRange(nodeId, index, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Initialize initialRange if not present
            if (!node.config.initialRange) {
                const current = node.config.initial ?? 80;
                node.config.initialRange = [current, current];
            }

            node.config.initialRange[index] = value;

            // Keep legacy 'initial' in sync (use midpoint)
            node.config.initial = Math.round((node.config.initialRange[0] + node.config.initialRange[1]) / 2);

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        // Layer roll range helper
        function updateLayerRollRange(nodeId, index, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.selection) node.config.selection = {};

            // Initialize rollRange if not present
            if (!node.config.selection.rollRange) {
                const current = node.config.selection.initialRolls ?? 1;
                node.config.selection.rollRange = [current, current];
            }

            node.config.selection.rollRange[index] = value;

            // Keep legacy 'initialRolls' in sync (use min value)
            node.config.selection.initialRolls = node.config.selection.rollRange[0];

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function updateLayerSelectionConfig(nodeId, key, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;
            if (!node.config.selection) node.config.selection = {};
            node.config.selection[key] = value;
            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        // Compound requirement helpers
        function updateCompoundRequireOperatorVisibility(nodeId) {
            const select = document.getElementById(`compoundAddRequire_${nodeId}`);
            const opSelect = document.getElementById(`compoundAddOp_${nodeId}`);
            const valueInput = document.getElementById(`compoundAddValue_${nodeId}`);
            const hint = document.getElementById(`compoundAddHint_${nodeId}`);

            if (!select || !opSelect || !valueInput) return;

            const selectedOption = select.options[select.selectedIndex];
            const nodeType = selectedOption?.dataset?.type;
            const reqNode = config.nodes.find(n => n.id === select.value);

            // Show operator/value only for attributes and variables (numeric types)
            const isNumericType = nodeType === 'attribute' || nodeType === 'variable';
            opSelect.style.display = isNumericType ? 'block' : 'none';
            valueInput.style.display = 'none'; // Hide until operator is selected

            // Reset operator selection
            opSelect.value = '';

            // Update hint text
            if (hint) {
                if (!select.value) {
                    hint.textContent = 'Select a node to add as requirement';
                } else if (isNumericType) {
                    hint.innerHTML = '<strong>Tip:</strong> For numeric nodes, you can set a threshold condition (e.g., "mood â‰¤ 30")';
                } else {
                    hint.textContent = `Will check if "${reqNode?.name || select.value}" is active`;
                }
            }

            // Show/hide value input based on operator
            opSelect.onchange = () => {
                const showValue = opSelect.value !== '';
                valueInput.style.display = showValue ? 'block' : 'none';
                if (showValue && !valueInput.value) {
                    // Default value based on type
                    if (reqNode?.config?.max) {
                        valueInput.value = Math.round(reqNode.config.max * 0.3); // 30% of max as default
                    } else {
                        valueInput.value = 30;
                    }
                }
            };
        }

        function addCompoundRequirement(nodeId) {
            const select = document.getElementById(`compoundAddRequire_${nodeId}`);
            const opSelect = document.getElementById(`compoundAddOp_${nodeId}`);
            const valueInput = document.getElementById(`compoundAddValue_${nodeId}`);
            const reqId = select.value;
            if (!reqId) return;

            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.requires) node.config.requires = [];

            // Get operator and value if set
            const operator = opSelect?.value || '';
            const value = valueInput?.value ? parseFloat(valueInput.value) : null;

            // Build requirement object
            let requirement;
            if (operator && value !== null) {
                // Threshold condition
                requirement = { id: reqId, operator: operator, value: value };
            } else {
                // Simple "is active" check - use string format for backwards compatibility
                requirement = reqId;
            }

            node.config.requires.push(requirement);

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function removeCompoundRequirement(nodeId, reqId) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node || !node.config.requires) return;

            node.config.requires = node.config.requires.filter(req => {
                // Handle both string and object formats
                if (typeof req === 'string') return req !== reqId;
                const id = req.id || req.item || req.modifier || req.trait || req.attribute || req.variable;
                return id !== reqId;
            });

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        // ========================================
        // ACTION NODE HELPERS
        // ========================================
        function updateActionCost(nodeId, varId, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.costs) node.config.costs = {};
            node.config.costs[varId] = value;

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function addActionCost(nodeId) {
            const select = document.getElementById(`actionCostAdd_${nodeId}`);
            const varId = select.value;
            if (!varId) return;

            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.costs) node.config.costs = {};
            node.config.costs[varId] = 10; // Default cost

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function removeActionCost(nodeId, varId) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node || !node.config.costs) return;

            delete node.config.costs[varId];

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function addActionRequirement(nodeId) {
            const select = document.getElementById(`actionRequirementAdd_${nodeId}`);
            const reqId = select.value;
            if (!reqId) return;

            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.requirements) node.config.requirements = [];
            if (!node.config.requirements.includes(reqId)) {
                node.config.requirements.push(reqId);
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function removeActionRequirement(nodeId, reqId) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node || !node.config.requirements) return;

            node.config.requirements = node.config.requirements.filter(id => id !== reqId);

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function addActionBlockedBy(nodeId) {
            const select = document.getElementById(`actionBlockedByAdd_${nodeId}`);
            const blockId = select.value;
            if (!blockId) return;

            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.blockedBy) node.config.blockedBy = [];
            if (!node.config.blockedBy.includes(blockId)) {
                node.config.blockedBy.push(blockId);
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function removeActionBlockedBy(nodeId, blockId) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node || !node.config.blockedBy) return;

            node.config.blockedBy = node.config.blockedBy.filter(id => id !== blockId);

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function updateActionEffects(nodeId, jsonStr) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            try {
                const effects = JSON.parse(jsonStr || '{}');
                node.config.effects = effects;
                engine.loadConfig(config);
                saveToStorage();
                render();
            } catch (e) {
                console.warn('Invalid JSON for action effects:', e);
                // Don't save invalid JSON, just leave it
            }
        }

        // ========================================
        // NODE MANAGEMENT
        // ========================================
        function showAddNodeModal() {
            document.getElementById('addNodeModal').classList.add('active');
            applyModalLayoutPref('addNodeModal');
            // Reset lock state
            userEditedId = false;
            idLocked = true;
            // Clear type selection - user must choose explicitly
            // (Name/ID fields are rendered dynamically when type is selected)
            clearNodeTypeSelection();
        }

        function clearNodeTypeSelection() {
            newNodeType = null;
            document.querySelectorAll('.node-type-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            // Clear the type-specific config area
            const container = document.getElementById('newNodeTypeConfig');
            if (container) {
                container.innerHTML = '<div style="padding: 1rem; text-align: center; color: var(--text-muted); font-size: 0.9rem;">Select a node type above to configure</div>';
            }
        }

        // Open add node modal pre-configured with a specific type (and optional layer for traits)
        function openAddNodeOfType(type, layerId = null) {
            document.getElementById('addNodeModal').classList.add('active');
            applyModalLayoutPref('addNodeModal');

            // Reset lock state before rendering
            userEditedId = false;
            idLocked = true;

            // Select the type first - this renders the Name/ID fields
            selectNodeType(type);

            // Now clear the fields (they exist after selectNodeType renders them)
            setTimeout(() => {
                const idInput = document.getElementById('newNodeId');
                const nameInput = document.getElementById('newNodeName');
                const lockBtn = document.getElementById('idLockBtn');

                if (nameInput) nameInput.value = '';
                if (idInput) {
                    idInput.value = '';
                    idInput.disabled = true;
                    idInput.style.opacity = '0.7';
                }
                if (lockBtn) {
                    lockBtn.textContent = 'ðŸ”’';
                }

                // Pre-select the layer in the dropdown for traits
                if (layerId && (type === 'trait' || type === 'item')) {
                    const layerSelect = document.getElementById('newNodeLayerId');
                    if (layerSelect) {
                        layerSelect.value = layerId;
                        updateTraitWeightPreview();
                    }
                }
            }, 10);
        }

        // Legacy function - use openAddNodeOfType('trait', layerId) instead
        function openAddTraitToLayer(layerId) {
            openAddNodeOfType('trait', layerId);
        }

        // closeModal is now provided by js/utils.js
        // Wrap to clean up connection preview line on relationship modal close
        const _originalCloseModal = closeModal;
        closeModal = function(modalId) {
            _originalCloseModal(modalId);
            if (!modalId || modalId === 'addRelationshipModal') {
                removeConnectionPreviewLine();
            }
        };

        function selectNodeType(type) {
            newNodeType = type;
            document.querySelectorAll('.node-type-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.type === type);
            });
            renderNewNodeTypeConfig();
        }

        const nodeTypeHelp = {
            attribute: {
                tip: 'NUMERIC values assigned at spawn that act as fundamental stats. Can change via game events (e.g., leveling up) but typically stay stable. For categorical "types" (species, class), use a Layer instead!',
                examples: [
                    { game: 'Tavern', example: 'Patience (1-10), Generosity (1-10) - core personality stats' },
                    { game: 'RPG', example: 'Strength (1-20), Dexterity - base stats that can grow with levels' }
                ]
            },
            variable: {
                tip: 'Values that change DURING gameplay. Can deplete (HP, Stamina), accumulate (Rage, Cooldowns), or only change from events (Mana on spell use).',
                examples: [
                    { game: 'Combat', example: 'HP (depletes on damage), Stamina (spent on actions), Rage (builds per hit)' },
                    { game: 'RPG', example: 'Mana (depletes on spells), Cooldown Timer (counts up until ready)' }
                ]
            },
            context: {
                tip: 'External WORLD state that affects spawning. Set by your game before spawning, not by the entity itself.',
                examples: [
                    { game: 'Tavern', example: 'TimeOfDay (morning/evening), IsCrowded (true/false)' },
                    { game: 'Dungeon', example: 'FloorLevel (1-10), DifficultyMode, BiomeType' }
                ]
            },
            layer: {
                tip: 'A CATEGORY for picking items. Use for categorical choices (species, class, personality type). Set maxItems=1 for "pick one" categories.',
                examples: [
                    { game: 'Monster', example: 'Species (max 1): Goblin, Orc, Dragon - mutually exclusive' },
                    { game: 'Tavern', example: 'Personality (max 3): Optimist, Grumpy... - can have multiple' }
                ]
            },
            trait: {
                tip: 'A categorical flag within a layer - something an entity either has or doesn\'t. Has a weight for selection probability. Can influence other traits via relationships.',
                examples: [
                    { game: 'Monster Species', example: 'Goblin (weight 50), Orc (30), Dragon (5) - rarity via weight' },
                    { game: 'Personality', example: 'Optimist, Grumpy, Social Butterfly - traits to select from' }
                ]
            },
            // Backward compatibility alias
            item: {
                tip: 'A categorical flag within a layer - something an entity either has or doesn\'t. Has a weight for selection probability. Can influence other traits via relationships.',
                examples: [
                    { game: 'Monster Species', example: 'Goblin (weight 50), Orc (30), Dragon (5) - rarity via weight' },
                    { game: 'Personality', example: 'Optimist, Grumpy, Social Butterfly - traits to select from' }
                ]
            },
            modifier: {
                tip: 'TEMPORARY effects applied by YOUR GAME CODE. Not automatic - you call <code>engine.applyModifier(entityId, "mod_id")</code> when events happen (enemy attack, item use, etc).',
                examples: [
                    { game: 'Combat', example: 'Poisoned, Stunned, Enraged - apply via engine.applyModifier()' },
                    { game: 'Tavern', example: 'GotFreeDrink, SawARat - trigger from game events' }
                ]
            },
            ticksystem: {
                tip: 'TIMING SYSTEMS that control how modifiers expire. Define manual (turn-based) or automatic (real-time) ticks. Modifiers can bind to tick systems for duration tracking.',
                examples: [
                    { game: 'Combat', example: 'Combat Turns - advances on each turn, poison lasts 3 turns' },
                    { game: 'Simulation', example: 'Day/Night Cycle - ticks every 5 seconds, buffs last until dawn' }
                ]
            },
            compound: {
                tip: 'EMERGENT states that auto-form when requirements are met. Define what items/conditions must be active, and the compound appears automatically.',
                examples: [
                    { game: 'Tavern', example: 'Hangry = Starving + Grumpy (replaces both, worse effects)' },
                    { game: 'Monster', example: 'Berserk = LowHealth + HighRage (special attack mode)' }
                ]
            },
            derived: {
                tip: 'CALCULATED output values. Use formulas referencing attributes and variables. Good for scores, ratings, or composite stats.',
                examples: [
                    { game: 'Tavern', example: 'TipAmount = generosity * 10 + (mood / 2)' },
                    { game: 'Monster', example: 'ThreatLevel = strength * aggression / 10' }
                ]
            },
            action: {
                tip: 'COMBAT BEHAVIORS with costs, cooldowns, and requirements. Engine tracks availability and enforces costs. Your game code interprets what the action does.',
                examples: [
                    { game: 'Combat', example: 'Basic Attack (costs 10 stamina, 1.5s cooldown), Heavy Strike (30 stamina, 3s)' },
                    { game: 'RPG', example: 'Fireball (requires Mage trait, blocked by Silenced modifier)' }
                ]
            }
        };

        // Track collapsed state for Add Node help section
        let addNodeTipCollapsed = localStorage.getItem('addNodeTipCollapsed') === 'true';

        function toggleAddNodeTip() {
            addNodeTipCollapsed = !addNodeTipCollapsed;
            localStorage.setItem('addNodeTipCollapsed', addNodeTipCollapsed);
            const toggle = document.querySelector('.node-help-toggle');
            const content = document.querySelector('.node-help-content');
            if (toggle) toggle.classList.toggle('collapsed', addNodeTipCollapsed);
            if (content) content.classList.toggle('collapsed', addNodeTipCollapsed);
        }

        function renderNewNodeTypeConfig() {
            const container = document.getElementById('newNodeTypeConfig');
            const help = nodeTypeHelp[newNodeType];

            // Build collapsible help section
            let helpHtml = '';
            if (help) {
                const collapsedClass = addNodeTipCollapsed ? 'collapsed' : '';
                helpHtml = `
                    <div class="node-help-container">
                        <div class="node-help-header" onclick="toggleAddNodeTip()">
                            <span class="node-help-toggle ${collapsedClass}">â–¼</span>
                            <span>Tips & Examples</span>
                        </div>
                        <div class="node-help-content ${collapsedClass}">
                            <div class="tutorial-tip" style="margin-top: 0.5rem;">
                                <span class="tutorial-tip-label">ðŸ’¡</span>
                                ${help.tip}
                            </div>
                            <div class="tutorial-examples" style="margin-top: 0.5rem;">
                                <div class="tutorial-examples-title">Examples</div>
                                ${help.examples.map(ex => `
                                    <div class="tutorial-example">
                                        <span class="tutorial-example-game">${ex.game}:</span>
                                        <span class="tutorial-example-desc">${ex.example}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Name/ID fields that appear after help section
            const nameIdHtml = `
                <div class="form-row" style="margin-top: 0.5rem;">
                    <div class="form-group" style="flex: 2;">
                        <label>Name</label>
                        <input type="text" id="newNodeName" placeholder="Display Name" oninput="autoGenerateNodeId()">
                    </div>
                    <div class="form-group" style="flex: 1;">
                        <label>ID <span class="help-icon" title="Unique identifier. Auto-generated from name. Click lock to edit manually.">?</span></label>
                        <div style="display: flex; gap: 0.25rem;">
                            <input type="text" id="newNodeId" placeholder="auto-generated" disabled style="flex: 1; opacity: 0.7;">
                            <button type="button" id="idLockBtn" class="btn btn-icon" onclick="toggleIdLock()" title="Toggle ID lock" style="min-width: 32px; padding: 0.25rem;">ðŸ”’</button>
                        </div>
                    </div>
                </div>
            `;

            // Add type-specific fields based on newNodeType
            switch (newNodeType) {
                case 'attribute':
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this attribute">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Value Mode</label>
                                <select id="newAttrValueMode" onchange="toggleAttrValueMode()">
                                    <option value="range">Random Range</option>
                                    <option value="fixed">Fixed Value</option>
                                </select>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                    Range = random within bounds, Fixed = always exact value
                                </div>
                            </div>
                            <div class="form-group">
                                <label>Precision <span class="help-icon" title="Decimal places. 0 = integers only, 1 = one decimal, etc.">?</span></label>
                                <select id="newNodePrecision">
                                    <option value="0" selected>Integer (0)</option>
                                    <option value="1">1 decimal</option>
                                    <option value="2">2 decimals</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-row" id="attrRangeInputs">
                            <div class="form-group">
                                <label>Min Value</label>
                                <input type="number" id="newNodeMin" value="1">
                            </div>
                            <div class="form-group">
                                <label>Max Value</label>
                                <input type="number" id="newNodeMax" value="10">
                            </div>
                            <div class="form-group">
                                <label>Default <span class="help-icon" title="Value used if not randomized. Leave blank to use midpoint.">?</span></label>
                                <input type="number" id="newNodeDefault" placeholder="auto">
                            </div>
                        </div>
                        <div class="form-row" id="attrFixedInput" style="display: none;">
                            <div class="form-group">
                                <label>Fixed Value</label>
                                <input type="number" id="newNodeFixed" value="5">
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                    Every entity spawns with exactly this value
                                </div>
                            </div>
                        </div>
                    `;
                    break;
                case 'variable':
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this variable">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Bounds Min <span class="help-icon" title="Hard minimum value - variable cannot go below this.">?</span></label>
                                <input type="number" id="newNodeMin" value="0">
                            </div>
                            <div class="form-group">
                                <label>Bounds Max <span class="help-icon" title="Hard maximum value - variable cannot exceed this.">?</span></label>
                                <input type="number" id="newNodeMax" value="100">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Initial Min <span class="help-icon" title="Minimum starting value when spawned.">?</span></label>
                                <input type="number" id="newNodeInitialMin" value="50">
                            </div>
                            <div class="form-group">
                                <label>Initial Max <span class="help-icon" title="Maximum starting value when spawned.">?</span></label>
                                <input type="number" id="newNodeInitialMax" value="50">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Change Mode <span class="help-icon" title="Manual: Changed only by your game code. Timed: Auto-changes per second. Per Tick: Changes when tick system advances.">?</span></label>
                            <select id="newNodeChangeMode" onchange="toggleVariableRateSection()">
                                <option value="manual">Manual (event-driven)</option>
                                <option value="timed">Timed (per second)</option>
                                <option value="perTick">Per Tick</option>
                            </select>
                        </div>
                        <div id="variableRateSection" style="display: none;">
                            <div class="form-group">
                                <label>Base Rate <span class="help-icon" title="How much this variable changes per interval. Negative = depletes, Positive = increases.">?</span></label>
                                <input type="number" id="newNodeRate" value="0" step="0.1">
                            </div>
                            <div class="rate-presets" style="margin: 0.5rem 0; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                <button type="button" class="btn btn-small" onclick="setVariableRate(-5)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Fast Drain (-5)</button>
                                <button type="button" class="btn btn-small" onclick="setVariableRate(-1)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Slow Drain (-1)</button>
                                <button type="button" class="btn btn-small" onclick="setVariableRate(1)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Slow Build (+1)</button>
                                <button type="button" class="btn btn-small" onclick="setVariableRate(5)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Fast Build (+5)</button>
                            </div>
                            <div style="font-size: 0.75rem; color: var(--text-secondary); padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                                <strong>Examples:</strong><br>
                                â€¢ Stamina (drain): Rate -2, starts at max, depletes with activity<br>
                                â€¢ Rage (build): Rate +3, starts at 0, builds toward ability threshold
                            </div>
                            <div id="variableTickSystemSection" style="display: none;">
                                <div class="form-group" style="margin-top: 0.5rem;">
                                    <label>Tick System <span class="help-icon" title="Which tick system drives this variable's per-tick changes">?</span></label>
                                    <select id="newNodeTickSystemId">
                                        <option value="">-- Select tick system --</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    `;
                    break;
                case 'layer':
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this layer">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Order <span class="help-icon" title="Processing order. Lower numbers are processed first. Use this to ensure dependencies are resolved correctly.">?</span></label>
                                <input type="number" id="newNodeOrder" value="0">
                            </div>
                            <div class="form-group">
                                <label>Selection Mode <span class="help-icon" title="Weighted: Random selection based on trait weights. All Matching: Select all eligible traits. Pick N: Select random count of traits. First Match: Select first eligible trait by priority.">?</span></label>
                                <select id="newNodeSelectionMode">
                                    <option value="weighted" selected>Weighted (random by weight)</option>
                                    <option value="allMatching">All Matching (all eligible)</option>
                                    <option value="pickN">Pick N (random count)</option>
                                    <option value="firstMatch">First Match (priority order)</option>
                                </select>
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Roll Timing <span class="help-icon" title="At Spawn: Traits selected when entity created. Manual: Call rollLayer() in code. Never: Only threshold-triggered traits activate.">?</span></label>
                                <select id="newNodeRollTiming">
                                    <option value="spawn" selected>At Spawn</option>
                                    <option value="manual">Manual (API call)</option>
                                    <option value="never">Never (threshold only)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Max Active <span class="help-icon" title="Maximum traits that can be active simultaneously from this layer.">?</span></label>
                                <input type="number" id="newNodeMaxItems" value="1" min="1">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Min Rolls <span class="help-icon" title="Minimum traits to select at spawn. Set to 0 for optional layers.">?</span></label>
                                <input type="number" id="newNodeMinRolls" value="1" min="0">
                            </div>
                            <div class="form-group">
                                <label>Max Rolls <span class="help-icon" title="Maximum traits to select at spawn. Must be â‰¤ Max Active.">?</span></label>
                                <input type="number" id="newNodeMaxRolls" value="1" min="1">
                            </div>
                        </div>
                        <div class="form-row" style="margin-top: 0.5rem;">
                            <div class="form-group" style="flex: 1;">
                                <label>Weight Floor <span class="help-icon" title="Minimum weight after influences applied. Prevents traits from reaching 0%. Default: 0.">?</span></label>
                                <input type="number" id="newNodeWeightFloor" value="0" min="0" step="1">
                            </div>
                            <div class="form-group" style="flex: 1;">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;"
                                       title="Compresses large influence effects with sqrt scaling to keep probabilities balanced.">
                                    <input type="checkbox" id="newNodeDiminishingReturns" style="width: auto;">
                                    Diminishing Returns
                                    <span class="help-icon" title="Sqrt scaling on influences. Large effects compressed more than small ones.">?</span>
                                </label>
                            </div>
                        </div>
                    `;
                    break;
                case 'item':
                case 'trait':
                    const layers = config.nodes.filter(n => n.type === 'layer');
                    const traitVariables = config.nodes.filter(n => n.type === 'variable');
                    const otherTraits = config.nodes.filter(n => (n.type === 'trait' || n.type === 'item'));
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this trait">
                        </div>
                        <div class="form-row">
                            <div class="form-group" style="flex: 2;">
                                <label>Parent Layer</label>
                                <select id="newNodeLayerId" onchange="updateTraitWeightPreview()">
                                    ${layers.length > 0
                                        ? layers.map(l => `<option value="${l.id}">${l.name}</option>`).join('')
                                        : '<option value="">No layers - create one first</option>'
                                    }
                                </select>
                            </div>
                            <div class="form-group" style="flex: 1;">
                                <label>Selection Mode <span class="help-icon" title="Weighted: Selected by probability. Threshold: Auto-activates when condition met.">?</span></label>
                                <select id="newNodeTraitSelectionMode" onchange="toggleTraitThresholdConfig()">
                                    <option value="weighted" selected>Weighted</option>
                                    <option value="threshold">Threshold</option>
                                </select>
                            </div>
                        </div>
                        <div id="traitWeightedConfig">
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Base Weight</label>
                                    <input type="number" id="newNodeWeight" value="20" min="0" oninput="updateTraitWeightPreview()">
                                </div>
                            </div>
                            <div class="weight-presets" style="margin: 0.5rem 0; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                <button type="button" class="btn btn-small" onclick="setTraitWeight(5)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Very Rare (5)</button>
                                <button type="button" class="btn btn-small" onclick="setTraitWeight(10)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Rare (10)</button>
                                <button type="button" class="btn btn-small" onclick="setTraitWeight(30)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Common (30)</button>
                                <button type="button" class="btn btn-small" onclick="setTraitWeight(50)" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Very Common (50)</button>
                            </div>
                            <div id="traitWeightPreview" style="margin-top: 0.5rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px; font-size: 0.8rem;">
                                <!-- Populated by updateTraitWeightPreview() -->
                            </div>
                        </div>
                        <div id="traitThresholdConfig" style="display: none;">
                            <div class="form-row">
                                <div class="form-group" style="flex: 2;">
                                    <label>Target Variable</label>
                                    <select id="newNodeThresholdTarget">
                                        <option value="">-- Select Variable --</option>
                                        ${traitVariables.map(v => `<option value="${v.id}">${v.name}</option>`).join('')}
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Operator</label>
                                    <select id="newNodeThresholdOp">
                                        <option value="<=">â‰¤ (less/equal)</option>
                                        <option value=">=">â‰¥ (greater/equal)</option>
                                        <option value="<">&lt; (less than)</option>
                                        <option value=">">&gt; (greater than)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Value</label>
                                    <input type="number" id="newNodeThresholdValue" value="20">
                                </div>
                            </div>
                            <div class="form-group">
                                <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; font-size: 0.85rem;">
                                    <input type="checkbox" id="newNodeAutoRemove" style="width: auto;">
                                    Auto-remove when condition clears
                                </label>
                            </div>
                        </div>
                        ${otherTraits.length > 0 ? `
                        <div class="form-group" style="margin-top: 0.75rem;">
                            <label>Incompatible With <span class="help-icon" title="Traits that cannot be active at the same time. Bidirectional.">?</span> <span class="optional-label">(optional)</span></label>
                            <div id="newNodeIncompatible" style="max-height: 120px; overflow-y: auto; background: rgba(0,0,0,0.2); border-radius: 4px; padding: 0.3rem;">
                                ${otherTraits.map(t => `
                                    <label style="display: flex; align-items: center; gap: 0.4rem; padding: 0.2rem 0.4rem; cursor: pointer; opacity: 0.5; border-radius: 3px; transition: opacity 0.15s;"
                                           onchange="this.style.opacity = this.querySelector('input').checked ? '1' : '0.5'">
                                        <input type="checkbox" value="${t.id}" style="width: auto;">
                                        <span class="dot item" style="width: 6px; height: 6px;"></span>
                                        <span style="font-size: 0.8rem;">${t.name}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    `;
                    // Initial preview update
                    setTimeout(() => updateTraitWeightPreview(), 10);
                    break;
                case 'modifier':
                    const modifierVariables = config.nodes.filter(n => n.type === 'variable');
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this modifier">
                        </div>
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Trigger Type <span class="help-icon" title="Manual: Applied/removed via game code. Threshold: Auto-applies when variable conditions are met.">?</span></label>
                            <div id="triggerTypeSelector" style="display: flex; gap: 0.5rem; margin-top: 0.25rem;">
                                <button type="button" class="btn btn-sm" id="triggerBtn_manual" onclick="selectModifierTriggerType('manual')" style="flex: 1; padding: 0.5rem; border: 2px solid var(--border-color); background: var(--bg-card); opacity: 0.6;">
                                    <div style="font-weight: 600;">Manual</div>
                                    <div style="font-size: 0.65rem; color: var(--text-muted);">Applied via game code</div>
                                </button>
                                <button type="button" class="btn btn-sm" id="triggerBtn_threshold" onclick="selectModifierTriggerType('threshold')" style="flex: 1; padding: 0.5rem; border: 2px solid var(--border-color); background: var(--bg-card); opacity: 0.6;">
                                    <div style="font-weight: 600;">Threshold</div>
                                    <div style="font-size: 0.65rem; color: var(--text-muted);">Auto when condition met</div>
                                </button>
                            </div>
                            <input type="hidden" id="newNodeTriggerType" value="">
                        </div>
                        <div id="modifierThresholdConfig" style="display: none;">
                            <div class="form-group">
                                <label>Apply Conditions <span class="help-icon" title="Conditions that trigger this modifier to be applied. Use groups (parentheticals) to control order of operations.">?</span></label>
                                <div id="modifierConditionsList" class="condition-list" style="max-width: 100%; overflow-x: auto;">
                                    <!-- Conditions rendered by JS -->
                                </div>
                                <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;">
                                    <button type="button" class="btn btn-secondary btn-sm" onclick="addModifierCondition('apply')">+ Condition</button>
                                    <button type="button" class="btn btn-secondary btn-sm" onclick="addModifierConditionGroup('apply')" title="Add a grouped set of conditions (parenthetical)">+ Group</button>
                                </div>
                            </div>
                            <!-- Exclusive With -->
                            <div class="form-group" style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 4px; border-left: 3px solid var(--copper);">
                                <label style="display: flex; align-items: center; gap: 0.4rem; margin-bottom: 0.5rem;">
                                    <span>Exclusive With</span>
                                    <span class="help-icon" title="Modifiers in an exclusive group are mutually exclusive. When multiple conditions are met, the most specific (narrowest threshold) wins. The others are automatically removed.">?</span>
                                    <span style="font-size: 0.65rem; color: var(--text-muted);">(optional)</span>
                                </label>
                                <div id="modifierExclusiveList" style="display: flex; flex-wrap: wrap; gap: 0.3rem; margin-bottom: 0.5rem;">
                                    <!-- Exclusive chips rendered by JS -->
                                </div>
                                <select id="modifierExclusiveAdd" onchange="addModifierExclusive(this.value); this.value='';" style="font-size: 0.8rem;">
                                    <option value="">+ Add exclusive modifier...</option>
                                </select>
                                <div id="exclusivePreview" style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem; display: none;"></div>
                            </div>
                            <!-- Removal Mode Toggle -->
                            <div class="form-group" style="margin-top: 1rem; padding: 0.75rem; background: rgba(0,0,0,0.2); border-radius: 4px;">
                                <label style="margin-bottom: 0.5rem; display: block;">Removal Behavior</label>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <label class="toggle-option" style="display: flex; align-items: center; gap: 0.4rem; padding: 0.4rem 0.6rem; background: rgba(0,0,0,0.2); border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;">
                                        <input type="radio" name="modRemovalMode" value="reactive" id="modRemovalReactive" onchange="toggleModifierStaticMode()" checked>
                                        <span style="font-size: 0.8rem;"><strong>Reactive</strong><br><span style="color: var(--text-muted); font-size: 0.7rem;">Auto-removes when conditions no longer met</span></span>
                                    </label>
                                    <label class="toggle-option" style="display: flex; align-items: center; gap: 0.4rem; padding: 0.4rem 0.6rem; background: rgba(0,0,0,0.2); border-radius: 4px; cursor: pointer; flex: 1; min-width: 120px;">
                                        <input type="radio" name="modRemovalMode" value="custom" id="modRemovalCustom" onchange="toggleModifierStaticMode()">
                                        <span style="font-size: 0.8rem;"><strong>Custom</strong><br><span style="color: var(--text-muted); font-size: 0.7rem;">Define separate removal conditions</span></span>
                                    </label>
                                </div>
                            </div>
                            <div id="modifierRemoveConditionsSection" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(255,255,255,0.1);">
                                <div class="form-group">
                                    <label>Remove Conditions <span class="help-icon" title="Custom conditions for removal (for hysteresis, e.g., apply at hunger &lt; 20, remove at hunger &gt; 50)">?</span></label>
                                    <div id="modifierRemoveConditionsList" class="condition-list" style="max-width: 100%; overflow-x: auto;">
                                        <!-- Remove conditions rendered by JS -->
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;">
                                        <button type="button" class="btn btn-secondary btn-sm" onclick="addModifierCondition('remove')">+ Condition</button>
                                        <button type="button" class="btn btn-secondary btn-sm" onclick="addModifierConditionGroup('remove')" title="Add a grouped set of conditions (parenthetical)">+ Group</button>
                                    </div>
                                </div>
                            </div>
                            <!-- English Preview -->
                            <div id="modifierEnglishPreview" class="english-preview" style="margin-top: 1rem; padding: 0.75rem; background: rgba(100,180,100,0.1); border: 1px solid rgba(100,180,100,0.3); border-radius: 4px; font-size: 0.8rem; color: var(--text-secondary);">
                                <!-- Rendered by updateModifierEnglishPreview() -->
                            </div>
                        </div>
                        <div id="modifierManualConfig" style="display: none;">
                            <div class="form-row" id="modifierDurationSection">
                                <div class="form-group">
                                    <label>Duration Type</label>
                                    <select id="newNodeDurationType" onchange="toggleModifierTickSystemField()">
                                        <option value="" selected>-- Select --</option>
                                        <option value="ticks">Tick-based</option>
                                        <option value="permanent">Permanent (until removed)</option>
                                    </select>
                                </div>
                                <div class="form-group" id="modifierDurationField" style="display: none;">
                                    <label>Duration (ticks)</label>
                                    <input type="number" id="newNodeDuration" value="10" min="0">
                                </div>
                            </div>
                            <div class="form-row" id="modifierTickSystemRow" style="display: none;">
                                <div class="form-group" style="flex: 1;">
                                    <label>Bind to Tick System <span class="help-icon" title="Which tick system controls this modifier's duration countdown">?</span></label>
                                    <select id="newNodeTickSystemId">
                                        <option value="">-- Select tick system --</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div id="modifierStackingSection" style="display: none;">
                            <div class="form-row">
                                <div class="form-group">
                                    <label>Stacking</label>
                                    <select id="newNodeStacking">
                                        <option value="" selected>-- Select --</option>
                                        <option value="refresh">Refresh (reset duration)</option>
                                        <option value="stack">Stack (add stacks)</option>
                                        <option value="ignore">Ignore (no effect if active)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Max Stacks</label>
                                    <input type="number" id="newNodeMaxStacks" value="1" min="1">
                                </div>
                            </div>
                        </div>
                    `;
                    // Initialize tick system dropdown
                    setTimeout(toggleModifierTickSystemField, 10);
                    break;
                case 'ticksystem':
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-row" style="margin-top: 0.5rem;">
                            <div class="form-group">
                                <label>Tick Type</label>
                                <select id="newNodeTickType" onchange="toggleTickIntervalField()">
                                    <option value="manual" selected>Manual (API/Turn-based)</option>
                                    <option value="timed">Timed (Auto-advance)</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Tick Label</label>
                                <input type="text" id="newNodeTickLabel" value="turn" placeholder="turn, second, cycle...">
                            </div>
                        </div>
                        <div class="form-row" id="tickIntervalRow" style="display: none;">
                            <div class="form-group">
                                <label>Interval (ms)</label>
                                <input type="number" id="newNodeTickInterval" value="1000" min="100">
                            </div>
                        </div>
                    `;
                    break;
                case 'compound':
                    // Initialize requirements builder
                    initCompoundRequirements();
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this compound state">
                        </div>
                        <div class="form-group">
                            <label>Requirements <span class="help-icon" title="Conditions that must be met for this compound to activate. Traits/modifiers check if active, attributes/variables can check threshold values.">?</span></label>
                            <div id="compoundRequirementsList" class="condition-list" style="margin-bottom: 0.5rem;">
                                <!-- Rendered by JS -->
                            </div>
                            <button type="button" class="btn btn-secondary btn-sm" onclick="addCompoundRequirementRow()">+ Add Requirement</button>
                        </div>
                    `;
                    // Render initial empty state
                    renderCompoundRequirements();
                    break;
                case 'action':
                    const actionVars = config.nodes.filter(n => n.type === 'variable');
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this action">
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Base Weight <span class="help-icon" title="Probability weight for random action selection. Higher = more likely to be chosen.">?</span></label>
                                <input type="number" id="newNodeBaseWeight" value="50" min="0">
                            </div>
                            <div class="form-group">
                                <label>Cooldown (sec) <span class="help-icon" title="Time before action can be used again. 0 = no cooldown.">?</span></label>
                                <input type="number" id="newNodeCooldown" value="0" min="0" step="0.1">
                            </div>
                        </div>
                        ${actionVars.length > 0 ? `
                        <div class="form-group">
                            <label>Initial Costs <span class="help-icon" title="Variable costs deducted when action executes. Configure more after creation.">?</span> <span class="optional-label">(optional)</span></label>
                            <div id="newActionCostInputs" style="display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; gap: 0.5rem; align-items: center;">
                                    <select id="newActionCostVar" style="flex: 1;">
                                        <option value="">Select variable...</option>
                                        ${actionVars.map(v => `<option value="${v.id}">${v.name}</option>`).join('')}
                                    </select>
                                    <input type="number" id="newActionCostAmount" value="10" min="0" style="width: 60px;" placeholder="Cost">
                                </div>
                            </div>
                        </div>
                        ` : ''}
                    `;
                    break;
                case 'derived':
                    const derivedSources = config.nodes.filter(n =>
                        ['attribute', 'variable', 'derived'].includes(n.type)
                    );
                    initFormulaBlocksEditor('new', '', null, null);
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this derived value">
                        </div>
                        <div class="form-group">
                            <label>Formula <span class="help-icon" title="Build formulas from blocks. Each block has 1-2 values. Blocks evaluate internally, then left-to-right across the formula. Drag to reorder, click to edit.">?</span></label>
                            ${renderFBSection('new', derivedSources, '', null, null)}
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label>Min <span class="help-icon" title="Clamp result to this minimum. Leave blank for no limit.">?</span></label>
                                <input type="number" id="newNodeDerivedMin" placeholder="none">
                            </div>
                            <div class="form-group">
                                <label>Max <span class="help-icon" title="Clamp result to this maximum. Leave blank for no limit.">?</span></label>
                                <input type="number" id="newNodeDerivedMax" placeholder="none">
                            </div>
                        </div>
                    `;
                    break;
                case 'context':
                    container.innerHTML = `
                        ${helpHtml}
                        ${nameIdHtml}
                        <div class="form-group" style="margin-top: 0.5rem;">
                            <label>Description <span class="optional-label">(optional)</span></label>
                            <input type="text" id="newNodeDescription" placeholder="Brief description of this context">
                        </div>
                        <div class="form-group">
                            <label>Context Type <span class="help-icon" title="Enum: Predefined list of values. String: Freeform text. Number: Numeric value.">?</span></label>
                            <select id="newNodeContextType">
                                <option value="enum" selected>Enum (list of values)</option>
                                <option value="string">String (freeform text)</option>
                                <option value="number">Number</option>
                            </select>
                        </div>
                        <div class="form-group" id="contextEnumValues">
                            <label>Possible Values <span class="help-icon" title="Comma-separated list of allowed values.">?</span></label>
                            <input type="text" id="newNodeContextValues" placeholder="e.g., tavern, market, castle, wilderness">
                            <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 0.25rem;">
                                Comma-separated. Used by relationships to trigger different behaviors.
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Default Value</label>
                            <input type="text" id="newNodeContextDefault" placeholder="Initial context value">
                        </div>
                        <div class="tutorial-tip" style="margin-top: 0.75rem;">
                            <span class="tutorial-tip-label">ðŸ’¡</span>
                            Context nodes represent external state (location, time of day, weather) that affects entity behavior through relationships.
                        </div>
                    `;
                    break;
                default:
                    container.innerHTML = helpHtml;
            }
        }

        function toggleAttrValueMode() {
            const mode = document.getElementById('newAttrValueMode')?.value || 'range';
            const rangeInputs = document.getElementById('attrRangeInputs');
            const fixedInput = document.getElementById('attrFixedInput');

            if (mode === 'fixed') {
                if (rangeInputs) rangeInputs.style.display = 'none';
                if (fixedInput) fixedInput.style.display = 'flex';
            } else {
                if (rangeInputs) rangeInputs.style.display = 'flex';
                if (fixedInput) fixedInput.style.display = 'none';
            }
        }

        // Select modifier trigger type (two-button selector in Add Node modal)
        function selectModifierTriggerType(type) {
            const hidden = document.getElementById('newNodeTriggerType');
            if (hidden) hidden.value = type;

            // Update button visuals
            const manualBtn = document.getElementById('triggerBtn_manual');
            const thresholdBtn = document.getElementById('triggerBtn_threshold');
            if (manualBtn) {
                manualBtn.style.borderColor = type === 'manual' ? 'var(--accent-primary)' : 'var(--border-color)';
                manualBtn.style.opacity = type === 'manual' ? '1' : '0.6';
            }
            if (thresholdBtn) {
                thresholdBtn.style.borderColor = type === 'threshold' ? 'var(--accent-primary)' : 'var(--border-color)';
                thresholdBtn.style.opacity = type === 'threshold' ? '1' : '0.6';
            }

            toggleModifierTriggerConfig();
        }

        function toggleModifierTriggerConfig() {
            const hidden = document.getElementById('newNodeTriggerType');
            const triggerType = hidden?.value || '';
            const isThreshold = triggerType === 'threshold';
            const thresholdConfig = document.getElementById('modifierThresholdConfig');
            const manualConfig = document.getElementById('modifierManualConfig');

            if (thresholdConfig) {
                thresholdConfig.style.display = isThreshold ? 'block' : 'none';

                // Initialize with one condition if switching to threshold
                if (isThreshold) {
                    initModifierConditions();
                    // Reset to reactive mode by default
                    const reactiveRadio = document.getElementById('modRemovalReactive');
                    if (reactiveRadio) reactiveRadio.checked = true;
                    toggleModifierStaticMode();
                    updateModifierEnglishPreview();
                    renderModifierExclusiveUI();
                }
            }

            // Show manual config section when manual is selected
            if (manualConfig) {
                manualConfig.style.display = triggerType === 'manual' ? 'block' : 'none';
            }

            // Show stacking section when either type is selected
            const stackingSection = document.getElementById('modifierStackingSection');
            if (stackingSection) {
                stackingSection.style.display = triggerType ? 'block' : 'none';
            }
        }

        // Modifier multi-condition state (supports both simple conditions and groups)
        // Simple condition: { target, operator, value, connector? }
        // Group: { type: 'group', connector?, conditions: [{ target, operator, value, connector? }, ...] }
        let modifierApplyConditions = [];
        let modifierRemoveConditions = [];
        let modifierStaticMode = false;
        let modifierExclusiveWith = [];

        function initModifierConditions() {
            modifierApplyConditions = [];
            modifierRemoveConditions = [];
            modifierStaticMode = false;
            modifierExclusiveWith = [];
            // Start with one empty apply condition
            addModifierCondition('apply');
        }

        // ========================================
        // EXCLUSIVE MODIFIER FUNCTIONS
        // ========================================

        // Render the exclusive chips and dropdown in the Add Node modal
        function renderModifierExclusiveUI() {
            const chipContainer = document.getElementById('modifierExclusiveList');
            const dropdown = document.getElementById('modifierExclusiveAdd');
            if (!chipContainer || !dropdown) return;

            // Render chips for currently selected exclusives
            chipContainer.innerHTML = modifierExclusiveWith.map(exId => {
                const exNode = config.nodes.find(n => n.id === exId);
                return `<span class="exclusive-chip" style="display: inline-flex; align-items: center; gap: 0.3rem; padding: 0.15rem 0.5rem; background: rgba(167,141,182,0.2); border: 1px solid var(--copper-dark); border-radius: 12px; font-size: 0.75rem;">
                    <span class="dot modifier" style="width: 6px; height: 6px;"></span>
                    ${exNode?.name || exId}
                    <button class="btn-icon" onclick="removeModifierExclusive('${exId}')" style="background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 0; font-size: 0.7rem;" title="Remove">&times;</button>
                </span>`;
            }).join('');

            // Populate dropdown with available modifiers (exclude already selected)
            const otherModifiers = config.nodes.filter(n =>
                n.type === 'modifier' && !modifierExclusiveWith.includes(n.id)
            );
            dropdown.innerHTML = '<option value="">+ Add exclusive modifier...</option>' +
                otherModifiers.map(n => `<option value="${n.id}">${n.name}</option>`).join('');

            // Update exclusive preview
            const previewEl = document.getElementById('exclusivePreview');
            if (previewEl) {
                if (modifierExclusiveWith.length > 0) {
                    const currentName = document.getElementById('newNodeName')?.value || 'this modifier';
                    const names = modifierExclusiveWith.map(id => {
                        const n = config.nodes.find(nd => nd.id === id);
                        return n?.name || id;
                    });
                    const allNames = [currentName, ...names];
                    previewEl.innerHTML = `Only one of [<strong>${allNames.join(', ')}</strong>] can be active. Most specific condition wins.`;
                    previewEl.style.display = 'block';
                } else {
                    previewEl.style.display = 'none';
                }
            }
        }

        // Add an exclusive modifier in Add Node modal
        function addModifierExclusive(modId) {
            if (!modId || modifierExclusiveWith.includes(modId)) return;
            modifierExclusiveWith.push(modId);
            renderModifierExclusiveUI();
        }

        // Remove an exclusive modifier in Add Node modal
        function removeModifierExclusive(modId) {
            modifierExclusiveWith = modifierExclusiveWith.filter(id => id !== modId);
            renderModifierExclusiveUI();
        }

        // Add exclusive in detail panel (bidirectional)
        function addDetailExclusive(nodeId, partnerId) {
            if (!partnerId) return;
            const node = config.nodes.find(n => n.id === nodeId);
            const partner = config.nodes.find(n => n.id === partnerId);
            if (!node || !partner) return;

            // Add to this node
            if (!node.config.exclusiveWith) node.config.exclusiveWith = [];
            if (!node.config.exclusiveWith.includes(partnerId)) {
                node.config.exclusiveWith.push(partnerId);
            }

            // Add to partner (bidirectional)
            if (!partner.config.exclusiveWith) partner.config.exclusiveWith = [];
            if (!partner.config.exclusiveWith.includes(nodeId)) {
                partner.config.exclusiveWith.push(nodeId);
            }

            saveToStorage();
            render();
        }

        // Remove exclusive in detail panel (bidirectional)
        function removeDetailExclusive(nodeId, partnerId) {
            const node = config.nodes.find(n => n.id === nodeId);
            const partner = config.nodes.find(n => n.id === partnerId);

            if (node?.config?.exclusiveWith) {
                node.config.exclusiveWith = node.config.exclusiveWith.filter(id => id !== partnerId);
            }
            if (partner?.config?.exclusiveWith) {
                partner.config.exclusiveWith = partner.config.exclusiveWith.filter(id => id !== nodeId);
            }

            saveToStorage();
            render();
        }

        // Add a simple condition at top level or inside a group
        function addModifierCondition(type = 'apply', groupIndex = null) {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;
            const newCondition = {
                target: '',
                operator: '<=',
                value: 0
            };

            if (groupIndex !== null && arr[groupIndex]?.type === 'group') {
                // Add inside a group
                const group = arr[groupIndex];
                if (group.conditions.length > 0) {
                    newCondition.connector = 'OR'; // Default to OR inside groups
                }
                group.conditions.push(newCondition);
            } else {
                // Add at top level
                if (arr.length > 0) {
                    newCondition.connector = 'AND';
                }
                arr.push(newCondition);
            }
            renderModifierConditions(type);
        }

        // Add a new group (parenthetical) at top level
        function addModifierConditionGroup(type = 'apply') {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;
            const newGroup = {
                type: 'group',
                conditions: [{ target: '', operator: '<=', value: 30 }]
            };
            if (arr.length > 0) {
                newGroup.connector = 'AND';
            }
            arr.push(newGroup);
            renderModifierConditions(type);
        }

        // Remove a condition or group
        function removeModifierCondition(type, index, groupIndex = null) {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;

            if (groupIndex !== null && arr[groupIndex]?.type === 'group') {
                // Remove from inside a group
                const group = arr[groupIndex];
                group.conditions.splice(index, 1);
                // Fix connectors - first in group has no connector
                if (group.conditions.length > 0 && group.conditions[0].connector) {
                    delete group.conditions[0].connector;
                }
                // Check if group should be dissolved (< 2 conditions)
                checkAndDissolveGroup(type, groupIndex);
            } else {
                // Remove from top level (only if more than one item)
                if (arr.length > 1) {
                    arr.splice(index, 1);
                    // Fix connectors - first item has no connector
                    if (arr.length > 0 && arr[0].connector) {
                        delete arr[0].connector;
                    }
                }
            }
            renderModifierConditions(type);
        }

        // Ungroup - remove the group but keep its conditions at top level
        function removeModifierConditionGroup(type, groupIndex) {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;
            const group = arr[groupIndex];

            if (!group || group.type !== 'group') return;

            // Get the group's connector for the first condition
            const groupConnector = group.connector;

            // Extract conditions from the group
            const conditions = group.conditions.map((cond, i) => {
                const newCond = { ...cond };
                if (i === 0) {
                    // First condition gets the group's connector
                    if (groupConnector) {
                        newCond.connector = groupConnector;
                    } else {
                        delete newCond.connector;
                    }
                } else {
                    // Subsequent conditions keep their connectors but convert to AND for top level
                    newCond.connector = cond.connector || 'AND';
                }
                return newCond;
            });

            // Replace the group with its conditions
            arr.splice(groupIndex, 1, ...conditions);

            // Fix first item connector
            if (arr.length > 0 && arr[0].connector) {
                delete arr[0].connector;
            }

            renderModifierConditions(type);
        }

        // Move a condition out of a group to top level
        function moveConditionOutOfGroup(type, condIndex, groupIndex) {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;
            const group = arr[groupIndex];

            if (!group || group.type !== 'group') return;

            // Get the condition to move
            const cond = { ...group.conditions[condIndex] };

            // Remove from group
            group.conditions.splice(condIndex, 1);

            // Fix group's first connector
            if (group.conditions.length > 0 && group.conditions[0].connector) {
                delete group.conditions[0].connector;
            }

            // Add to top level after the group with AND connector
            cond.connector = 'AND';
            arr.splice(groupIndex + 1, 0, cond);

            // Check if group should be dissolved
            checkAndDissolveGroup(type, groupIndex);

            renderModifierConditions(type);
        }

        function updateModifierCondition(type, index, field, value, groupIndex = null) {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;

            let cond;
            if (groupIndex !== null && arr[groupIndex]?.type === 'group') {
                cond = arr[groupIndex].conditions[index];
            } else {
                cond = arr[index];
            }

            if (cond && cond.type !== 'group') {
                if (field === 'value') {
                    cond[field] = parseFloat(value) || 0;
                } else {
                    cond[field] = value;
                }
                // Re-render if operator changed to update value field visibility
                if (field === 'operator' || field === 'target') {
                    renderModifierConditions(type);
                }
            }
        }

        function updateConditionConnector(type, index, connector, groupIndex = null) {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;

            if (groupIndex !== null && arr[groupIndex]?.type === 'group') {
                // Update connector inside a group
                const group = arr[groupIndex];
                if (group.conditions[index] && index > 0) {
                    group.conditions[index].connector = connector;
                }
            } else {
                // Update connector at top level
                if (arr[index] && index > 0) {
                    arr[index].connector = connector;
                }
            }
            renderModifierConditions(type);
        }

        function toggleModifierStaticMode() {
            // Check which radio is selected (reactive = static mode on, custom = static mode off)
            const reactiveRadio = document.getElementById('modRemovalReactive');
            modifierStaticMode = reactiveRadio?.checked ?? true;

            const removeSection = document.getElementById('modifierRemoveConditionsSection');

            // When reactive: hide remove conditions (auto-inverted)
            // When custom: show remove conditions
            if (removeSection) {
                removeSection.style.display = modifierStaticMode ? 'none' : 'block';
            }

            // Update English preview
            updateModifierEnglishPreview();
        }

        // Helper functions for detail panel modifier editing
        function updateModifierTriggerType(nodeId, triggerType) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (triggerType === 'threshold') {
                node.config.trigger = node.config.trigger || { type: 'threshold', logic: 'all', conditions: [] };
                node.config.trigger.type = 'threshold';
            } else {
                delete node.config.trigger;
            }
            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function updateModifierStaticMode(nodeId, isStatic) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node || !node.config.trigger) return;

            node.config.trigger.static = isStatic;
            if (isStatic && !node.config.trigger.removeConditions) {
                node.config.trigger.removeConditions = [];
                node.config.trigger.removeLogic = 'all';
            }
            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function renderDetailConditions(nodeId, conditions, type) {
            if (!conditions || conditions.length === 0) {
                return '<div class="empty-hint">No conditions defined</div>';
            }

            const renderSingleCondition = (cond) => {
                const targetNode = config.nodes.find(n => n.id === cond.target);
                const targetName = targetNode?.name || cond.target;
                const isActive = cond.operator === 'active' || cond.operator === 'inactive';

                if (isActive) {
                    return `<span style="color: var(--copper);">${targetName}</span> <span style="color: var(--text-secondary);">${cond.operator}</span>`;
                }

                return `<span style="color: var(--copper);">${targetName}</span> <span style="color: var(--text-secondary);">${cond.operator}</span> <span>${cond.value}</span>`;
            };

            return conditions.map((cond, idx) => {
                // Connector display for conditions after the first
                const connectorHtml = idx > 0 && cond.connector
                    ? `<div style="text-align: center; font-size: 0.75rem; color: var(--copper); font-weight: bold; margin: 0.15rem 0;">${cond.connector}</div>`
                    : '';

                // Group with per-expression connectors
                if (cond.type === 'group' && cond.conditions) {
                    const groupInnerHtml = cond.conditions.map((gc, gidx) => {
                        const gConnectorHtml = gidx > 0 && gc.connector
                            ? `<div style="font-size: 0.7rem; color: var(--copper); font-weight: bold; margin: 0.1rem 0;">${gc.connector}</div>`
                            : '';
                        return `${gConnectorHtml}<div style="padding: 0.15rem 0; font-size: 0.8rem;">${renderSingleCondition(gc)}</div>`;
                    }).join('');

                    return `${connectorHtml}<div class="condition-group-display" style="margin-left: 0.75rem; margin-bottom: 0.25rem; padding: 0.35rem 0.5rem; border-left: 2px solid var(--copper); background: rgba(167,141,182,0.08); border-radius: 0 4px 4px 0;">
                        <div style="font-size: 0.65rem; color: var(--text-secondary); margin-bottom: 0.2rem;">(Group)</div>
                        ${groupInnerHtml}
                    </div>`;
                }

                // Simple condition with connector
                return `${connectorHtml}<div class="condition-display" style="padding: 0.25rem 0.5rem; margin-bottom: 0.15rem; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 0.85rem;">
                    ${renderSingleCondition(cond)}
                </div>`;
            }).join('');
        }

        // Render editable conditions for detail panel
        function renderEditableDetailConditions(nodeId, conditions) {
            const node = config.nodes.find(n => n.id === nodeId);

            // Check for old single-condition format and convert for display
            let displayConditions = conditions || [];
            if (displayConditions.length === 0 && node?.config?.trigger?.target) {
                // Old format: condition stored directly on trigger object
                displayConditions = [{
                    target: node.config.trigger.target,
                    operator: node.config.trigger.operator || '<=',
                    value: node.config.trigger.value ?? 50
                }];
            }

            if (displayConditions.length === 0) {
                return '<div class="detail-empty-conditions">No conditions. Click + Add to create one.</div>';
            }

            // Use displayConditions from here on
            conditions = displayConditions;

            // Get valid targets grouped by type
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const modifiers = config.nodes.filter(n => n.type === 'modifier' && n.id !== nodeId);
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
            const compounds = config.nodes.filter(n => n.type === 'compound');

            const buildTargetOptions = (selected) => {
                let opts = '<option value="">--</option>';
                if (variables.length > 0) {
                    opts += '<optgroup label="Variables">' +
                        variables.map(n => '<option value="' + n.id + '"' + (selected === n.id ? ' selected' : '') + '>' + n.name + '</option>').join('') +
                        '</optgroup>';
                }
                if (attributes.length > 0) {
                    opts += '<optgroup label="Attributes">' +
                        attributes.map(n => '<option value="' + n.id + '"' + (selected === n.id ? ' selected' : '') + '>' + n.name + '</option>').join('') +
                        '</optgroup>';
                }
                if (modifiers.length > 0) {
                    opts += '<optgroup label="Modifiers">' +
                        modifiers.map(n => '<option value="' + n.id + '"' + (selected === n.id ? ' selected' : '') + '>' + n.name + '</option>').join('') +
                        '</optgroup>';
                }
                if (traits.length > 0) {
                    opts += '<optgroup label="Traits">' +
                        traits.map(n => '<option value="' + n.id + '"' + (selected === n.id ? ' selected' : '') + '>' + n.name + '</option>').join('') +
                        '</optgroup>';
                }
                return opts;
            };

            const getOperatorOptions = (targetId, selectedOp) => {
                const targetNode = config.nodes.find(n => n.id === targetId);
                const isNumeric = targetNode?.type === 'attribute' || targetNode?.type === 'variable';

                if (isNumeric) {
                    return ['<', '<=', '>', '>=', '='].map(op =>
                        '<option value="' + op + '"' + (selectedOp === op ? ' selected' : '') + '>' + op + '</option>'
                    ).join('');
                } else {
                    return ['active', 'inactive'].map(op =>
                        '<option value="' + op + '"' + (selectedOp === op ? ' selected' : '') + '>' + op + '</option>'
                    ).join('');
                }
            };

            return conditions.map((cond, idx) => {
                if (cond.type === 'group') return ''; // Skip groups for now

                const targetNode = config.nodes.find(n => n.id === cond.target);
                const isNumeric = targetNode?.type === 'attribute' || targetNode?.type === 'variable';
                const connectorHtml = idx > 0 ?
                    '<span class="detail-condition-connector" onclick="toggleDetailConditionConnector(\'' + nodeId + '\', ' + idx + ')" title="Click to toggle AND/OR">' + (cond.connector || 'AND') + '</span>' : '';

                return connectorHtml +
                    '<div class="detail-condition-row">' +
                        '<select class="cond-target" onchange="updateDetailCondition(\'' + nodeId + '\', ' + idx + ', \'target\', this.value)">' +
                            buildTargetOptions(cond.target) +
                        '</select>' +
                        '<select class="cond-op" onchange="updateDetailCondition(\'' + nodeId + '\', ' + idx + ', \'operator\', this.value)">' +
                            getOperatorOptions(cond.target, cond.operator) +
                        '</select>' +
                        (isNumeric ? '<input type="number" class="cond-value" value="' + (cond.value ?? 0) + '" onchange="updateDetailCondition(\'' + nodeId + '\', ' + idx + ', \'value\', parseFloat(this.value))">' : '') +
                        '<button class="cond-remove" onclick="removeDetailCondition(\'' + nodeId + '\', ' + idx + ')" title="Remove">âœ•</button>' +
                    '</div>';
            }).join('');
        }

        // Detail panel modifier functions
        function updateModifierTriggerTypeDetail(nodeId, triggerType) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (triggerType === 'threshold') {
                // Restore previous trigger config if it exists, otherwise create new
                node.config.trigger = node.config.trigger || { type: 'threshold', conditions: [] };
                node.config.trigger.type = 'threshold';
                node.config.triggerType = 'threshold';
            } else {
                // Preserve trigger config but mark as manual (so conditions survive toggle)
                if (node.config.trigger) {
                    node.config.trigger.type = 'manual';
                }
                node.config.triggerType = 'manual';
            }
            engine.loadConfig(config);
            saveToStorage();
            renderDetailPanel();
        }

        function updateModifierStaticModeDetail(nodeId, isStatic) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.trigger) {
                node.config.trigger = { type: 'threshold', conditions: [] };
            }
            node.config.trigger.static = isStatic;
            engine.loadConfig(config);
            saveToStorage();
            renderDetailPanel();
        }

        function addDetailCondition(nodeId) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;

            if (!node.config.trigger) {
                node.config.trigger = { type: 'threshold', conditions: [] };
            }

            // Migrate old single-condition format to conditions array
            if (!node.config.trigger.conditions) {
                node.config.trigger.conditions = [];
            }

            // Check for old format: condition stored directly on trigger object
            if (node.config.trigger.target && node.config.trigger.conditions.length === 0) {
                // Migrate the old condition to the new array format
                const oldCondition = {
                    target: node.config.trigger.target,
                    operator: node.config.trigger.operator || '<=',
                    value: node.config.trigger.value ?? 50
                };
                node.config.trigger.conditions.push(oldCondition);

                // Clean up old format properties
                delete node.config.trigger.target;
                delete node.config.trigger.operator;
                delete node.config.trigger.value;

                console.log('Migrated old condition format:', oldCondition);
            }

            // Find first variable to use as default target
            const firstVar = config.nodes.find(n => n.type === 'variable');
            const newCondition = {
                target: firstVar?.id || '',
                operator: '<=',
                value: 50
            };

            // Add connector if not first condition
            if (node.config.trigger.conditions.length > 0) {
                newCondition.connector = 'AND';
            }

            node.config.trigger.conditions.push(newCondition);
            engine.loadConfig(config);
            saveToStorage();
            renderDetailPanel();
        }

        function removeDetailCondition(nodeId, index) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node?.config?.trigger?.conditions) return;

            node.config.trigger.conditions.splice(index, 1);

            // Remove connector from new first condition
            if (node.config.trigger.conditions.length > 0 && node.config.trigger.conditions[0].connector) {
                delete node.config.trigger.conditions[0].connector;
            }

            engine.loadConfig(config);
            saveToStorage();
            renderDetailPanel();
        }

        function updateDetailCondition(nodeId, index, field, value) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node?.config?.trigger?.conditions?.[index]) return;

            node.config.trigger.conditions[index][field] = value;

            // If target changed to non-numeric, update operator
            if (field === 'target') {
                const targetNode = config.nodes.find(n => n.id === value);
                const isNumeric = targetNode?.type === 'attribute' || targetNode?.type === 'variable';
                if (!isNumeric) {
                    node.config.trigger.conditions[index].operator = 'active';
                    delete node.config.trigger.conditions[index].value;
                } else if (!['<', '<=', '>', '>=', '='].includes(node.config.trigger.conditions[index].operator)) {
                    node.config.trigger.conditions[index].operator = '<=';
                    node.config.trigger.conditions[index].value = 50;
                }
            }

            engine.loadConfig(config);
            saveToStorage();
            renderDetailPanel();
        }

        function toggleDetailConditionConnector(nodeId, index) {
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node?.config?.trigger?.conditions?.[index]) return;

            const current = node.config.trigger.conditions[index].connector || 'AND';
            node.config.trigger.conditions[index].connector = current === 'AND' ? 'OR' : 'AND';

            engine.loadConfig(config);
            saveToStorage();
            renderDetailPanel();
        }

        function renderModifierConditions(type = 'apply') {
            const containerId = type === 'apply' ? 'modifierConditionsList' : 'modifierRemoveConditionsList';
            const container = document.getElementById(containerId);
            if (!container) return;

            const conditions = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;

            // Get valid targets grouped by type
            const attributes = config.nodes.filter(n => n.type === 'attribute');
            const variables = config.nodes.filter(n => n.type === 'variable');
            const modifiers = config.nodes.filter(n => n.type === 'modifier');
            const traits = config.nodes.filter(n => n.type === 'trait' || n.type === 'item');
            const compounds = config.nodes.filter(n => n.type === 'compound');

            // Build optgroup-based options
            const buildTargetOptions = (selected) => {
                let opts = '<option value="">-- Select --</option>';
                if (attributes.length > 0) {
                    opts += `<optgroup label="Attributes">`;
                    opts += attributes.map(n => `<option value="${n.id}" ${selected === n.id ? 'selected' : ''}>${n.name}</option>`).join('');
                    opts += '</optgroup>';
                }
                if (variables.length > 0) {
                    opts += `<optgroup label="Variables">`;
                    opts += variables.map(n => `<option value="${n.id}" ${selected === n.id ? 'selected' : ''}>${n.name}</option>`).join('');
                    opts += '</optgroup>';
                }
                if (modifiers.length > 0) {
                    opts += `<optgroup label="Modifiers">`;
                    opts += modifiers.map(n => `<option value="${n.id}" ${selected === n.id ? 'selected' : ''}>${n.name}</option>`).join('');
                    opts += '</optgroup>';
                }
                if (traits.length > 0) {
                    opts += `<optgroup label="Traits">`;
                    opts += traits.map(n => `<option value="${n.id}" ${selected === n.id ? 'selected' : ''}>${n.name}</option>`).join('');
                    opts += '</optgroup>';
                }
                if (compounds.length > 0) {
                    opts += `<optgroup label="Compounds">`;
                    opts += compounds.map(n => `<option value="${n.id}" ${selected === n.id ? 'selected' : ''}>${n.name}</option>`).join('');
                    opts += '</optgroup>';
                }
                return opts;
            };

            // Determine if target is numeric
            const isNumericTarget = (targetId) => {
                const node = config.nodes.find(n => n.id === targetId);
                return node && ['attribute', 'variable', 'derived'].includes(node.type);
            };

            // Render a single condition row with drag-and-drop
            const renderConditionRow = (cond, idx, groupIndex = null) => {
                const isNumeric = isNumericTarget(cond.target);
                const showValueField = isNumeric && !['active', 'inactive'].includes(cond.operator);
                const groupParam = groupIndex !== null ? `, ${groupIndex}` : '';
                const canDelete = groupIndex !== null
                    ? conditions[groupIndex].conditions.length > 1
                    : conditions.length > 1;

                // Data attributes for drag-and-drop
                const dragData = groupIndex !== null
                    ? `data-type="${type}" data-index="${idx}" data-group="${groupIndex}"`
                    : `data-type="${type}" data-index="${idx}"`;

                return `
                    <div class="condition-row" ${dragData}
                         draggable="true"
                         ondragstart="handleConditionDragStart(event)"
                         ondragover="handleConditionDragOver(event)"
                         ondrop="handleConditionDrop(event)"
                         ondragend="handleConditionDragEnd(event)"
                         style="display: flex; flex-wrap: wrap; gap: 0.35rem; align-items: center; padding: 0.4rem; background: rgba(0,0,0,0.2); border-radius: 4px;">
                        <span class="drag-handle" style="cursor: grab; color: var(--text-muted); font-size: 0.7rem; margin-right: 0.1rem;" title="Drag to reorder or group">â‹®â‹®</span>
                        <select onchange="updateModifierCondition('${type}', ${idx}, 'target', this.value${groupParam})" style="flex: 1; min-width: 90px; max-width: 130px; font-size: 0.8rem;">
                            ${buildTargetOptions(cond.target)}
                        </select>
                        <select onchange="updateModifierCondition('${type}', ${idx}, 'operator', this.value${groupParam})" style="width: auto; min-width: 45px; font-size: 0.8rem;">
                            ${isNumeric ? `
                                <option value="<" ${cond.operator === '<' ? 'selected' : ''}>&lt;</option>
                                <option value="<=" ${cond.operator === '<=' ? 'selected' : ''}>&le;</option>
                                <option value=">" ${cond.operator === '>' ? 'selected' : ''}>&gt;</option>
                                <option value=">=" ${cond.operator === '>=' ? 'selected' : ''}>&ge;</option>
                                <option value="=" ${cond.operator === '=' ? 'selected' : ''}>=</option>
                            ` : `
                                <option value="active" ${cond.operator === 'active' ? 'selected' : ''}>active</option>
                                <option value="inactive" ${cond.operator === 'inactive' ? 'selected' : ''}>inactive</option>
                            `}
                        </select>
                        ${showValueField ? `<input type="number" value="${cond.value}" onchange="updateModifierCondition('${type}', ${idx}, 'value', this.value${groupParam})" onfocus="this.parentElement.draggable=false" onblur="this.parentElement.draggable=true" onclick="this.select()" style="width: 60px; font-size: 0.8rem;">` : ''}
                        ${groupIndex !== null ? `<button type="button" class="btn btn-secondary btn-sm" onclick="moveConditionOutOfGroup('${type}', ${idx}, ${groupIndex})" style="padding: 0.1rem 0.3rem; font-size: 0.65rem;" title="Move out of group">â†‘</button>` : ''}
                        ${canDelete ? `<button type="button" class="btn btn-danger btn-sm" onclick="removeModifierCondition('${type}', ${idx}${groupParam})" style="padding: 0.1rem 0.35rem; font-size: 0.7rem;">&times;</button>` : ''}
                    </div>
                `;
            };

            // Render connector dropdown with distinct colors
            const renderConnector = (connector, idx, groupIndex = null) => {
                const groupParam = groupIndex !== null ? `, ${groupIndex}` : '';
                const andStyle = connector === 'AND' ? 'background: rgba(100, 180, 100, 0.3); color: #8fbc8f;' : '';
                const orStyle = connector === 'OR' ? 'background: rgba(167, 141, 182, 0.3); color: #c4a8d0;' : '';
                return `
                    <div class="condition-connector" style="display: flex; justify-content: ${groupIndex !== null ? 'flex-start' : 'center'}; margin: 0.2rem 0;">
                        <select onchange="updateConditionConnector('${type}', ${idx}, this.value${groupParam})" class="connector-select" data-value="${connector}" style="width: auto; padding: 0.1rem 0.4rem; font-size: 0.7rem; font-weight: bold; border: 1px solid var(--copper-dark); border-radius: 3px; ${connector === 'AND' ? andStyle : orStyle}">
                            <option value="AND" ${connector === 'AND' ? 'selected' : ''} style="background: rgba(100, 180, 100, 0.3); color: #8fbc8f;">AND</option>
                            <option value="OR" ${connector === 'OR' ? 'selected' : ''} style="background: rgba(167, 141, 182, 0.3); color: #c4a8d0;">OR</option>
                        </select>
                    </div>
                `;
            };

            // Build the HTML
            const html = conditions.map((item, idx) => {
                const isFirst = idx === 0;
                const canDeleteItem = conditions.length > 1;

                // Top-level connector
                const connectorHtml = !isFirst ? renderConnector(item.connector, idx) : '';

                // Check if this is a group
                if (item.type === 'group') {
                    // Render group with indented conditions
                    const groupConditionsHtml = item.conditions.map((cond, gIdx) => {
                        const gConnector = gIdx > 0 ? renderConnector(cond.connector, gIdx, idx) : '';
                        return gConnector + renderConditionRow(cond, gIdx, idx);
                    }).join('');

                    return `${connectorHtml}
                        <div class="condition-group" data-type="${type}" data-group-index="${idx}"
                             ondragover="handleGroupDragOver(event)"
                             ondrop="handleGroupDrop(event)"
                             ondragleave="handleGroupDragLeave(event)"
                             style="margin-left: 1rem; padding: 0.5rem; border-left: 2px solid var(--copper); background: rgba(167,141,182,0.08); border-radius: 0 4px 4px 0;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.3rem;">
                                <span style="font-size: 0.7rem; color: var(--copper); font-weight: bold;">(Group)</span>
                                <button type="button" class="btn btn-secondary btn-sm" onclick="removeModifierConditionGroup('${type}', ${idx})" style="padding: 0.1rem 0.4rem; font-size: 0.6rem;" title="Ungroup (keep conditions)">ungroup</button>
                            </div>
                            ${groupConditionsHtml}
                            <button type="button" class="btn btn-secondary btn-sm" onclick="addModifierCondition('${type}', ${idx})" style="margin-top: 0.3rem; padding: 0.15rem 0.4rem; font-size: 0.7rem;">+ Add to group</button>
                        </div>
                    `;
                }

                // Regular condition
                return connectorHtml + renderConditionRow(item, idx);
            }).join('');

            container.innerHTML = html;

            // Update English preview
            updateModifierEnglishPreview();
        }

        // Generate English description of conditions
        function generateConditionsEnglish(conditions, prefix = '') {
            if (!conditions || conditions.length === 0) return '';

            const parts = [];
            for (let i = 0; i < conditions.length; i++) {
                const item = conditions[i];
                const connector = i > 0 ? ` ${item.connector || 'AND'} ` : '';

                if (item.type === 'group') {
                    // Handle group
                    const groupParts = item.conditions.map((c, gi) => {
                        const gConn = gi > 0 ? ` ${c.connector || 'OR'} ` : '';
                        return gConn + formatSingleCondition(c);
                    }).join('');
                    parts.push(connector + '(' + groupParts + ')');
                } else {
                    parts.push(connector + formatSingleCondition(item));
                }
            }
            return prefix + parts.join('');
        }

        function formatSingleCondition(cond) {
            if (!cond.target) return '(incomplete)';
            const node = config.nodes.find(n => n.id === cond.target);
            const name = node?.name || cond.target;

            if (cond.operator === 'active') return `${name} is active`;
            if (cond.operator === 'inactive') return `${name} is inactive`;

            const opWords = {
                '<': 'is less than',
                '<=': 'is less than or equal to',
                '>': 'is greater than',
                '>=': 'is greater than or equal to',
                '=': 'equals'
            };
            return `${name} ${opWords[cond.operator] || cond.operator} ${cond.value}`;
        }

        function updateModifierEnglishPreview() {
            const previewEl = document.getElementById('modifierEnglishPreview');
            if (!previewEl) return;

            const isReactive = document.getElementById('modRemovalReactive')?.checked ?? true;
            const applyText = generateConditionsEnglish(modifierApplyConditions);

            if (!applyText || applyText.includes('(incomplete)')) {
                previewEl.innerHTML = '<em style="color: var(--text-muted);">Configure conditions to see preview...</em>';
                return;
            }

            let html = `<strong>Applies when:</strong> ${applyText}`;

            if (isReactive) {
                // Generate inverse for reactive mode
                const removeText = generateInverseEnglish(modifierApplyConditions);
                html += `<br><strong>Removes when:</strong> ${removeText}`;
            } else if (modifierRemoveConditions.length > 0) {
                const removeText = generateConditionsEnglish(modifierRemoveConditions);
                if (removeText && !removeText.includes('(incomplete)')) {
                    html += `<br><strong>Removes when:</strong> ${removeText}`;
                }
            }

            previewEl.innerHTML = html;
        }

        function generateInverseEnglish(conditions) {
            // For reactive mode, removal is when apply conditions are NO LONGER met
            if (!conditions || conditions.length === 0) return 'conditions are no longer met';

            // Simple case: single condition
            if (conditions.length === 1 && conditions[0].type !== 'group') {
                const cond = conditions[0];
                if (!cond.target) return 'conditions are no longer met';
                const node = config.nodes.find(n => n.id === cond.target);
                const name = node?.name || cond.target;

                if (cond.operator === 'active') return `${name} becomes inactive`;
                if (cond.operator === 'inactive') return `${name} becomes active`;

                const inverseOps = { '<': '>=', '<=': '>', '>': '<=', '>=': '<', '=': 'â‰ ' };
                const opWords = {
                    '<': 'is less than',
                    '<=': 'is less than or equal to',
                    '>': 'is greater than',
                    '>=': 'is greater than or equal to',
                    '=': 'equals',
                    'â‰ ': 'is not equal to'
                };
                const invOp = inverseOps[cond.operator] || cond.operator;
                return `${name} ${opWords[invOp]} ${cond.value}`;
            }

            // Complex case: describe as "conditions no longer met"
            return 'apply conditions are no longer met';
        }

        // Drag-and-drop state
        let conditionDragData = null;

        function handleConditionDragStart(event) {
            const row = event.target.closest('.condition-row');
            if (!row) return;

            conditionDragData = {
                type: row.dataset.type,
                index: parseInt(row.dataset.index),
                groupIndex: row.dataset.group !== undefined ? parseInt(row.dataset.group) : null
            };

            row.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', ''); // Required for Firefox
        }

        function handleConditionDragEnd(event) {
            const row = event.target.closest('.condition-row');
            if (row) row.classList.remove('dragging');

            // Clear all drag-over states
            document.querySelectorAll('.condition-row.drag-over, .condition-group.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });

            conditionDragData = null;
        }

        function handleConditionDragOver(event) {
            event.preventDefault();
            if (!conditionDragData) return;

            const row = event.target.closest('.condition-row');
            if (!row || row.classList.contains('dragging')) return;

            // Don't allow drop on self
            const targetIndex = parseInt(row.dataset.index);
            const targetGroup = row.dataset.group !== undefined ? parseInt(row.dataset.group) : null;

            if (conditionDragData.index === targetIndex && conditionDragData.groupIndex === targetGroup) {
                return;
            }

            row.classList.add('drag-over');
        }

        function handleConditionDrop(event) {
            event.preventDefault();
            event.stopPropagation();

            const row = event.target.closest('.condition-row');
            if (!row || !conditionDragData) return;

            row.classList.remove('drag-over');

            const targetType = row.dataset.type;
            const targetIndex = parseInt(row.dataset.index);
            const targetGroup = row.dataset.group !== undefined ? parseInt(row.dataset.group) : null;

            // Validate same type (apply/remove)
            if (targetType !== conditionDragData.type) return;

            // Don't drop on self
            if (conditionDragData.index === targetIndex && conditionDragData.groupIndex === targetGroup) return;

            const arr = targetType === 'apply' ? modifierApplyConditions : modifierRemoveConditions;

            // Get the dragged condition
            let draggedCond;
            if (conditionDragData.groupIndex !== null) {
                draggedCond = { ...arr[conditionDragData.groupIndex].conditions[conditionDragData.index] };
            } else {
                draggedCond = { ...arr[conditionDragData.index] };
            }

            // Case 1: Both at top level - create a new group containing both
            if (conditionDragData.groupIndex === null && targetGroup === null) {
                // Remove dragged from top level
                const dragIdx = conditionDragData.index;
                const targetIdx = targetIndex;

                // Get both conditions
                const cond1 = { ...arr[targetIdx] };
                const cond2 = { ...arr[dragIdx] };

                // Remove connectors for inside group
                delete cond1.connector;
                cond2.connector = 'OR'; // Default to OR inside groups

                // Create group at target position
                const newGroup = {
                    type: 'group',
                    connector: cond1.connector || (targetIdx > 0 ? 'AND' : undefined),
                    conditions: [cond1, cond2]
                };

                // Remove in reverse order to maintain indices
                const indicesToRemove = [dragIdx, targetIdx].sort((a, b) => b - a);
                indicesToRemove.forEach(i => arr.splice(i, 1));

                // Insert group at min position
                const insertAt = Math.min(dragIdx, targetIdx);
                arr.splice(insertAt, 0, newGroup);

                // Fix connectors
                if (insertAt === 0 && arr[0].connector) delete arr[0].connector;
            }
            // Case 2: Dragged is in a group, target is at top level - move out of group
            else if (conditionDragData.groupIndex !== null && targetGroup === null) {
                const group = arr[conditionDragData.groupIndex];

                // Remove from group
                group.conditions.splice(conditionDragData.index, 1);

                // Add connector for top level
                draggedCond.connector = 'AND';

                // Insert after target
                arr.splice(targetIndex + 1, 0, draggedCond);

                // Check if group should be dissolved
                checkAndDissolveGroup(targetType, conditionDragData.groupIndex);
            }
            // Case 3: Dragged is at top level, target is in a group - add to group
            else if (conditionDragData.groupIndex === null && targetGroup !== null) {
                const group = arr[targetGroup];

                // Remove from top level
                arr.splice(conditionDragData.index, 1);

                // Add connector for inside group
                draggedCond.connector = 'OR';

                // Insert after target in group
                group.conditions.splice(targetIndex + 1, 0, draggedCond);

                // Fix top-level connectors
                if (arr.length > 0 && arr[0].connector) delete arr[0].connector;
            }
            // Case 4: Both in groups (same or different)
            else if (conditionDragData.groupIndex !== null && targetGroup !== null) {
                if (conditionDragData.groupIndex === targetGroup) {
                    // Same group - reorder within group
                    const group = arr[conditionDragData.groupIndex];
                    group.conditions.splice(conditionDragData.index, 1);
                    const newIdx = conditionDragData.index < targetIndex ? targetIndex : targetIndex + 1;
                    group.conditions.splice(newIdx, 0, draggedCond);

                    // Fix first connector
                    if (group.conditions[0].connector) delete group.conditions[0].connector;
                } else {
                    // Different groups - move between groups
                    const srcGroup = arr[conditionDragData.groupIndex];
                    const dstGroup = arr[targetGroup];

                    srcGroup.conditions.splice(conditionDragData.index, 1);
                    draggedCond.connector = 'OR';
                    dstGroup.conditions.splice(targetIndex + 1, 0, draggedCond);

                    // Check source group dissolution
                    checkAndDissolveGroup(targetType, conditionDragData.groupIndex);
                }
            }

            renderModifierConditions(targetType);
        }

        function handleGroupDragOver(event) {
            event.preventDefault();
            if (!conditionDragData) return;

            // Only accept if dragging from top level (not already in a group)
            if (conditionDragData.groupIndex !== null) return;

            const group = event.target.closest('.condition-group');
            if (group) group.classList.add('drag-over');
        }

        function handleGroupDragLeave(event) {
            const group = event.target.closest('.condition-group');
            if (group && !group.contains(event.relatedTarget)) {
                group.classList.remove('drag-over');
            }
        }

        function handleGroupDrop(event) {
            event.preventDefault();
            event.stopPropagation();

            const groupEl = event.target.closest('.condition-group');
            if (!groupEl || !conditionDragData) return;

            groupEl.classList.remove('drag-over');

            // Only accept from top level
            if (conditionDragData.groupIndex !== null) return;

            const targetType = groupEl.dataset.type;
            const targetGroupIndex = parseInt(groupEl.dataset.groupIndex);

            if (targetType !== conditionDragData.type) return;

            const arr = targetType === 'apply' ? modifierApplyConditions : modifierRemoveConditions;
            const group = arr[targetGroupIndex];

            // Get dragged condition
            const draggedCond = { ...arr[conditionDragData.index] };

            // Remove from top level
            arr.splice(conditionDragData.index, 1);

            // Add to group with OR connector
            draggedCond.connector = group.conditions.length > 0 ? 'OR' : undefined;
            group.conditions.push(draggedCond);

            // Fix top-level connectors
            if (arr.length > 0 && arr[0].connector) delete arr[0].connector;

            renderModifierConditions(targetType);
        }

        // Check if a group should be dissolved (< 2 conditions)
        function checkAndDissolveGroup(type, groupIndex) {
            const arr = type === 'apply' ? modifierApplyConditions : modifierRemoveConditions;
            const group = arr[groupIndex];

            if (!group || group.type !== 'group') return;

            if (group.conditions.length < 2) {
                if (group.conditions.length === 1) {
                    // Move single condition to top level
                    const cond = group.conditions[0];
                    cond.connector = group.connector;
                    arr.splice(groupIndex, 1, cond);
                } else {
                    // Empty group - remove it
                    arr.splice(groupIndex, 1);
                }

                // Fix first connector
                if (arr.length > 0 && arr[0].connector) delete arr[0].connector;
            }
        }

        // Compound requirement builder state
        let compoundRequirements = [];

        function initCompoundRequirements() {
            compoundRequirements = [
                { nodeId: '', nodeType: '', operator: '', value: 0 },
                { nodeId: '', nodeType: '', operator: '', value: 0 }
            ];
            renderCompoundRequirements();
        }

        function addCompoundRequirementRow() {
            compoundRequirements.push({
                nodeId: '',
                nodeType: '',
                operator: '',  // Empty = "is active"
                value: 0
            });
            renderCompoundRequirements();
        }

        function removeCompoundRequirementRow(index) {
            compoundRequirements.splice(index, 1);
            renderCompoundRequirements();
        }

        function updateCompoundRequirementRow(index, field, value) {
            if (compoundRequirements[index]) {
                compoundRequirements[index][field] = field === 'value' ? parseFloat(value) || 0 : value;

                // When node changes, update the type and reset operator/value if needed
                if (field === 'nodeId' && value) {
                    const node = config.nodes.find(n => n.id === value);
                    compoundRequirements[index].nodeType = node?.type || '';

                    // Reset operator to "is active" for non-numeric nodes
                    const isNumeric = ['attribute', 'variable', 'derived'].includes(node?.type);
                    if (!isNumeric) {
                        compoundRequirements[index].operator = '';
                    }
                }
                renderCompoundRequirements();
            }
        }

        function renderCompoundRequirements() {
            const container = document.getElementById('compoundRequirementsList');
            if (!container) return;

            // Get requireable nodes
            const requireables = config.nodes.filter(n =>
                ['trait', 'item', 'modifier', 'attribute', 'variable', 'compound'].includes(n.type)
            );

            // Group by type for optgroups
            const byType = {
                trait: requireables.filter(n => n.type === 'trait' || n.type === 'item'),
                modifier: requireables.filter(n => n.type === 'modifier'),
                compound: requireables.filter(n => n.type === 'compound'),
                attribute: requireables.filter(n => n.type === 'attribute'),
                variable: requireables.filter(n => n.type === 'variable')
            };

            if (compoundRequirements.length === 0) {
                container.innerHTML = `
                    <div class="empty-hint" style="padding: 0.5rem; color: var(--text-muted); text-align: center;">
                        No requirements defined. Click "+ Add Requirement" to add conditions.
                    </div>
                `;
                return;
            }

            const html = compoundRequirements.map((req, idx) => {
                const showAndLabel = idx > 0;
                const node = req.nodeId ? config.nodes.find(n => n.id === req.nodeId) : null;
                const isNumeric = node && ['attribute', 'variable', 'derived'].includes(node.type);

                return `
                    <div class="condition-row" style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem; padding: 0.3rem; background: rgba(0,0,0,0.2); border-radius: 4px; flex-wrap: nowrap;">
                        <span style="color: var(--copper); font-weight: bold; min-width: 32px; text-align: center; font-size: 0.8rem;">
                            ${showAndLabel ? 'AND' : ''}
                        </span>
                        <select onchange="updateCompoundRequirementRow(${idx}, 'nodeId', this.value)" style="flex: 1; min-width: 90px;">
                            <option value="">-- Select node --</option>
                            ${byType.trait.length ? `<optgroup label="Traits">${byType.trait.map(n =>
                                `<option value="${n.id}" ${req.nodeId === n.id ? 'selected' : ''}>${n.name}</option>`
                            ).join('')}</optgroup>` : ''}
                            ${byType.modifier.length ? `<optgroup label="Modifiers">${byType.modifier.map(n =>
                                `<option value="${n.id}" ${req.nodeId === n.id ? 'selected' : ''}>${n.name}</option>`
                            ).join('')}</optgroup>` : ''}
                            ${byType.compound.length ? `<optgroup label="Compounds">${byType.compound.map(n =>
                                `<option value="${n.id}" ${req.nodeId === n.id ? 'selected' : ''}>${n.name}</option>`
                            ).join('')}</optgroup>` : ''}
                            ${byType.attribute.length ? `<optgroup label="Attributes">${byType.attribute.map(n =>
                                `<option value="${n.id}" ${req.nodeId === n.id ? 'selected' : ''}>${n.name}</option>`
                            ).join('')}</optgroup>` : ''}
                            ${byType.variable.length ? `<optgroup label="Variables">${byType.variable.map(n =>
                                `<option value="${n.id}" ${req.nodeId === n.id ? 'selected' : ''}>${n.name}</option>`
                            ).join('')}</optgroup>` : ''}
                        </select>
                        ${isNumeric ? `
                        <select onchange="updateCompoundRequirementRow(${idx}, 'operator', this.value)" style="width: 55px;">
                            <option value="" ${!req.operator ? 'selected' : ''}>is active</option>
                            <option value="<" ${req.operator === '<' ? 'selected' : ''}>&lt;</option>
                            <option value="<=" ${req.operator === '<=' ? 'selected' : ''}>â‰¤</option>
                            <option value=">" ${req.operator === '>' ? 'selected' : ''}>&gt;</option>
                            <option value=">=" ${req.operator === '>=' ? 'selected' : ''}>â‰¥</option>
                            <option value="=" ${req.operator === '=' ? 'selected' : ''}>=</option>
                        </select>
                        <input type="number" value="${req.value}" onchange="updateCompoundRequirementRow(${idx}, 'value', this.value)"
                            style="width: 50px; ${req.operator ? '' : 'display: none;'}">
                        ` : `${req.nodeId ? '<span style="font-size: 0.75rem; color: var(--text-muted); white-space: nowrap;">is active</span>' : ''}`}
                        <button type="button" class="btn btn-danger btn-sm" onclick="removeCompoundRequirementRow(${idx})" style="padding: 0.25rem 0.5rem;" title="Remove">&times;</button>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function toggleTickIntervalField() {
            const tickType = document.getElementById('newNodeTickType')?.value || 'manual';
            const intervalRow = document.getElementById('tickIntervalRow');
            if (intervalRow) {
                intervalRow.style.display = tickType === 'timed' ? 'flex' : 'none';
            }
        }

        function toggleModifierTickSystemField() {
            const durationType = document.getElementById('newNodeDurationType')?.value || '';
            const tickSystemRow = document.getElementById('modifierTickSystemRow');
            const tickSystemSelect = document.getElementById('newNodeTickSystemId');
            const durationField = document.getElementById('modifierDurationField');

            // Show duration field only for tick-based
            if (durationField) {
                durationField.style.display = durationType === 'ticks' ? 'block' : 'none';
            }

            // Show tick system row only for tick-based
            if (tickSystemRow) {
                tickSystemRow.style.display = durationType === 'ticks' ? 'flex' : 'none';
            }

            // Populate tick system dropdown with existing tick systems
            if (tickSystemSelect && durationType === 'ticks') {
                const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');
                tickSystemSelect.innerHTML = '<option value="">-- Select tick system --</option>';
                tickSystems.forEach(ts => {
                    tickSystemSelect.innerHTML += `<option value="${ts.id}">${ts.name || ts.id}</option>`;
                });

                // Auto-select if there's only one tick system
                if (tickSystems.length === 1) {
                    tickSystemSelect.value = tickSystems[0].id;
                }
            }
        }

        function toggleTraitThresholdConfig() {
            const mode = document.getElementById('newNodeTraitSelectionMode')?.value || 'weighted';
            const weightedConfig = document.getElementById('traitWeightedConfig');
            const thresholdConfig = document.getElementById('traitThresholdConfig');

            if (weightedConfig) weightedConfig.style.display = mode === 'weighted' ? 'block' : 'none';
            if (thresholdConfig) thresholdConfig.style.display = mode === 'threshold' ? 'block' : 'none';
        }

        function toggleVariableRateSection() {
            const mode = document.getElementById('newNodeChangeMode')?.value || 'manual';
            const rateSection = document.getElementById('variableRateSection');
            const tickSystemSection = document.getElementById('variableTickSystemSection');

            if (rateSection) {
                // Show rate section for both timed and perTick modes
                rateSection.style.display = (mode === 'timed' || mode === 'perTick') ? 'block' : 'none';
            }

            // Show tick system dropdown only for perTick mode
            if (tickSystemSection) {
                tickSystemSection.style.display = mode === 'perTick' ? 'block' : 'none';
                if (mode === 'perTick') {
                    // Populate tick system dropdown
                    const tickSelect = document.getElementById('newNodeTickSystemId');
                    if (tickSelect) {
                        const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');
                        tickSelect.innerHTML = '<option value="">-- Select tick system --</option>' +
                            tickSystems.map(ts =>
                                `<option value="${ts.id}">${ts.name} (${ts.config?.tickUnit?.label || 'tick'})</option>`
                            ).join('');
                        // Auto-select if only one tick system
                        if (tickSystems.length === 1) {
                            tickSelect.value = tickSystems[0].id;
                        }
                    }
                }
            }
        }

        function setVariableRate(rate) {
            const input = document.getElementById('newNodeRate');
            if (input) {
                input.value = rate;
            }
        }

        // Track if user has manually edited the ID
        let userEditedId = false;
        let idLocked = true; // ID is locked by default
        let detailIdLocked = true; // ID is locked by default in detail panel

        // Toggle ID lock in detail (edit) panel
        function toggleDetailIdLock() {
            detailIdLocked = !detailIdLocked;
            const idInput = document.getElementById('detailNodeId');
            const lockBtn = document.getElementById('detailIdLockBtn');
            if (idInput) {
                idInput.disabled = detailIdLocked;
                idInput.style.opacity = detailIdLocked ? '0.7' : '1';
            }
            if (lockBtn) {
                lockBtn.textContent = detailIdLocked ? 'ðŸ”’' : 'ðŸ”“';
                lockBtn.title = detailIdLocked ? 'Click to edit ID (may break connections)' : 'Click to lock ID';
            }
        }

        // Handle ID change in detail panel with warning
        function handleDetailIdChange(oldId, newId) {
            if (!newId || newId.trim() === '') {
                alert('ID cannot be empty');
                document.getElementById('detailNodeId').value = oldId;
                return;
            }

            newId = newId.trim();

            // Check for duplicate
            if (config.nodes.some(n => n.id === newId && n.id !== oldId)) {
                alert('A node with this ID already exists');
                document.getElementById('detailNodeId').value = oldId;
                return;
            }

            // Check if this change would break relationships
            const affectedRels = config.relationships.filter(r => r.sourceId === oldId || r.targetId === oldId);
            if (affectedRels.length > 0) {
                const proceed = confirm(`Changing this ID will update ${affectedRels.length} connection(s) that reference it.\n\nContinue?`);
                if (!proceed) {
                    document.getElementById('detailNodeId').value = oldId;
                    return;
                }

                // Update all relationships
                affectedRels.forEach(r => {
                    if (r.sourceId === oldId) r.sourceId = newId;
                    if (r.targetId === oldId) r.targetId = newId;
                });
            }

            // Update exclusiveWith references in other modifiers
            config.nodes.forEach(n => {
                if (n.config?.exclusiveWith) {
                    const idx = n.config.exclusiveWith.indexOf(oldId);
                    if (idx !== -1) n.config.exclusiveWith[idx] = newId;
                }
            });

            // Update the node ID
            updateNode(oldId, 'id', newId);

            // Re-lock the field after change
            detailIdLocked = true;
        }

        function toggleIdLock() {
            idLocked = !idLocked;
            const idInput = document.getElementById('newNodeId');
            const lockBtn = document.getElementById('idLockBtn');
            if (idInput) {
                idInput.disabled = idLocked;
                idInput.style.opacity = idLocked ? '0.7' : '1';
            }
            if (lockBtn) {
                lockBtn.textContent = idLocked ? 'ðŸ”’' : 'ðŸ”“';
                lockBtn.title = idLocked ? 'Click to edit ID manually' : 'Click to lock ID (auto-generate)';
            }
            // If unlocking, mark as user edited; if locking, regenerate
            if (!idLocked) {
                userEditedId = true;
            } else {
                userEditedId = false;
                autoGenerateNodeId();
            }
        }

        function autoGenerateNodeId() {
            const idInput = document.getElementById('newNodeId');
            const nameInput = document.getElementById('newNodeName');

            // Fields may not exist yet if no type is selected
            if (!idInput || !nameInput) return;

            // Only auto-generate if user hasn't manually edited the ID
            if (userEditedId && idInput.value.trim() !== '') return;

            const name = nameInput?.value || '';
            if (!name.trim()) {
                idInput.value = '';
                return;
            }

            // Generate ID with type prefix
            const typePrefix = {
                'attribute': 'attr_',
                'variable': 'var_',
                'context': 'ctx_',
                'layer': 'layer_',
                'trait': 'trait_',
                'item': 'item_',
                'modifier': 'mod_',
                'compound': 'comp_',
                'action': 'act_',
                'derived': 'derived_',
                'ticksystem': 'tick_'
            }[newNodeType] || '';

            // Convert name to snake_case ID
            const baseId = name
                .toLowerCase()
                .replace(/[^a-z0-9\s]/g, '')
                .trim()
                .replace(/\s+/g, '_');

            let proposedId = typePrefix + baseId;

            // Ensure uniqueness by adding suffix if needed
            let suffix = 1;
            while (config.nodes.some(n => n.id === proposedId)) {
                proposedId = typePrefix + baseId + '_' + suffix;
                suffix++;
            }

            idInput.value = proposedId;
        }

        // Note: ID lock state is now reset in showAddNodeModal() and openAddNodeOfType()
        // The Name/ID fields are rendered dynamically, so we use event delegation for tracking manual edits
        document.addEventListener('input', (e) => {
            if (e.target && e.target.id === 'newNodeId') {
                userEditedId = true;
            }
        });

        function setTraitWeight(weight) {
            const input = document.getElementById('newNodeWeight');
            if (input) {
                input.value = weight;
                updateTraitWeightPreview();
            }
        }

        function updateTraitWeightPreview() {
            const container = document.getElementById('traitWeightPreview');
            if (!container) return;

            const layerId = document.getElementById('newNodeLayerId')?.value;
            const newWeight = parseFloat(document.getElementById('newNodeWeight')?.value) || 20;

            if (!layerId) {
                container.innerHTML = '<div style="font-size: 0.8rem; color: var(--text-muted);">Select a layer to see probability preview</div>';
                return;
            }

            // Get existing traits in this layer
            const layer = config.nodes.find(n => n.id === layerId);
            const traitIds = layer?.config?.traitIds || layer?.config?.itemIds || [];
            const traits = config.nodes.filter(n => traitIds.includes(n.id));

            // Calculate total weight including new trait
            let totalWeight = newWeight;
            const traitWeights = traits.map(t => {
                const w = t.config?.selection?.baseWeight ?? t.config?.baseWeight ?? 20;
                totalWeight += w;
                return { name: t.name, weight: w };
            });

            if (totalWeight === 0) totalWeight = 1; // Avoid division by zero

            // Calculate probability for new trait
            const newProb = Math.round((newWeight / totalWeight) * 100);

            // Build visual bar
            let barHtml = '<div style="display: flex; height: 24px; border-radius: 4px; overflow: hidden; margin-bottom: 0.5rem;">';

            traitWeights.forEach(t => {
                const pct = Math.round((t.weight / totalWeight) * 100);
                barHtml += `<div style="width: ${pct}%; background: var(--node-trait); display: flex; align-items: center; justify-content: center; font-size: 0.7rem; color: white; min-width: 20px;" title="${t.name}: ${pct}%">${pct > 10 ? t.name : ''}</div>`;
            });

            // Add new trait segment
            barHtml += `<div style="width: ${newProb}%; background: var(--accent-primary); display: flex; align-items: center; justify-content: center; font-size: 0.7rem; color: white; min-width: 20px;" title="New trait: ${newProb}%">New</div>`;
            barHtml += '</div>';

            // Summary text
            let summaryHtml = `<div style="font-size: 0.8rem; color: var(--text-secondary);">`;
            if (traits.length === 0) {
                summaryHtml += `This will be the <strong>only trait</strong> in ${layer.name} â€” always selected.`;
            } else {
                summaryHtml += `<strong>~${newProb}%</strong> chance to be selected from ${traits.length + 1} traits in ${layer.name}`;
            }
            summaryHtml += '</div>';

            container.innerHTML = barHtml + summaryHtml;
        }

        function addNode() {
            if (typeof TIER_LIMITS !== 'undefined') {
                const check = checkNodeLimit();
                if (!check.allowed) {
                    showToast(check.reason, 'warning', TIER_TOAST_DURATION);
                    return;
                }
            }
            if (!newNodeType) {
                alert('Please select a node type');
                return;
            }

            const idInput = document.getElementById('newNodeId');
            const nameInput = document.getElementById('newNodeName');

            if (!idInput || !nameInput) {
                alert('Please select a node type first');
                return;
            }

            const id = idInput.value.trim();
            const name = nameInput.value.trim();

            if (!id || !name) {
                alert('ID and Name are required');
                return;
            }

            if (config.nodes.some(n => n.id === id)) {
                alert('Node with this ID already exists');
                return;
            }

            // Get description if present
            const description = document.getElementById('newNodeDescription')?.value?.trim() || '';

            const node = {
                id,
                name,
                type: newNodeType,
                description: description,
                tags: [],
                position: null,
                config: getDefaultConfig(newNodeType)
            };

            // Handle type-specific fields
            if (newNodeType === 'attribute') {
                const valueMode = document.getElementById('newAttrValueMode')?.value || 'range';
                const precision = parseInt(document.getElementById('newNodePrecision')?.value) || 0;
                node.config.precision = precision;

                if (valueMode === 'fixed') {
                    const fixedVal = parseFloat(document.getElementById('newNodeFixed')?.value) || 5;
                    node.config.min = fixedVal;
                    node.config.max = fixedVal;
                    node.config.defaultRange = [fixedVal, fixedVal];
                } else {
                    const min = parseFloat(document.getElementById('newNodeMin')?.value) || 1;
                    const max = parseFloat(document.getElementById('newNodeMax')?.value) || 10;
                    const defaultVal = document.getElementById('newNodeDefault')?.value;
                    node.config.min = min;
                    node.config.max = max;
                    node.config.defaultRange = [min, max];
                    if (defaultVal && defaultVal.trim() !== '') {
                        node.config.default = parseFloat(defaultVal);
                    }
                }
            } else if (newNodeType === 'variable') {
                // Bounds (hard limits)
                node.config.min = parseFloat(document.getElementById('newNodeMin')?.value) || 0;
                node.config.max = parseFloat(document.getElementById('newNodeMax')?.value) || 100;

                // Initial range for spawning
                const initialMin = parseFloat(document.getElementById('newNodeInitialMin')?.value) || 50;
                const initialMax = parseFloat(document.getElementById('newNodeInitialMax')?.value) || 50;
                node.config.initialRange = [initialMin, initialMax];
                // For backwards compatibility, also set initial to the midpoint
                node.config.initial = (initialMin + initialMax) / 2;

                node.config.changeMode = document.getElementById('newNodeChangeMode')?.value || 'manual';

                const rate = parseFloat(document.getElementById('newNodeRate')?.value) || 0;
                node.config.baseRate = rate;

                // Tick system binding for perTick variables
                const tickSystemId = document.getElementById('newNodeTickSystemId')?.value;
                if (tickSystemId && node.config.changeMode === 'perTick') {
                    node.config.tickSystemId = tickSystemId;
                }
            } else if (newNodeType === 'layer') {
                node.config.order = parseInt(document.getElementById('newNodeOrder')?.value) || 0;
                const maxItems = parseInt(document.getElementById('newNodeMaxItems')?.value) || 1;
                const minRolls = parseInt(document.getElementById('newNodeMinRolls')?.value) || 1;
                const maxRolls = parseInt(document.getElementById('newNodeMaxRolls')?.value) || 1;
                const selectionMode = document.getElementById('newNodeSelectionMode')?.value || 'weighted';
                const rollTiming = document.getElementById('newNodeRollTiming')?.value || 'spawn';
                const weightFloor = parseFloat(document.getElementById('newNodeWeightFloor')?.value) || 0;
                const diminishingReturns = document.getElementById('newNodeDiminishingReturns')?.checked || false;
                node.config.selection = {
                    mode: selectionMode,
                    maxItems: maxItems,
                    initialRolls: maxRolls,
                    minRolls: minRolls,
                    maxRolls: maxRolls,
                    weightFloor: weightFloor,
                    diminishingReturns: diminishingReturns
                };
                node.config.timing = { rollAt: rollTiming };
            } else if (newNodeType === 'item' || newNodeType === 'trait') {
                node.config.layerId = document.getElementById('newNodeLayerId')?.value || '';
                const selectionMode = document.getElementById('newNodeTraitSelectionMode')?.value || 'weighted';

                if (selectionMode === 'weighted') {
                    const weight = parseFloat(document.getElementById('newNodeWeight')?.value) || 20;
                    node.config.selection = { mode: 'weighted', baseWeight: weight };
                } else {
                    // Threshold mode
                    const targetVar = document.getElementById('newNodeThresholdTarget')?.value || '';
                    const operator = document.getElementById('newNodeThresholdOp')?.value || '<=';
                    const thresholdValue = parseFloat(document.getElementById('newNodeThresholdValue')?.value) || 20;
                    const autoRemove = document.getElementById('newNodeAutoRemove')?.checked || false;

                    node.config.selection = {
                        mode: 'threshold',
                        trigger: {
                            target: targetVar,
                            operator: operator,
                            value: thresholdValue
                        }
                    };
                    if (autoRemove) {
                        // Default auto-remove uses opposite operator
                        const oppositeOp = operator.includes('<') ? '>=' : '<=';
                        node.config.selection.autoRemove = {
                            target: targetVar,
                            operator: oppositeOp,
                            value: thresholdValue
                        };
                    }
                }

                // Handle incompatibilities
                const incompatContainer = document.getElementById('newNodeIncompatible');
                if (incompatContainer) {
                    const incompatIds = Array.from(incompatContainer.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                    if (incompatIds.length > 0) {
                        node.config.incompatibleWith = incompatIds;
                        // Also add bidirectional incompatibility
                        incompatIds.forEach(otherTraitId => {
                            const otherTrait = config.nodes.find(n => n.id === otherTraitId);
                            if (otherTrait) {
                                if (!otherTrait.config.incompatibleWith) otherTrait.config.incompatibleWith = [];
                                if (!otherTrait.config.incompatibleWith.includes(id)) {
                                    otherTrait.config.incompatibleWith.push(id);
                                }
                            }
                        });
                    }
                }

                // Add to layer's traitIds (or itemIds for backward compatibility)
                const layer = config.nodes.find(n => n.id === node.config.layerId);
                if (layer) {
                    // Use traitIds for new configs, but support itemIds for existing
                    if (!layer.config.traitIds && !layer.config.itemIds) layer.config.traitIds = [];
                    const idsArray = layer.config.traitIds || layer.config.itemIds;
                    idsArray.push(id);
                }
            } else if (newNodeType === 'modifier') {
                node.config.durationType = document.getElementById('newNodeDurationType')?.value || 'ticks';
                node.config.duration = parseInt(document.getElementById('newNodeDuration')?.value) || 10;
                node.config.stacking = document.getElementById('newNodeStacking')?.value || 'refresh';
                node.config.maxStacks = parseInt(document.getElementById('newNodeMaxStacks')?.value) || 1;

                // Handle tick system binding for tick-based duration
                if (node.config.durationType === 'ticks') {
                    const tickSystemId = document.getElementById('newNodeTickSystemId')?.value;
                    if (tickSystemId) {
                        node.config.tickBindings = [{
                            tickSystemId: tickSystemId,
                            duration: node.config.duration
                        }];
                    }
                }

                // Handle trigger type
                const triggerType = document.getElementById('newNodeTriggerType')?.value || 'manual';
                if (triggerType === 'threshold') {
                    // Helper to convert condition or group to save format
                    const conditionToSaveFormat = (item) => {
                        // Handle groups
                        if (item.type === 'group') {
                            const savedGroup = {
                                type: 'group',
                                conditions: item.conditions
                                    .filter(c => c.target)
                                    .map(c => {
                                        const saved = { target: c.target, operator: c.operator, value: c.value };
                                        if (c.connector) saved.connector = c.connector;
                                        return saved;
                                    })
                            };
                            if (item.connector) savedGroup.connector = item.connector;
                            return savedGroup;
                        }
                        // Handle simple conditions
                        const saved = {
                            target: item.target,
                            operator: item.operator,
                            value: item.value
                        };
                        if (item.connector) {
                            saved.connector = item.connector;
                        }
                        return saved;
                    };

                    // Get valid apply conditions (simple conditions with target, or groups with at least one valid condition)
                    const validConditions = modifierApplyConditions.filter(item => {
                        if (item.type === 'group') {
                            return item.conditions.some(c => c.target);
                        }
                        return item.target;
                    });

                    if (validConditions.length > 0) {
                        // Check if reactive mode is selected (reactive = static true)
                        const isStatic = document.getElementById('modRemovalReactive')?.checked ?? true;

                        node.config.trigger = {
                            type: 'threshold',
                            static: isStatic,
                            conditions: validConditions.map(conditionToSaveFormat)
                        };

                        // For backwards compatibility, also set single target/operator/value from first simple condition
                        const firstSimple = validConditions.find(c => c.type !== 'group');
                        if (firstSimple) {
                            node.config.trigger.target = firstSimple.target;
                            node.config.trigger.operator = firstSimple.operator;
                            node.config.trigger.value = firstSimple.value;
                        }

                        // For static modifiers without custom remove conditions, removal is automatic inverse
                        // No need to save removeConditions - engine handles it
                    }
                }

                // Save exclusive modifier group (bidirectional)
                if (modifierExclusiveWith.length > 0) {
                    node.config.exclusiveWith = [...modifierExclusiveWith];
                    // Also add this new node to each partner's exclusiveWith (bidirectional)
                    for (const partnerId of modifierExclusiveWith) {
                        const partner = config.nodes.find(n => n.id === partnerId);
                        if (partner) {
                            if (!partner.config.exclusiveWith) partner.config.exclusiveWith = [];
                            if (!partner.config.exclusiveWith.includes(node.id)) {
                                partner.config.exclusiveWith.push(node.id);
                            }
                        }
                    }
                }
            } else if (newNodeType === 'compound') {
                node.config.requirementLogic = 'all';  // Compounds always require ALL conditions

                // Build requirements from the condition builder
                const validReqs = compoundRequirements.filter(r => r.nodeId);
                node.config.requires = validReqs.map(r => {
                    // If it's a numeric node with an operator, use threshold format
                    if (r.operator && ['attribute', 'variable', 'derived'].includes(r.nodeType)) {
                        return {
                            id: r.nodeId,
                            operator: r.operator,
                            value: r.value
                        };
                    }
                    // Otherwise, just use the node ID (is active check)
                    return r.nodeId;
                });
            } else if (newNodeType === 'action') {
                node.config.baseWeight = parseFloat(document.getElementById('newNodeBaseWeight')?.value) || 50;
                node.config.cooldown = parseFloat(document.getElementById('newNodeCooldown')?.value) || 0;

                // Handle initial cost if specified
                const costVar = document.getElementById('newActionCostVar')?.value;
                const costAmount = parseFloat(document.getElementById('newActionCostAmount')?.value) || 0;
                if (costVar && costAmount > 0) {
                    node.config.costs = { [costVar]: costAmount };
                }
            } else if (newNodeType === 'derived') {
                node.config.formula = document.getElementById('newNodeFormula')?.value || '0';
                // Save block model if editor was used
                const derivedEditor = _fbEditors['new'];
                if (derivedEditor && derivedEditor.model && derivedEditor.model.steps.length > 0) {
                    node.config.formulaBlocks = JSON.parse(JSON.stringify(derivedEditor.model));
                }
                const derivedMin = document.getElementById('newNodeDerivedMin')?.value;
                const derivedMax = document.getElementById('newNodeDerivedMax')?.value;
                node.config.min = derivedMin && derivedMin.trim() !== '' ? parseFloat(derivedMin) : null;
                node.config.max = derivedMax && derivedMax.trim() !== '' ? parseFloat(derivedMax) : null;
            } else if (newNodeType === 'context') {
                node.config.contextType = document.getElementById('newNodeContextType')?.value || 'enum';
                const valuesStr = document.getElementById('newNodeContextValues')?.value || '';
                node.config.values = valuesStr.split(',').map(v => v.trim()).filter(v => v);
                node.config.default = document.getElementById('newNodeContextDefault')?.value?.trim() || null;
            } else if (newNodeType === 'ticksystem') {
                node.config.tickUnit = {
                    type: document.getElementById('newNodeTickType')?.value || 'manual',
                    value: parseInt(document.getElementById('newNodeTickInterval')?.value) || 1000,
                    label: document.getElementById('newNodeTickLabel')?.value || 'tick'
                };
                node.config.triggers = {
                    start: { type: 'always', conditions: [], conditionLogic: 'all' },
                    stop: { type: 'api', conditions: [], conditionLogic: 'all' }
                };
            }

            config.nodes.push(node);
            engine.loadConfig(config);
            saveToStorage();
            closeModal('addNodeModal');
            selectNode(id);
            render();

            // Auto-equalize layer weights if trait was added to a layer with auto-equalize enabled
            if ((newNodeType === 'trait' || newNodeType === 'item') && node.config.layerId) {
                autoEqualizeLayerIfEnabled(node.config.layerId);
            }

            // Check if wizard is active and update progress
            if (typeof checkWizardProgress === 'function') {
                checkWizardProgress();
            }
        }

        function getDefaultConfig(type) {
            switch (type) {
                case 'attribute':
                    return { min: 1, max: 10, defaultRange: [1, 10], precision: 0, spawnOrder: 0 };
                case 'variable':
                    return { initial: 100, min: 0, max: 100, changeMode: 'manual', direction: 'none', baseRate: 0 };
                case 'context':
                    return { contextType: 'enum', values: [], default: null };
                case 'layer':
                    return { order: 0, timing: { rollAt: 'create' }, selection: { mode: 'weighted', maxItems: 5, initialRolls: 1 }, traitIds: [], autoEqualizeWeights: true };
                case 'item':
                case 'trait':
                case 'trait':
                    return { layerId: '', selection: { mode: 'weighted', baseWeight: 20 }, eligibility: [], effects: [], incompatibleWith: [] };
                case 'modifier':
                    return { durationType: 'ticks', duration: 10, stacking: 'refresh', maxStacks: 1, effects: [] };
                case 'compound':
                    return { requires: [], requirementLogic: 'all', replaces: [], effects: [] };
                case 'derived':
                    return { formula: '0', min: null, max: null };
                case 'ticksystem':
                    return {
                        tickUnit: { type: 'manual', value: 1000, label: 'tick' },
                        triggers: {
                            start: { type: 'always', conditions: [], conditionLogic: 'all' },
                            stop: { type: 'api', conditions: [], conditionLogic: 'all' }
                        }
                    };
                default:
                    return {};
            }
        }

        function deleteSelectedNode() {
            if (!selectedNodeId) return;
            if (!confirm('Delete this node and all its relationships?')) return;

            const nodeId = selectedNodeId;

            // Remember the layer ID if this is a trait (for auto-equalize after deletion)
            const deletedNode = config.nodes.find(n => n.id === nodeId);
            const wasTraitInLayer = (deletedNode?.type === 'trait' || deletedNode?.type === 'item') ? deletedNode.config.layerId : null;

            // Remove from nodes
            config.nodes = config.nodes.filter(n => n.id !== nodeId);

            // Clean up references to deleted node in other nodes
            for (const node of config.nodes) {
                // Remove from layer itemIds/traitIds
                if (node.type === 'layer') {
                    if (node.config.traitIds) {
                        node.config.traitIds = node.config.traitIds.filter(id => id !== nodeId);
                    }
                    if (node.config.itemIds) {
                        node.config.itemIds = node.config.itemIds.filter(id => id !== nodeId);
                    }
                }

                // Clean up incompatibleWith references in traits
                if (node.config?.incompatibleWith) {
                    node.config.incompatibleWith = node.config.incompatibleWith.filter(id => id !== nodeId);
                }

                // Clean up compound requires that reference the deleted node
                if (node.type === 'compound' && node.config?.requires) {
                    node.config.requires = node.config.requires.filter(req => {
                        if (typeof req === 'string') return req !== nodeId;
                        if (typeof req === 'object') {
                            const reqId = req.item || req.modifier || req.trait || req.attribute || req.variable || req.id;
                            return reqId !== nodeId;
                        }
                        return true;
                    });
                }
            }

            // Remove relationships
            config.relationships = config.relationships.filter(r =>
                r.sourceId !== nodeId && r.targetId !== nodeId
            );

            selectedNodeId = null;
            engine.loadConfig(config);
            saveToStorage();
            render();

            // Auto-equalize layer weights if trait was deleted from a layer with auto-equalize enabled
            if (wasTraitInLayer) {
                autoEqualizeLayerIfEnabled(wasTraitInLayer);
            }
        }

        function deleteNodeById(nodeId) {
            if (!nodeId) return;
            const node = config.nodes.find(n => n.id === nodeId);
            if (!node) return;
            if (!confirm(`Delete "${node.name}" and all its relationships?`)) return;

            // Remember the layer ID if this is a trait (for auto-equalize after deletion)
            const wasTraitInLayer = (node.type === 'trait' || node.type === 'item') ? node.config?.layerId : null;

            // Remove from nodes
            config.nodes = config.nodes.filter(n => n.id !== nodeId);

            // Clean up references to deleted node in other nodes
            for (const n of config.nodes) {
                // Remove from layer itemIds/traitIds
                if (n.type === 'layer') {
                    if (n.config.traitIds) {
                        n.config.traitIds = n.config.traitIds.filter(id => id !== nodeId);
                    }
                    if (n.config.itemIds) {
                        n.config.itemIds = n.config.itemIds.filter(id => id !== nodeId);
                    }
                }

                // Clean up incompatibleWith references in traits
                if (n.config?.incompatibleWith) {
                    n.config.incompatibleWith = n.config.incompatibleWith.filter(id => id !== nodeId);
                }

                // Clean up exclusiveWith references in modifiers
                if (n.config?.exclusiveWith) {
                    n.config.exclusiveWith = n.config.exclusiveWith.filter(id => id !== nodeId);
                }

                // Clean up compound requires that reference the deleted node
                if (n.type === 'compound' && n.config?.requires) {
                    n.config.requires = n.config.requires.filter(req => {
                        if (typeof req === 'string') return req !== nodeId;
                        if (typeof req === 'object') {
                            const reqId = req.item || req.modifier || req.trait || req.attribute || req.variable || req.id;
                            return reqId !== nodeId;
                        }
                        return true;
                    });
                }
            }

            // Remove relationships
            config.relationships = config.relationships.filter(r =>
                r.sourceId !== nodeId && r.targetId !== nodeId
            );

            // Clear selection if we deleted the selected node
            if (selectedNodeId === nodeId) {
                selectedNodeId = null;
            }

            engine.loadConfig(config);
            saveToStorage();
            render();

            // Auto-equalize layer weights if trait was deleted from a layer with auto-equalize enabled
            if (wasTraitInLayer) {
                autoEqualizeLayerIfEnabled(wasTraitInLayer);
            }

            showToast(`Deleted "${node.name}"`, 'success');
        }

        function duplicateNode() {
            if (typeof TIER_LIMITS !== 'undefined') {
                const check = checkNodeLimit();
                if (!check.allowed) {
                    showToast(check.reason, 'warning', TIER_TOAST_DURATION);
                    return;
                }
            }
            if (!selectedNodeId) return;

            const original = config.nodes.find(n => n.id === selectedNodeId);
            if (!original) return;

            // Generate new unique ID
            const baseId = original.id.replace(/_copy\d*$/, ''); // Remove existing _copy suffix
            let newId = `${baseId}_copy`;
            let counter = 1;
            while (config.nodes.some(n => n.id === newId)) {
                newId = `${baseId}_copy${counter++}`;
            }

            // Deep clone the node
            const newNode = JSON.parse(JSON.stringify(original));
            newNode.id = newId;
            newNode.name = `${original.name} (Copy)`;

            // Clear position so it gets auto-placed in graph view
            delete newNode.position;

            // Add to config
            config.nodes.push(newNode);

            // If it's a trait/item, add to parent layer's itemIds
            if ((newNode.type === 'item' || newNode.type === 'trait') && newNode.config.layerId) {
                const layer = config.nodes.find(n => n.id === newNode.config.layerId);
                if (layer) {
                    // Support both traitIds and itemIds for backward compatibility
                    if (layer.config.traitIds) {
                        layer.config.traitIds.push(newId);
                    }
                    if (layer.config.itemIds) {
                        layer.config.itemIds.push(newId);
                    }
                    // If neither exists, create itemIds
                    if (!layer.config.traitIds && !layer.config.itemIds) {
                        layer.config.itemIds = [newId];
                    }
                }
            }

            // Select the new node
            selectedNodeId = newId;

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function deleteRelationship(relId) {
            config.relationships = config.relationships.filter(r => r.id !== relId);
            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function deleteRelationshipFromGraph(relId) {
            // Find the relationship to show details
            const rel = config.relationships.find(r => r.id === relId);
            if (!rel) return;

            const source = config.nodes.find(n => n.id === rel.sourceId);
            const target = config.nodes.find(n => n.id === rel.targetId);
            const sourceName = source?.name || rel.sourceId;
            const targetName = target?.name || rel.targetId;

            if (confirm(`Delete relationship from "${sourceName}" to "${targetName}"?`)) {
                deleteRelationship(relId);
            }
        }

        // ========================================
        // INCOMPATIBILITY MANAGEMENT (Bidirectional)
        // ========================================

        function addIncompatibility(nodeId, targetNodeId) {
            if (!nodeId || !targetNodeId || nodeId === targetNodeId) return;

            const node = config.nodes.find(n => n.id === nodeId);
            const targetNode = config.nodes.find(n => n.id === targetNodeId);
            if (!node || !targetNode) return;

            // Add to source node
            if (!node.config.incompatibleWith) node.config.incompatibleWith = [];
            if (!node.config.incompatibleWith.includes(targetNodeId)) {
                node.config.incompatibleWith.push(targetNodeId);
            }

            // Add to target node (bidirectional sync)
            if (!targetNode.config.incompatibleWith) targetNode.config.incompatibleWith = [];
            if (!targetNode.config.incompatibleWith.includes(nodeId)) {
                targetNode.config.incompatibleWith.push(nodeId);
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function removeIncompatibility(nodeId, targetNodeId) {
            const node = config.nodes.find(n => n.id === nodeId);
            const targetNode = config.nodes.find(n => n.id === targetNodeId);

            // Remove from source node
            if (node?.config?.incompatibleWith) {
                node.config.incompatibleWith = node.config.incompatibleWith.filter(id => id !== targetNodeId);
            }

            // Remove from target node (bidirectional sync)
            if (targetNode?.config?.incompatibleWith) {
                targetNode.config.incompatibleWith = targetNode.config.incompatibleWith.filter(id => id !== nodeId);
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        function addIncompatFromDropdown(nodeId) {
            const select = document.getElementById(`incompatAdd_${nodeId}`);
            if (!select || !select.value) return;
            addIncompatibility(nodeId, select.value);
        }

        // Quick influence helper for soft weight influence
        function addQuickInfluence(sourceId, value) {
            const select = document.getElementById(`influenceTarget_${sourceId}`);
            if (!select || !select.value) {
                alert('Please select a target trait first');
                return;
            }

            const targetId = select.value;

            // Check if relationship already exists
            const existing = config.relationships.find(r =>
                r.sourceId === sourceId &&
                r.targetId === targetId &&
                r.type === 'weight_influence'
            );

            if (existing) {
                // Update existing value
                existing.config.value = (existing.config.value || 0) + value;
                if (existing.config.value === 0) {
                    // Remove if zeroed out
                    config.relationships = config.relationships.filter(r => r.id !== existing.id);
                }
            } else {
                // Create new relationship
                const relationship = {
                    id: `rel_${sourceId}_${targetId}_${Date.now()}`,
                    sourceId,
                    targetId,
                    type: 'weight_influence',
                    config: {
                        operation: 'add',
                        value: value
                    }
                };
                config.relationships.push(relationship);
            }

            engine.loadConfig(config);
            saveToStorage();
            render();
        }

        // ========================================
        // GRAPH UTILITIES
        // ========================================
        // getNodeColor is now provided by js/utils.js

        function autoLayoutNodes(width, height, offsetX = 0, offsetY = 0) {
            // Semi-circular layout: columns arranged in an arc opening upward
            // Connections can pass through the empty space above the arc
            const padding = 60;
            const usableWidth = width - padding * 2;
            const usableHeight = height - padding * 2;

            // Group nodes by type
            const typeGroups = {};
            for (const node of config.nodes) {
                const type = node.type;
                if (!typeGroups[type]) typeGroups[type] = [];
                typeGroups[type].push(node);
            }

            // Combine traits and items
            const allTraits = [...(typeGroups['trait'] || []), ...(typeGroups['item'] || [])];

            // Group traits by their parent layer
            const traitsByLayer = {};
            const orphanTraits = [];
            allTraits.forEach(node => {
                const layerId = node.config?.layerId;
                if (layerId) {
                    if (!traitsByLayer[layerId]) traitsByLayer[layerId] = [];
                    traitsByLayer[layerId].push(node);
                } else {
                    orphanTraits.push(node);
                }
            });

            // Get layers in order
            const layers = (typeGroups['layer'] || [])
                .sort((a, b) => (a.config?.order || 0) - (b.config?.order || 0));

            // Build column structure:
            // [attributes] [variables] [layer1+traits] [layer2+traits] ... [modifiers] [compounds] [derived]
            const columns = [];

            // Add attribute column
            if (typeGroups['attribute']?.length > 0) {
                columns.push({ type: 'attribute', nodes: typeGroups['attribute'], header: null });
            }

            // Add variable column
            if (typeGroups['variable']?.length > 0) {
                columns.push({ type: 'variable', nodes: typeGroups['variable'], header: null });
            }

            // Add a column for each layer with its traits (including empty layers)
            layers.forEach(layer => {
                const layerTraits = traitsByLayer[layer.id] || [];
                columns.push({ type: 'layer-group', nodes: layerTraits, header: layer });
            });

            // Add orphan traits if any
            if (orphanTraits.length > 0) {
                columns.push({ type: 'trait', nodes: orphanTraits, header: null });
            }

            // Add modifier column
            if (typeGroups['modifier']?.length > 0) {
                columns.push({ type: 'modifier', nodes: typeGroups['modifier'], header: null });
            }

            // Add compound column
            if (typeGroups['compound']?.length > 0) {
                columns.push({ type: 'compound', nodes: typeGroups['compound'], header: null });
            }

            // Add derived column
            if (typeGroups['derived']?.length > 0) {
                columns.push({ type: 'derived', nodes: typeGroups['derived'], header: null });
            }

            // Add action column
            if (typeGroups['action']?.length > 0) {
                columns.push({ type: 'action', nodes: typeGroups['action'], header: null });
            }

            // Add tick system column
            if (typeGroups['ticksystem']?.length > 0) {
                columns.push({ type: 'ticksystem', nodes: typeGroups['ticksystem'], header: null });
            }

            const colCount = columns.length;
            if (colCount === 0) return;

            // Semi-circular arc parameters
            // Arc center is near the top, arc curves downward (opens upward for connections)
            const arcCenterX = offsetX + width / 2;
            const arcCenterY = offsetY + padding;

            // Radius based on available space - use smaller dimension to ensure fit
            const radius = Math.min(usableWidth * 0.45, usableHeight * 0.5);

            // Node stacking parameters
            const MIN_NODE_SPACING = 45;
            const MAX_NODE_SPACING = 80;
            const headerGap = 35;

            columns.forEach((col, colIndex) => {
                // Calculate position along the arc
                // t goes from 0 (left) to 1 (right)
                const t = colCount > 1 ? colIndex / (colCount - 1) : 0.5;

                // Angle: Ï€ (left, 180Â°) to 0 (right, 0Â°)
                // This creates an arc that curves downward
                const angle = Math.PI * (1 - t);

                // Position on the arc
                const arcX = arcCenterX + radius * Math.cos(angle);
                const arcY = arcCenterY + radius * Math.sin(angle);

                // Calculate how much vertical space we have below this arc point
                const spaceBelow = (offsetY + height - padding) - arcY;

                if (col.header) {
                    // Layer-group column: layer header at arc, traits below
                    const availableHeight = Math.max(100, spaceBelow - headerGap);
                    const rawRowHeight = availableHeight / (col.nodes.length + 0.5);
                    const rowHeight = Math.max(MIN_NODE_SPACING, Math.min(MAX_NODE_SPACING, rawRowHeight));

                    // Position layer header at the arc point
                    col.header.position = {
                        x: arcX,
                        y: arcY
                    };

                    // Stack traits vertically below the header
                    col.nodes.forEach((node, idx) => {
                        node.position = {
                            x: arcX,
                            y: arcY + headerGap + rowHeight * idx
                        };
                    });
                } else {
                    // Standard column: stack nodes below arc point
                    const availableHeight = Math.max(100, spaceBelow);
                    const rawRowHeight = availableHeight / (col.nodes.length + 0.5);
                    const rowHeight = Math.max(MIN_NODE_SPACING, Math.min(MAX_NODE_SPACING, rawRowHeight));

                    col.nodes.forEach((node, idx) => {
                        node.position = {
                            x: arcX,
                            y: arcY + rowHeight * idx
                        };
                    });
                }
            });

            // Empty layers are now included in columns above, so they get proper arc positions
        }

        // Drag-to-connect state
        let dragToConnect = {
            active: false,
            sourceNodeId: null,
            sourceNodeEl: null,
            tempLine: null,
            justCompleted: false // Flag to prevent click handling immediately after drag completion
        };

        // Handle graph node clicks - don't select if we just completed a drag
        function handleGraphNodeClick(nodeId, event) {
            // If we're in the middle of a drag or just completed one, don't select
            if (dragToConnect.active || dragToConnect.justCompleted) {
                event.stopPropagation();
                dragToConnect.justCompleted = false;
                return;
            }
            selectNode(nodeId);
        }

        // Convert screen coordinates to SVG viewBox coordinates
        function screenToSvgCoords(svg, screenX, screenY) {
            const rect = svg.getBoundingClientRect();
            // Get current viewBox values
            const viewBox = svg.viewBox.baseVal;
            // Calculate the scale from screen to viewBox
            const scaleX = viewBox.width / rect.width;
            const scaleY = viewBox.height / rect.height;
            // Convert screen coords to SVG coords
            return {
                x: viewBox.x + (screenX - rect.left) * scaleX,
                y: viewBox.y + (screenY - rect.top) * scaleY
            };
        }

        function setupGraphDrag() {
            // Setup graph interactions (hover highlighting + drag-to-connect + pan)
            const svg = document.querySelector('.graph-svg');
            if (!svg) return;

            const container = document.getElementById('graphViewContainer');
            if (container) {
                // Ctrl+scroll wheel zoom (zoom toward mouse position)
                container.addEventListener('wheel', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        const rect = container.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        const delta = e.deltaY < 0 ? 0.1 : -0.1;
                        setGraphZoom(graphZoom + delta, mouseX, mouseY);
                    } else {
                        // Regular scroll = pan
                        e.preventDefault();
                        const panSpeed = 0.5 / graphZoom;  // Slower pan when zoomed in
                        graphPan.x += e.deltaX * panSpeed;
                        graphPan.y += e.deltaY * panSpeed;
                        updateGraphViewBox();
                    }
                }, { passive: false });
            }

            // Pan-drag: start on mousedown on empty space (left-click) or middle-click anywhere
            svg.addEventListener('mousedown', (e) => {
                const isMiddle = e.button === 1;
                const isLeftOnEmpty = e.button === 0 && !e.target.closest('.graph-node');
                if (isMiddle || isLeftOnEmpty) {
                    if (isMiddle) e.preventDefault();
                    graphPanDrag = { active: true, startX: e.clientX, startY: e.clientY };
                    svg.classList.add('panning');
                }
            });

            // Clear highlights when mouse leaves the SVG
            // BUT don't cancel drag-to-connect â€” cursor may be over a sibling panel
            svg.addEventListener('mouseleave', () => {
                clearGraphHighlights();
                // Don't cancel dragToConnect here â€” document-level handlers manage it
                if (graphPanDrag.active) {
                    graphPanDrag.active = false;
                    svg.classList.remove('panning');
                }
            });

            // Track mouse movement for pan-drag (SVG-level)
            svg.addEventListener('mousemove', (e) => {
                // Pan-drag
                if (graphPanDrag.active) {
                    const dx = e.clientX - graphPanDrag.startX;
                    const dy = e.clientY - graphPanDrag.startY;
                    graphPanDrag.startX = e.clientX;
                    graphPanDrag.startY = e.clientY;
                    // Convert screen pixels to viewBox units
                    const viewWidth = graphBaseSize.width / graphZoom;
                    const viewHeight = graphBaseSize.height / graphZoom;
                    const containerEl = document.getElementById('graphViewContainer');
                    if (containerEl) {
                        graphPan.x -= dx * (viewWidth / containerEl.clientWidth);
                        graphPan.y -= dy * (viewHeight / containerEl.clientHeight);
                        updateGraphViewBox();
                    }
                    return;
                }
                // Drag-to-connect line (also handled at document level for cross-panel dragging)
                if (dragToConnect.active && dragToConnect.tempLine) {
                    const coords = screenToSvgCoords(svg, e.clientX, e.clientY);
                    dragToConnect.tempLine.setAttribute('x2', coords.x);
                    dragToConnect.tempLine.setAttribute('y2', coords.y);
                }
            });

            // Cancel drag on mouseup anywhere on SVG (missed a node) + stop pan-drag
            svg.addEventListener('mouseup', (e) => {
                if (graphPanDrag.active) {
                    graphPanDrag.active = false;
                    svg.classList.remove('panning');
                }
                if (dragToConnect.active) {
                    // Check if we're on a node
                    const targetNode = e.target.closest('.graph-node');
                    if (!targetNode) {
                        cancelDragToConnect();
                    }
                }
            });

            // Document-level drag-to-connect tracking â€” cursor can pass over sibling panels
            document.addEventListener('mousemove', (e) => {
                if (!dragToConnect.active || !dragToConnect.tempLine) return;
                const coords = screenToSvgCoords(svg, e.clientX, e.clientY);
                dragToConnect.tempLine.setAttribute('x2', coords.x);
                dragToConnect.tempLine.setAttribute('y2', coords.y);
            });

            // Document-level mouseup â€” cancel drag if released outside a graph node
            document.addEventListener('mouseup', (e) => {
                if (graphPanDrag.active) {
                    graphPanDrag.active = false;
                    const svgEl = document.querySelector('.graph-svg');
                    if (svgEl) svgEl.classList.remove('panning');
                }
                if (dragToConnect.active) {
                    // Only keep drag alive if mouseup is on a graph node (handled by node's own mouseup)
                    const targetNode = e.target.closest('.graph-node');
                    if (!targetNode) {
                        cancelDragToConnect();
                    }
                }
            });

            // Setup hover highlighting for nodes and edges
            setupGraphHoverHighlighting(svg);

            // Setup drag-to-connect for nodes
            setupDragToConnect(svg);
        }

        function setupDragToConnect(svg) {
            const nodes = svg.querySelectorAll('.graph-node');

            nodes.forEach(nodeEl => {
                // Start drag on mousedown
                nodeEl.addEventListener('mousedown', (e) => {
                    // Only left mouse button
                    if (e.button !== 0) return;

                    // Prevent text selection
                    e.preventDefault();

                    const nodeId = nodeEl.dataset.id;
                    // Find the node's position from config (more reliable than screen coords)
                    const node = config.nodes.find(n => n.id === nodeId);
                    if (!node || !node.position) return;

                    // Use the node's stored position
                    const x = node.position.x;
                    const y = node.position.y;

                    // Create temporary drag line
                    const tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tempLine.setAttribute('x1', x);
                    tempLine.setAttribute('y1', y);
                    tempLine.setAttribute('x2', x);
                    tempLine.setAttribute('y2', y);
                    tempLine.setAttribute('stroke', 'var(--accent-primary)');
                    tempLine.setAttribute('stroke-width', '2');
                    tempLine.setAttribute('stroke-dasharray', '5,5');
                    tempLine.setAttribute('class', 'drag-temp-line');
                    tempLine.style.pointerEvents = 'none';

                    svg.appendChild(tempLine);

                    dragToConnect.active = true;
                    dragToConnect.sourceNodeId = nodeId;
                    dragToConnect.sourceNodeEl = nodeEl;
                    dragToConnect.tempLine = tempLine;

                    // Add dragging visual feedback
                    nodeEl.classList.add('dragging-source');
                    document.getElementById('graphViewContainer')?.classList.add('drag-connect-active');
                });

                // Complete drag on mouseup on a different node
                nodeEl.addEventListener('mouseup', (e) => {
                    if (!dragToConnect.active) return;

                    const targetNodeId = nodeEl.dataset.id;

                    // Can't connect to self
                    if (targetNodeId === dragToConnect.sourceNodeId) {
                        cancelDragToConnect();
                        return;
                    }

                    // Open relationship modal with source and target pre-filled
                    completeDragToConnect(dragToConnect.sourceNodeId, targetNodeId);
                });

                // Highlight potential drop target
                nodeEl.addEventListener('mouseenter', () => {
                    if (dragToConnect.active && nodeEl.dataset.id !== dragToConnect.sourceNodeId) {
                        nodeEl.classList.add('drop-target');
                    }
                });

                nodeEl.addEventListener('mouseleave', () => {
                    nodeEl.classList.remove('drop-target');
                });
            });
        }

        function completeDragToConnect(sourceId, targetId) {
            // Set flag to prevent click handler from firing
            dragToConnect.justCompleted = true;
            setTimeout(() => { dragToConnect.justCompleted = false; }, 100);

            // Clean up drag state
            cancelDragToConnect();

            const sourceNode = config.nodes.find(n => n.id === sourceId);
            const targetNode = config.nodes.find(n => n.id === targetId);
            if (!sourceNode || !targetNode) return;

            // Find a relationship type valid for both source and target
            const validSourceTypes = getValidRelTypesForSource(sourceNode.type);
            const validRelType = validSourceTypes.find(rt => {
                const validTargets = getValidTargetTypesForRel(rt);
                return validTargets.includes(targetNode.type);
            });

            if (!validRelType) {
                showToast(`No valid relationship type from ${sourceNode.type} to ${targetNode.type}`, 'error');
                return;
            }

            // Select the source node first
            selectNode(sourceId);

            // Open the relationship modal after a brief delay
            setTimeout(() => {
                showAddRelationshipModal();

                // Set the relationship type that works for this sourceâ†’target
                setTimeout(() => {
                    const relTypeSelect = document.getElementById('newRelType');
                    const targetSelect = document.getElementById('newRelTarget');

                    if (relTypeSelect && validRelType) {
                        relTypeSelect.value = validRelType;
                        updateRelTypeHelp(); // This repopulates targets
                    }

                    // Now set the target
                    setTimeout(() => {
                        if (targetSelect) {
                            targetSelect.value = targetId;
                            updateRelPreview();
                        }
                    }, 50);
                }, 100);
            }, 50);
        }

        function cancelDragToConnect() {
            if (dragToConnect.tempLine) {
                dragToConnect.tempLine.remove();
            }
            if (dragToConnect.sourceNodeEl) {
                dragToConnect.sourceNodeEl.classList.remove('dragging-source');
            }
            document.querySelectorAll('.graph-node.drop-target').forEach(el => {
                el.classList.remove('drop-target');
            });
            document.getElementById('graphViewContainer')?.classList.remove('drag-connect-active');
            dragToConnect.active = false;
            dragToConnect.sourceNodeId = null;
            dragToConnect.sourceNodeEl = null;
            dragToConnect.tempLine = null;
            // Note: don't reset justCompleted here - it's managed separately
        }

        // Hover debounce state for graph
        let graphHoverTimeout = null;
        let graphClearTimeout = null;
        let currentHoveredElement = null; // Track what's currently being hovered
        const GRAPH_HOVER_DELAY = 150; // ms delay before showing highlights

        function setupGraphHoverHighlighting(svg) {
            const nodes = svg.querySelectorAll('.graph-node');
            const edgeGroups = svg.querySelectorAll('.graph-edge-group');

            nodes.forEach(nodeEl => {
                nodeEl.addEventListener('mouseenter', () => {
                    // Cancel any pending operations
                    if (graphClearTimeout) {
                        clearTimeout(graphClearTimeout);
                        graphClearTimeout = null;
                    }
                    if (graphHoverTimeout) clearTimeout(graphHoverTimeout);

                    // If switching to a different element, clear old highlights immediately
                    if (currentHoveredElement && currentHoveredElement !== nodeEl) {
                        clearGraphHighlights();
                    }
                    currentHoveredElement = nodeEl;

                    // Debounce the new highlight
                    graphHoverTimeout = setTimeout(() => {
                        const nodeId = nodeEl.dataset.id;
                        highlightNodeConnections(nodeId);
                    }, GRAPH_HOVER_DELAY);
                });

                nodeEl.addEventListener('mouseleave', () => {
                    // Cancel pending highlight
                    if (graphHoverTimeout) {
                        clearTimeout(graphHoverTimeout);
                        graphHoverTimeout = null;
                    }
                    // Debounce the clear (gives time to move to another element)
                    graphClearTimeout = setTimeout(() => {
                        if (currentHoveredElement === nodeEl) {
                            currentHoveredElement = null;
                            clearGraphHighlights();
                        }
                    }, GRAPH_HOVER_DELAY);
                });
            });

            // Highlight when hovering edge groups (includes hitarea)
            edgeGroups.forEach(group => {
                group.addEventListener('mouseenter', () => {
                    // Cancel any pending operations
                    if (graphClearTimeout) {
                        clearTimeout(graphClearTimeout);
                        graphClearTimeout = null;
                    }
                    if (graphHoverTimeout) clearTimeout(graphHoverTimeout);

                    // If switching to a different element, clear old highlights immediately
                    if (currentHoveredElement && currentHoveredElement !== group) {
                        clearGraphHighlights();
                    }
                    currentHoveredElement = group;

                    // Debounce the new highlight
                    graphHoverTimeout = setTimeout(() => {
                        const edge = group.querySelector('.graph-edge');
                        const sourceId = edge.dataset.source;
                        const targetId = edge.dataset.target;
                        highlightEdgeAndNodes(edge, sourceId, targetId);
                    }, GRAPH_HOVER_DELAY);
                });

                group.addEventListener('mouseleave', () => {
                    // Cancel pending highlight
                    if (graphHoverTimeout) {
                        clearTimeout(graphHoverTimeout);
                        graphHoverTimeout = null;
                    }
                    // Debounce the clear
                    graphClearTimeout = setTimeout(() => {
                        if (currentHoveredElement === group) {
                            currentHoveredElement = null;
                            clearGraphHighlights();
                        }
                    }, GRAPH_HOVER_DELAY);
                });
            });
        }

        function highlightNodeConnections(nodeId) {
            const svg = document.querySelector('.graph-svg');
            if (!svg) return;

            const allNodes = svg.querySelectorAll('.graph-node');
            const allEdges = svg.querySelectorAll('.graph-edge');
            const allIncompatGroups = svg.querySelectorAll('.graph-incompat-group');

            // Find all edges connected to this node
            const connectedNodeIds = new Set([nodeId]);
            const connectedEdges = [];
            const connectedIncompatGroups = [];

            allEdges.forEach(edge => {
                const source = edge.dataset.source;
                const target = edge.dataset.target;
                if (source === nodeId || target === nodeId) {
                    connectedEdges.push(edge);
                    connectedNodeIds.add(source);
                    connectedNodeIds.add(target);
                }
            });

            // Find incompatibility connections
            const node = config.nodes.find(n => n.id === nodeId);
            const incompatibles = node?.config?.incompatibleWith || [];
            incompatibles.forEach(incompId => {
                connectedNodeIds.add(incompId);
            });

            // Check incompatibility edge groups
            allIncompatGroups.forEach(group => {
                const pairData = group.dataset.incompat;
                if (pairData) {
                    const [id1, id2] = pairData.split('|');
                    if (id1 === nodeId || id2 === nodeId) {
                        connectedIncompatGroups.push(group);
                    }
                }
            });

            // For compound nodes, also highlight required nodes
            if (node?.type === 'compound' && node.config?.requires) {
                node.config.requires.forEach(reqId => {
                    connectedNodeIds.add(reqId);
                });
            }

            // Also check if this node is required by any compounds
            config.nodes.forEach(n => {
                if (n.type === 'compound' && n.config?.requires?.includes(nodeId)) {
                    connectedNodeIds.add(n.id);
                }
            });

            // Create set of incompatible node IDs for red highlighting
            const incompatibleNodeIds = new Set(incompatibles);

            // Dim all nodes and edges first
            allNodes.forEach(nodeEl => {
                const elId = nodeEl.dataset.id;
                if (!connectedNodeIds.has(elId)) {
                    nodeEl.classList.add('dimmed');
                } else if (elId !== nodeId) {
                    // Use red highlight for incompatible nodes, normal for others
                    if (incompatibleNodeIds.has(elId)) {
                        nodeEl.classList.add('incompat-highlight');
                    } else {
                        nodeEl.classList.add('highlight');
                    }
                }
            });

            allEdges.forEach(edge => {
                if (!connectedEdges.includes(edge)) {
                    edge.classList.add('dimmed');
                } else {
                    edge.classList.add('highlight');
                }
            });

            // Handle incompatibility group highlighting
            allIncompatGroups.forEach(group => {
                if (connectedIncompatGroups.includes(group)) {
                    group.classList.add('highlight');
                } else {
                    group.classList.add('dimmed');
                }
            });

            // Update context window
            updateGraphContextWindow(nodeId);
        }

        function highlightEdgeAndNodes(edgeEl, sourceId, targetId) {
            const svg = document.querySelector('.graph-svg');
            if (!svg) return;

            const allNodes = svg.querySelectorAll('.graph-node');
            const allEdges = svg.querySelectorAll('.graph-edge');

            // Dim everything except the hovered edge and its nodes
            allNodes.forEach(node => {
                const id = node.dataset.id;
                if (id === sourceId || id === targetId) {
                    node.classList.add('highlight');
                } else {
                    node.classList.add('dimmed');
                }
            });

            allEdges.forEach(edge => {
                if (edge === edgeEl) {
                    edge.classList.add('highlight');
                } else {
                    edge.classList.add('dimmed');
                }
            });

            // Update context window to show the relationship
            updateGraphContextForEdge(sourceId, targetId, edgeEl.dataset.relId);
        }

        function updateGraphContextForEdge(sourceId, targetId, relId) {
            const body = document.getElementById('graphContextBody');
            if (!body) return;

            const source = config.nodes.find(n => n.id === sourceId);
            const target = config.nodes.find(n => n.id === targetId);
            const rel = config.relationships.find(r => r.id === relId);

            if (!source || !target || !rel) return;

            const typeClass = rel.type === 'rate_modifier' ? 'rate' : (rel.type === 'weight_influence' ? 'weight' : (rel.type === 'duration_binding' ? 'duration' : 'value'));
            const opSymbol = rel.config?.operation === 'multiply' ? 'Ã—' : (rel.config?.value >= 0 ? '+' : '');

            body.innerHTML = `
                <div class="graph-context-node">
                    <div class="graph-context-node-name">${source.name} â†’ ${target.name}</div>
                    <div class="graph-context-node-type">Relationship</div>
                    <div class="graph-context-rel" style="margin-top: 0.5rem;">
                        <span class="graph-context-rel-type ${typeClass}">${rel.type.replace(/_/g, ' ')}</span>
                    </div>
                    <div style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">
                        <strong>Operation:</strong> ${rel.config?.operation || 'add'}<br>
                        <strong>Value:</strong> ${opSymbol}${rel.config?.value || 0}
                        ${rel.config?.scaling ? `<br><strong>Scaling:</strong> ${rel.config.scaling}` : ''}
                        ${rel.config?.perPointSource ? `<br><strong>Per point of:</strong> ${config.nodes.find(n => n.id === rel.config.perPointSource)?.name || rel.config.perPointSource}` : ''}
                    </div>
                </div>
            `;
        }

        function clearGraphHighlights() {
            const svg = document.querySelector('.graph-svg');
            if (!svg) return;

            svg.querySelectorAll('.graph-node').forEach(node => {
                node.classList.remove('dimmed', 'highlight', 'incompat-highlight');
            });

            svg.querySelectorAll('.graph-edge').forEach(edge => {
                edge.classList.remove('dimmed', 'highlight');
            });

            svg.querySelectorAll('.graph-incompat-group').forEach(group => {
                group.classList.remove('dimmed', 'highlight');
            });

            // Clear context window
            updateGraphContextWindow(null);
        }

        // ========================================
        // IMPORT / EXPORT
        // ========================================
        function importConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            config = JSON.parse(e.target.result);
                            engine.loadConfig(config);
                            // Use normalized config from engine for consistency
                            config = engine.spawnManager.config;
                            saveToStorage();
                            selectedNodeId = null;
                            render();
                            // Auto-equalize weights for layers that have the setting enabled (default: on)
                            autoEqualizeAllLayers();
                        } catch (err) {
                            alert('Failed to parse config file');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function exportConfig() {
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${config.id}.json`;
            a.click();
            URL.revokeObjectURL(url);
            // Mark as exported - no need to warn on page leave
            configExportedSinceChange = true;
        }

        // ========================================
        // CSV IMPORT
        // ========================================
        const CSV_HELP = {
            attributes: 'id, name, description, min, max, default_min, default_max, precision',
            variables: 'id, name, description, min, max, initial, base_rate, change_mode, direction',
            layers: 'id, name, description, order, selection_mode, max_items, initial_rolls, roll_at',
            traits: 'id, name, description, layer, base_weight',
            relationships: 'id, source, target, type, operation, value, scaling, per_point_source',
            presetGroups: 'id, name, description',
            presets: 'id, name, description, group, tags (;separated), forceTraits (;separated), attr_* (attribute overrides)'
        };

        const CSV_TEMPLATES = {
            attributes: `id,name,description,min,max,default_min,default_max,precision
attr_strength,Strength,Physical power,1,20,5,15,0
attr_speed,Speed,Quickness,1,20,3,12,0
attr_intelligence,Intelligence,Cunning,1,20,1,10,0`,

            variables: `id,name,description,min,max,initial,base_rate,change_mode,direction
var_health,Health,Hit points,0,100,100,0,manual,none
var_hunger,Hunger,Hunger level,0,100,0,-5,timed,deplete
var_rage,Rage,Anger buildup,0,100,0,0,manual,none`,

            layers: `id,name,description,order,selection_mode,max_items,initial_rolls,roll_at
layer_species,Species,Type of creature,1,weighted,1,1,spawn
layer_behavior,Behavior,How it acts,2,weighted,1,1,spawn
layer_status,Status,Current state,3,weighted,3,0,never`,

            traits: `id,name,description,layer,base_weight
trait_goblin,Goblin,Small and quick,layer_species,30
trait_orc,Orc,Strong and aggressive,layer_species,25
trait_aggressive,Aggressive,Attacks first,layer_behavior,25
trait_defensive,Defensive,Waits and counters,layer_behavior,20`,

            relationships: `id,source,target,type,operation,value,scaling,per_point_source
rel_str_orc,attr_strength,trait_orc,weight_influence,add,2,perPoint,attr_strength
rel_goblin_coward,trait_goblin,trait_defensive,weight_influence,add,20,flat,`,

            presetGroups: `id,name,description
monsters,Monsters,Enemy creature templates
allies,Allies,Friendly NPC templates
bosses,Bosses,Boss encounter templates`,

            presets: `id,name,description,group,tags,forceTraits,attr_strength,attr_speed
preset_goblin_scout,Goblin Scout,Fast goblin,monsters,enemy;goblin,trait_goblin;trait_aggressive,8,15
preset_orc_warrior,Orc Warrior,Strong orc,monsters,enemy;orc,trait_orc;trait_aggressive,16,8`
        };

        function showCSVImportModal() {
            document.getElementById('csvImportData').value = '';
            updateCSVHelp();
            document.getElementById('csvImportModal').classList.add('active');
        }

        function updateCSVHelp() {
            const type = document.getElementById('csvImportType').value;
            document.getElementById('csvHelpText').innerHTML =
                `<strong>Expected columns:</strong> ${CSV_HELP[type]}`;
        }

        function downloadCSVTemplate() {
            const type = document.getElementById('csvImportType').value;
            const template = CSV_TEMPLATES[type];
            const blob = new Blob([template], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${type}_template.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function importCSVData() {
            if (typeof TIER_LIMITS !== 'undefined') {
                const check = checkNodeLimit();
                if (!check.allowed) {
                    showToast(check.reason, 'warning', TIER_TOAST_DURATION);
                    return;
                }
            }
            const type = document.getElementById('csvImportType').value;
            const csvData = document.getElementById('csvImportData').value.trim();

            if (!csvData) {
                alert('Please paste CSV data first');
                return;
            }

            try {
                let imported;
                switch (type) {
                    case 'attributes':
                        imported = CSVImporter.importAttributes(csvData, config);
                        break;
                    case 'variables':
                        imported = CSVImporter.importVariables(csvData, config);
                        break;
                    case 'layers':
                        imported = CSVImporter.importLayers(csvData, config);
                        break;
                    case 'traits':
                        imported = CSVImporter.importTraits(csvData, config);
                        break;
                    case 'relationships':
                        imported = CSVImporter.importRelationships(csvData, config);
                        break;
                    case 'presets':
                        imported = importPresetsToConfig(csvData);
                        break;
                    case 'presetGroups':
                        imported = importPresetGroupsToConfig(csvData);
                        break;
                }

                engine.loadConfig(config);
                render();
                closeModal('csvImportModal');

                const count = Array.isArray(imported) ? imported.length : 0;
                alert(`Successfully imported ${count} ${type}!`);
            } catch (e) {
                alert('Import failed: ' + e.message);
                console.error('CSV Import error:', e);
            }
        }

        function importPresetsToConfig(csvData) {
            const rows = CSVImporter.parseCSV(csvData);
            if (!config.presets) config.presets = [];

            const imported = [];
            for (const row of rows) {
                if (!row.id) continue;

                // Check for duplicate
                const existingIdx = config.presets.findIndex(p => p.id === row.id);

                const preset = {
                    id: row.id,
                    name: row.name || row.id,
                    description: row.description || '',
                    group: row.group || null,
                    tags: row.tags ? row.tags.split(';').map(t => t.trim()).filter(Boolean) : [],
                    forceTraits: row.forceTraits ? row.forceTraits.split(';').map(t => t.trim()).filter(Boolean) : [],
                    attributes: {},
                    contexts: {}
                };

                // Parse attribute overrides from remaining columns
                for (const [key, value] of Object.entries(row)) {
                    if (['id', 'name', 'description', 'group', 'tags', 'forceTraits'].includes(key)) continue;
                    if (key.startsWith('attr_') || config.nodes.find(n => n.type === 'attribute' && n.id === key)) {
                        preset.attributes[key] = parseFloat(value) || 0;
                    } else if (key.startsWith('ctx_') || config.nodes.find(n => n.type === 'context' && n.id === key)) {
                        preset.contexts[key] = value;
                    }
                }

                if (existingIdx >= 0) {
                    config.presets[existingIdx] = preset;
                } else {
                    config.presets.push(preset);
                }
                imported.push(preset);
            }
            return imported;
        }

        function importPresetGroupsToConfig(csvData) {
            const rows = CSVImporter.parseCSV(csvData);
            if (!config.presetGroups) config.presetGroups = [];

            const imported = [];
            for (const row of rows) {
                if (!row.id) continue;

                const existingIdx = config.presetGroups.findIndex(g => g.id === row.id);

                const group = {
                    id: row.id,
                    name: row.name || row.id,
                    description: row.description || ''
                };

                if (existingIdx >= 0) {
                    config.presetGroups[existingIdx] = group;
                } else {
                    config.presetGroups.push(group);
                }
                imported.push(group);
            }
            return imported;
        }

        // ========================================
        // TEST SPAWN
        // ========================================
        function testSpawn() {
            const entity = engine.spawn();
            if (entity) {
                console.log('Spawned entity:', entity);
                alert(`Spawned entity: ${entity.id}\n\nCheck console for details.`);
            } else {
                alert('Failed to spawn entity - check config');
            }
        }

        // Tutorial system now provided by js/tutorial.js

        // ========================================
        // RELATIONSHIP MODAL
        // ========================================

        // Semantic validation for relationship types
        // Returns which relationship types are valid for a given source node type
        function getValidRelTypesForSource(sourceType) {
            // "Active" types can be sources for most relationships (they can be "on/off")
            const activeTypes = ['trait', 'item', 'modifier', 'compound'];

            // All relationship types
            const allRelTypes = [
                'weight_influence',
                'rate_modifier',
                'value_modifier',
                'eligibility_gate',
                'requires',
                'replaces',
                'duration_binding'
            ];

            // Filter based on source type
            if (activeTypes.includes(sourceType)) {
                // Active sources can use most relationship types
                // But 'requires' is only meaningful FROM compound, 'duration_binding' only FROM modifier
                return allRelTypes.filter(rt => {
                    if (rt === 'requires') return sourceType === 'compound'; // Deprecated in favor of compound config, but still valid
                    if (rt === 'duration_binding') return sourceType === 'modifier';
                    return true;
                });
            }

            if (sourceType === 'attribute') {
                // Attributes are always present - they can't be "active" to trigger effects
                // But an attribute value CAN influence trait weights at spawn time
                return ['weight_influence', 'value_modifier'];
            }

            if (sourceType === 'variable') {
                // Variables change over time - their values can influence things
                return ['weight_influence', 'rate_modifier', 'value_modifier'];
            }

            if (sourceType === 'layer') {
                // Layers themselves don't usually create relationships
                return [];
            }

            if (sourceType === 'derived') {
                // Derived values can influence weights
                return ['weight_influence', 'value_modifier'];
            }

            if (sourceType === 'ticksystem') {
                // Tick systems are targets, not sources
                return [];
            }

            if (sourceType === 'context') {
                // Context can gate eligibility and influence weights
                return ['weight_influence', 'eligibility_gate'];
            }

            if (sourceType === 'action') {
                // Actions when active can have effects
                return ['weight_influence', 'rate_modifier', 'value_modifier'];
            }

            return allRelTypes; // Fallback
        }

        // Returns which target node types are valid for a given relationship type
        function getValidTargetTypesForRel(relType) {
            switch (relType) {
                case 'weight_influence':
                    // Only selectable items have weights: traits/items (in layers) and actions
                    return ['trait', 'item', 'action'];

                case 'rate_modifier':
                    // Only variables have rates
                    return ['variable'];

                case 'value_modifier':
                    // Attributes, variables, and derived values have numeric values
                    return ['attribute', 'variable', 'derived'];

                case 'eligibility_gate':
                    // Only selectable items can be gated: traits/items and actions
                    return ['trait', 'item', 'action'];

                case 'requires':
                    // Compounds can require traits, modifiers, attributes (threshold), variables (threshold)
                    return ['trait', 'item', 'modifier', 'attribute', 'variable'];

                case 'replaces':
                    // Replaces works between active states
                    return ['trait', 'item', 'modifier'];

                case 'duration_binding':
                    // Only tick systems can track duration
                    return ['ticksystem'];

                default:
                    return []; // Unknown type
            }
        }

        // Update relationship type dropdown based on source node type
        function updateRelTypeOptionsForSource(sourceType) {
            const relTypeSelect = document.getElementById('newRelType');
            const validTypes = getValidRelTypesForSource(sourceType);

            // Enable/disable options based on validity
            Array.from(relTypeSelect.options).forEach(option => {
                const isValid = validTypes.includes(option.value);
                option.disabled = !isValid;
                option.style.color = isValid ? '' : 'var(--text-muted)';
            });

            // If current selection is invalid, select first valid option
            if (!validTypes.includes(relTypeSelect.value)) {
                const firstValid = validTypes[0];
                if (firstValid) {
                    relTypeSelect.value = firstValid;
                }
            }
        }

        // Track edit mode state for relationships
        let editingRelationshipId = null;

        // Open add connection modal from toolbar (prompts to select node if none selected)
        function openAddConnectionFromToolbar() {
            // Toolbar version: open generic (no pre-selected source) if no node selected
            showAddRelationshipModal({ generic: !selectedNodeId });
        }

        // Handle source node selection in generic connection modal
        function onRelSourceSelected(nodeId) {
            if (!nodeId) return;
            // Temporarily set selectedNodeId for the modal logic
            window._relModalSourceId = nodeId;
            const sourceNode = config.nodes.find(n => n.id === nodeId);
            if (!sourceNode) return;

            // Update type dropdown for this source
            updateRelTypeOptionsForSource(sourceNode.type);
            const relTypeSelect = document.getElementById('newRelType');
            const firstEnabledOption = Array.from(relTypeSelect.options).find(opt => !opt.disabled);
            if (firstEnabledOption) relTypeSelect.value = firstEnabledOption.value;
            updateRelTypeHelp();
            populateRelTargets();
        }

        // Switch from static source display to dropdown (called by "change" button)
        function switchRelSourceToDropdown() {
            const sourceDisplay = document.getElementById('relSourceDisplay');
            const sourceSelect = document.getElementById('relSourceSelect');
            if (!sourceDisplay || !sourceSelect) return;

            // Hide static display, show dropdown
            sourceDisplay.style.display = 'none';
            sourceSelect.style.display = 'block';

            // Populate dropdown with all valid source node types (same as generic mode)
            const validSourceTypes = ['attribute', 'variable', 'trait', 'item', 'modifier', 'compound', 'action', 'derived', 'context'];
            const groupLabels = { attribute: 'Attributes', variable: 'Variables', trait: 'Traits', item: 'Traits', modifier: 'Modifiers', compound: 'Compounds', action: 'Actions', derived: 'Derived', context: 'Context' };
            let srcHtml = '<option value="">-- Select source node --</option>';
            const processedGroups = new Set();
            for (const type of validSourceTypes) {
                const groupKey = (type === 'item') ? 'trait' : type;
                if (processedGroups.has(groupKey)) continue;
                processedGroups.add(groupKey);
                const nodes = groupKey === 'trait'
                    ? config.nodes.filter(n => n.type === 'trait' || n.type === 'item')
                    : config.nodes.filter(n => n.type === type);
                if (nodes.length > 0) {
                    srcHtml += `<optgroup label="${groupLabels[groupKey] || groupKey}">`;
                    nodes.forEach(n => srcHtml += `<option value="${n.id}">${n.name}</option>`);
                    srcHtml += '</optgroup>';
                }
            }
            sourceSelect.innerHTML = srcHtml;

            // Pre-select the current source if one exists
            const currentSource = window._relModalSourceId || selectedNodeId;
            if (currentSource) {
                sourceSelect.value = currentSource;
            }

            sourceSelect.focus();
        }

        // Connection preview line (animated dashed line between source and target during Add Connection)
        function updateConnectionPreviewLine(sourceId, targetId) {
            const edgesGroup = document.getElementById('graphEdges');
            if (!edgesGroup) return; // Graph not visible (e.g., in Tree view)

            let line = edgesGroup.querySelector('.connection-preview-line');

            const sourceNode = sourceId ? config.nodes.find(n => n.id === sourceId) : null;
            const targetNode = targetId ? config.nodes.find(n => n.id === targetId) : null;

            if (!sourceNode?.position) {
                if (line) line.remove();
                return;
            }

            if (!line) {
                line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('class', 'connection-preview-line');
                edgesGroup.appendChild(line);
            }

            line.setAttribute('x1', sourceNode.position.x);
            line.setAttribute('y1', sourceNode.position.y);

            if (targetNode?.position) {
                line.setAttribute('x2', targetNode.position.x);
                line.setAttribute('y2', targetNode.position.y);
                line.style.display = '';
            } else {
                line.style.display = 'none';
            }
        }

        function removeConnectionPreviewLine() {
            const line = document.querySelector('.connection-preview-line');
            if (line) line.remove();
        }

        function showAddRelationshipModal(opts = {}) {
            const isGeneric = opts.generic || false;
            window._relModalSourceId = null;

            if (!isGeneric && !selectedNodeId) {
                alert('Select a node first');
                return;
            }

            // Close add node panel if open
            closeModal('addNodeModal');

            // Reset to add mode
            editingRelationshipId = null;
            document.getElementById('relModalTitle').textContent = 'Add Connection';
            document.getElementById('relSubmitBtn').textContent = 'Add Connection';

            const sourceDisplay = document.getElementById('relSourceDisplay');
            const sourceSelect = document.getElementById('relSourceSelect');

            if (isGeneric) {
                // Generic mode: show source dropdown instead of static display
                sourceDisplay.style.display = 'none';
                sourceSelect.style.display = 'block';

                // Populate source dropdown with all valid source node types
                const validSourceTypes = ['attribute', 'variable', 'trait', 'item', 'modifier', 'compound', 'action', 'derived', 'context'];
                const groupLabels = { attribute: 'Attributes', variable: 'Variables', trait: 'Traits', item: 'Traits', modifier: 'Modifiers', compound: 'Compounds', action: 'Actions', derived: 'Derived', context: 'Context' };
                let srcHtml = '<option value="">-- Select source node --</option>';
                const processedGroups = new Set();
                for (const type of validSourceTypes) {
                    const groupKey = (type === 'item') ? 'trait' : type;
                    if (processedGroups.has(groupKey)) continue;
                    processedGroups.add(groupKey);
                    const nodes = groupKey === 'trait'
                        ? config.nodes.filter(n => n.type === 'trait' || n.type === 'item')
                        : config.nodes.filter(n => n.type === type);
                    if (nodes.length > 0) {
                        srcHtml += `<optgroup label="${groupLabels[groupKey] || groupKey}">`;
                        nodes.forEach(n => srcHtml += `<option value="${n.id}">${n.name}</option>`);
                        srcHtml += '</optgroup>';
                    }
                }
                sourceSelect.innerHTML = srcHtml;

                // Show modal but don't populate targets yet (wait for source selection)
                document.getElementById('newRelOperation').value = 'add';
                document.getElementById('newRelValue').value = '';
                resetRelAdvancedSettings();

                document.getElementById('addRelationshipModal').classList.add('active');
                applyModalLayoutPref('addRelationshipModal');
                return;
            }

            // Normal mode: source is the selected node (shown as dropdown pre-selected)
            const sourceNode = config.nodes.find(n => n.id === selectedNodeId);
            if (!sourceNode) return;

            // Check if this node type can be a relationship source
            const validRelTypes = getValidRelTypesForSource(sourceNode.type);
            if (validRelTypes.length === 0) {
                if (sourceNode.type === 'ticksystem') {
                    // Tick systems are targets â€” redirect to incoming connection picker
                    showAddIncomingConnection(sourceNode.id);
                    return;
                }
                const typeMessages = {
                    layer: 'Layers are containers for traits. To create relationships, select a trait within the layer.'
                };
                alert(typeMessages[sourceNode.type] || `${sourceNode.type} nodes cannot be relationship sources.`);
                return;
            }

            // Always show dropdown, pre-selected to current source
            sourceDisplay.style.display = 'none';
            sourceSelect.style.display = 'block';

            // Populate source dropdown with all valid source nodes
            const validSourceTypes2 = ['attribute', 'variable', 'trait', 'item', 'modifier', 'compound', 'action', 'derived', 'context'];
            const groupLabels2 = { attribute: 'Attributes', variable: 'Variables', trait: 'Traits', item: 'Traits', modifier: 'Modifiers', compound: 'Compounds', action: 'Actions', derived: 'Derived', context: 'Context' };
            let srcHtml2 = '<option value="">-- Select source node --</option>';
            const processedGroups2 = new Set();
            for (const type of validSourceTypes2) {
                const groupKey = (type === 'item') ? 'trait' : type;
                if (processedGroups2.has(groupKey)) continue;
                processedGroups2.add(groupKey);
                const nodes = groupKey === 'trait'
                    ? config.nodes.filter(n => n.type === 'trait' || n.type === 'item')
                    : config.nodes.filter(n => n.type === type);
                if (nodes.length > 0) {
                    srcHtml2 += `<optgroup label="${groupLabels2[groupKey] || groupKey}">`;
                    nodes.forEach(n => srcHtml2 += `<option value="${n.id}">${n.name}</option>`);
                    srcHtml2 += '</optgroup>';
                }
            }
            sourceSelect.innerHTML = srcHtml2;
            sourceSelect.value = selectedNodeId;
            window._relModalSourceId = selectedNodeId;

            // Filter relationship types based on source node type
            updateRelTypeOptionsForSource(sourceNode.type);

            // Reset form - use first valid type for this source
            const relTypeSelect = document.getElementById('newRelType');
            const firstEnabledOption = Array.from(relTypeSelect.options).find(opt => !opt.disabled);
            if (firstEnabledOption) {
                relTypeSelect.value = firstEnabledOption.value;
            }
            document.getElementById('newRelOperation').value = 'add';
            document.getElementById('newRelValue').value = '';

            // Reset advanced settings
            resetRelAdvancedSettings();
            updateRelTypeHelp();

            // Populate target dropdown (now filtered by relationship type)
            populateRelTargets();

            document.getElementById('addRelationshipModal').classList.add('active');
            applyModalLayoutPref('addRelationshipModal');

            // Show animated preview line on graph (add mode only)
            if (!editingRelationshipId) {
                updateConnectionPreviewLine(selectedNodeId, null);
            }
        }

        // Show edit modal for an existing relationship
        function showEditRelationshipModal(relId) {
            const rel = config.relationships.find(r => r.id === relId);
            if (!rel) return;

            editingRelationshipId = relId;
            document.getElementById('relModalTitle').textContent = 'Edit Connection';
            document.getElementById('relSubmitBtn').textContent = 'Save Changes';

            // Set source node info (edit mode uses static display, not dropdown)
            const sourceNode = config.nodes.find(n => n.id === rel.sourceId);
            if (!sourceNode) return;

            document.getElementById('relSourceDisplay').style.display = 'block';
            document.getElementById('relSourceSelect').style.display = 'none';
            window._relModalSourceId = rel.sourceId;

            document.getElementById('relSourceName').textContent = sourceNode.name;
            document.getElementById('relSourceType').textContent = `(${sourceNode.type})`;
            const typeColors = {
                attribute: 'var(--node-attribute)',
                variable: 'var(--node-variable)',
                layer: 'var(--node-layer)',
                trait: 'var(--node-trait)',
                item: 'var(--node-trait)',
                modifier: 'var(--node-modifier)',
                compound: 'var(--node-compound)',
                derived: 'var(--node-derived)',
                ticksystem: 'var(--node-ticksystem)'
            };
            document.getElementById('relSourceDisplay').style.borderLeftColor = typeColors[sourceNode.type] || 'var(--accent-primary)';

            // Populate and set form values
            updateRelTypeOptionsForSource(sourceNode.type);
            document.getElementById('newRelType').value = rel.type;
            updateRelTypeHelp();
            populateRelTargets();
            document.getElementById('newRelTarget').value = rel.targetId;
            document.getElementById('newRelOperation').value = rel.config?.operation || 'add';
            document.getElementById('newRelValue').value = rel.config?.value || 10;

            // Set advanced settings
            resetRelAdvancedSettings();
            if (rel.config?.invert) {
                document.getElementById('newRelInvert').checked = true;
            }
            // Set scaling mode - default to perPoint for attr/var sources, flat otherwise
            const scalingEl = document.getElementById('newRelScaling');
            if (scalingEl) {
                if (rel.config?.scaling) {
                    scalingEl.value = rel.config.scaling;
                } else {
                    // Default based on source type
                    scalingEl.value = (sourceNode.type === 'attribute' || sourceNode.type === 'variable') ? 'perPoint' : 'flat';
                }
                toggleRelScalingSource();
                if (rel.config?.scaling === 'perPoint' && rel.config?.perPointSource) {
                    document.getElementById('newRelScalingSource').value = rel.config.perPointSource;
                }
            }

            updateRelPreview();

            document.getElementById('addRelationshipModal').classList.add('active');
            applyModalLayoutPref('addRelationshipModal');
        }

        // Reset advanced settings to defaults
        function resetRelAdvancedSettings() {
            const invertCheckbox = document.getElementById('newRelInvert');
            const scalingSelect = document.getElementById('newRelScaling');
            const advancedContents = document.getElementById('relAdvancedContents');
            const advancedToggle = document.getElementById('relAdvancedToggle');

            if (invertCheckbox) invertCheckbox.checked = false;
            if (scalingSelect) scalingSelect.value = 'flat';
            if (advancedContents) advancedContents.style.display = 'none';
            if (advancedToggle) advancedToggle.textContent = 'â–¶';

            toggleRelScalingSource();
        }

        // Toggle advanced settings visibility
        function toggleRelAdvanced() {
            const contents = document.getElementById('relAdvancedContents');
            const toggle = document.getElementById('relAdvancedToggle');
            if (contents && toggle) {
                const isHidden = contents.style.display === 'none';
                contents.style.display = isHidden ? 'block' : 'none';
                toggle.textContent = isHidden ? 'â–¼' : 'â–¶';
            }
        }

        // Toggle scaling source dropdown visibility
        function toggleRelScalingSource() {
            const scaling = document.getElementById('newRelScaling')?.value || 'flat';
            const sourceRow = document.getElementById('relScalingSourceRow');
            const sourceSelect = document.getElementById('newRelScalingSource');

            if (sourceRow) {
                sourceRow.style.display = scaling === 'perPoint' ? 'block' : 'none';
            }

            // Populate scaling source with attributes and variables
            if (sourceSelect && scaling === 'perPoint') {
                const sources = config.nodes.filter(n => n.type === 'attribute' || n.type === 'variable');
                sourceSelect.innerHTML = '<option value="">-- Select source --</option>';
                sources.forEach(n => {
                    sourceSelect.innerHTML += `<option value="${n.id}">${n.name} (${n.type})</option>`;
                });
            }
        }

        function updateRelTypeHelp() {
            const type = document.getElementById('newRelType').value;
            const helpEl = document.getElementById('relTypeHelp');
            const valueRow = document.getElementById('relValueRow');

            const helpTexts = {
                weight_influence: `
                    <span class="tutorial-tip-label">Weight Influence</span>
                    <div style="margin-top: 0.5rem;">Changes how likely a trait is to be selected from its layer.</div>
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">
                        <strong>Operations:</strong><br>
                        â€¢ <strong>Add (+/-)</strong>: Add/subtract from base weight. <em>Default: 10-30</em><br>
                        &nbsp;&nbsp;Example: +20 weight makes trait more likely<br>
                        â€¢ <strong>Multiply (Ã—)</strong>: Scale the weight. <em>Default: 1.5 or 0.5</em><br>
                        &nbsp;&nbsp;Example: Ã—2 doubles selection chance, Ã—0.5 halves it<br>
                        â€¢ <strong>Set (=)</strong>: Override to exact weight value
                    </div>
                `,
                rate_modifier: `
                    <span class="tutorial-tip-label">Rate Modifier</span>
                    <div style="margin-top: 0.5rem;">Changes how fast a variable's value changes over time.</div>
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">
                        <strong>How rates work:</strong> Variables have a base rate (e.g., -1/tick for depleting hunger).<br>
                        <strong>Operations:</strong><br>
                        â€¢ <strong>Multiply (Ã—)</strong>: Scale the rate. <em>Recommended. Default: 0.5-1.5</em><br>
                        &nbsp;&nbsp;Example: Ã—0.5 = half speed, Ã—1.5 = 50% faster, Ã—0 = stops change<br>
                        â€¢ <strong>Add (+/-)</strong>: Add to rate. <em>Default: Â±0.5</em><br>
                        &nbsp;&nbsp;Example: If rate is -1, adding +0.5 makes it -0.5 (slower depletion)<br>
                        â€¢ <strong>Set (=)</strong>: Override rate entirely
                    </div>
                `,
                value_modifier: `
                    <span class="tutorial-tip-label">Value Modifier</span>
                    <div style="margin-top: 0.5rem;">Instantly changes a variable's current value when the source is active.</div>
                    <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">
                        <strong>Operations:</strong><br>
                        â€¢ <strong>Add (+/-)</strong>: Add/subtract from value. <em>Default: Â±10-20</em><br>
                        &nbsp;&nbsp;Example: "Well Fed" adds +30 to Hunger variable<br>
                        â€¢ <strong>Multiply (Ã—)</strong>: Scale the value. <em>Default: 1.2 or 0.8</em><br>
                        â€¢ <strong>Set (=)</strong>: Set to exact value<br>
                        &nbsp;&nbsp;Example: "Full" sets Hunger to 100
                    </div>
                `,
                eligibility_gate: '<span class="tutorial-tip-label">Eligibility Gate</span><div style="margin-top: 0.5rem;">When source is active, target cannot be selected. Use to make traits mutually exclusive or conditional.</div><div style="margin-top: 0.5rem; font-size: 0.75rem;">Example: "Pacifist" gates "Aggressive" trait from being selected.</div>',
                requires: '<span class="tutorial-tip-label">Requires (Compound)</span><div style="margin-top: 0.5rem;">The target compound needs this source to be active. Use to define compound formation rules.</div><div style="margin-top: 0.5rem; font-size: 0.75rem;">Example: "Hangry" requires both "Starving" modifier AND "Grumpy" trait.</div>',
                replaces: '<span class="tutorial-tip-label">Replaces</span><div style="margin-top: 0.5rem;">When source becomes active, target is automatically deactivated. Use for superseding states.</div><div style="margin-top: 0.5rem; font-size: 0.75rem;">Example: "Starving" replaces "Hungry" (more severe version).</div>',
                duration_binding: '<span class="tutorial-tip-label">Duration Binding</span><div style="margin-top: 0.5rem;">Connects a modifier to a tick system for duration tracking. When the tick system advances, the modifier\'s duration decrements.</div><div style="margin-top: 0.5rem; font-size: 0.75rem;">Example: "Poison" â†’ Combat Turns: Poison lasts 3 combat turns.</div>'
            };

            helpEl.innerHTML = helpTexts[type] || '';

            // Update default values based on type
            const valueInput = document.getElementById('newRelValue');
            const opSelect = document.getElementById('newRelOperation');
            if (type === 'weight_influence') {
                opSelect.value = 'add';
                valueInput.value = '20';
                valueInput.step = '5';
            } else if (type === 'rate_modifier') {
                opSelect.value = 'multiply';
                valueInput.value = '0.8';
                valueInput.step = '0.1';
            } else if (type === 'value_modifier') {
                opSelect.value = 'add';
                valueInput.value = '10';
                valueInput.step = '5';
            }

            // Show/hide value row for types that don't need it
            const noValueTypes = ['eligibility_gate', 'requires', 'replaces', 'duration_binding'];
            valueRow.style.display = noValueTypes.includes(type) ? 'none' : 'grid';

            // Show/hide advanced settings section (only for weight_influence)
            const advancedSection = document.getElementById('relAdvancedSection');
            if (advancedSection) {
                advancedSection.style.display = type === 'weight_influence' ? 'block' : 'none';

                // Set scaling default based on source type
                if (type === 'weight_influence') {
                    const sourceId = editingRelationshipId
                        ? config.relationships.find(r => r.id === editingRelationshipId)?.sourceId
                        : selectedNodeId;
                    const sourceNode = config.nodes.find(n => n.id === sourceId);
                    const scalingEl = document.getElementById('newRelScaling');
                    if (scalingEl && !editingRelationshipId) {
                        // For new relationships, default based on source type
                        scalingEl.value = (sourceNode?.type === 'attribute' || sourceNode?.type === 'variable') ? 'perPoint' : 'flat';
                        toggleRelScalingSource();
                    }
                }
            }

            // Refresh target options based on relationship type
            populateRelTargets();

            // Update contextual labels
            updateRelLabels(type);

            // Update preview
            updateRelPreview();
        }

        function updateRelLabels(type) {
            const targetLabel = document.getElementById('relTargetLabel');
            const operationLabel = document.getElementById('relOperationLabel');
            const valueLabel = document.getElementById('relValueLabel');

            const labelConfig = {
                weight_influence: {
                    target: 'Trait to Influence',
                    operation: 'How to Change Weight',
                    value: 'Weight Change'
                },
                rate_modifier: {
                    target: 'Variable to Speed Up/Slow',
                    operation: 'How to Change Rate',
                    value: 'Rate Modifier'
                },
                value_modifier: {
                    target: 'Variable to Adjust',
                    operation: 'How to Change Value',
                    value: 'Amount'
                },
                eligibility_gate: {
                    target: 'Trait to Block',
                    operation: 'Operation',
                    value: 'Value'
                },
                requires: {
                    target: 'Compound This Enables',
                    operation: 'Operation',
                    value: 'Value'
                },
                replaces: {
                    target: 'State to Deactivate',
                    operation: 'Operation',
                    value: 'Value'
                },
                duration_binding: {
                    target: 'Tick System',
                    operation: 'Operation',
                    value: 'Value'
                }
            };

            const labels = labelConfig[type] || labelConfig.weight_influence;
            if (targetLabel) targetLabel.innerHTML = `${labels.target} <span class="help-icon" title="The node being affected">?</span>`;
            if (operationLabel) operationLabel.textContent = labels.operation;
            if (valueLabel) valueLabel.textContent = labels.value;
        }

        // Apply sidebar mode to modals (only mode now)
        function applyModalLayoutPref(modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;
            // Always use sidebar mode
            modal.classList.add('sidebar-mode');
            // Add body class to shift main view content
            document.body.classList.add('sidebar-modal-active');
        }

        function updateRelPreview() {
            const preview = document.getElementById('relPreview');
            if (!preview) return;

            const type = document.getElementById('newRelType')?.value;
            const targetId = document.getElementById('newRelTarget')?.value;
            const operation = document.getElementById('newRelOperation')?.value;
            const value = document.getElementById('newRelValue')?.value;

            // Update connection preview line on graph (add mode only)
            if (!editingRelationshipId) {
                updateConnectionPreviewLine(selectedNodeId, targetId);
            }

            const sourceNode = config.nodes.find(n => n.id === selectedNodeId);
            const targetNode = config.nodes.find(n => n.id === targetId);

            if (!sourceNode || !targetNode) {
                preview.innerHTML = '<div style="font-size: 0.85rem; color: var(--text-muted);">Select source and target nodes to see preview</div>';
                return;
            }

            const sourceName = `<strong>${sourceNode.name}</strong>`;
            const targetName = `<strong>${targetNode.name}</strong>`;
            const sourceType = sourceNode.type;

            let effectText = '';
            const numValue = parseFloat(value);
            const absValue = Math.abs(numValue);
            const isNegative = numValue < 0;
            const opSymbol = operation === 'add' ? (numValue >= 0 ? '+' : '') : operation === 'multiply' ? 'Ã—' : '=';

            // Build contextual prefix based on source type
            // Attributes/variables are values, not "active" states
            const isValueSource = sourceType === 'attribute' || sourceType === 'variable' || sourceType === 'derived';
            const isTraitLikeSource = sourceType === 'trait' || sourceType === 'item' || sourceType === 'modifier' || sourceType === 'compound';

            // For weight_influence, try to get base weight of target trait
            const targetBaseWeight = (targetNode.type === 'trait' || targetNode.type === 'item')
                ? (targetNode.config?.weight || targetNode.config?.baseWeight || 50)
                : null;

            switch (type) {
                case 'weight_influence':
                    if (isValueSource) {
                        // Check scaling mode
                        const scalingMode = document.getElementById('newRelScaling')?.value || 'perPoint';

                        if (scalingMode === 'flat') {
                            // Flat: fixed effect regardless of source value
                            if (isNegative) {
                                effectText = `When ${sourceName} exists, ${targetName} selection weight <strong>decreases</strong> by <strong>${absValue}</strong> (flat)`;
                                if (targetBaseWeight !== null) {
                                    effectText += `<br><span style="font-size: 0.8rem; color: var(--text-muted);">base ${targetBaseWeight} â†’ ${targetBaseWeight - absValue}</span>`;
                                }
                            } else {
                                effectText = `When ${sourceName} exists, ${targetName} selection weight <strong>increases</strong> by <strong>${absValue}</strong> (flat)`;
                                if (targetBaseWeight !== null) {
                                    effectText += `<br><span style="font-size: 0.8rem; color: var(--text-muted);">base ${targetBaseWeight} â†’ ${targetBaseWeight + absValue}</span>`;
                                }
                            }
                        } else {
                            // Per Point: scales with source value
                            const exampleSourceVal = 5; // Example attribute value
                            const exampleEffect = absValue * exampleSourceVal;
                            if (isNegative) {
                                effectText = `${sourceName} <strong>decreases</strong> ${targetName} selection weight by <strong>${absValue}</strong> per point`;
                                effectText += `<br><span style="font-size: 0.8rem; color: var(--text-muted);">e.g., at ${sourceNode.name} ${exampleSourceVal} â†’ -${exampleEffect} weight`;
                                if (targetBaseWeight !== null) {
                                    effectText += ` (base ${targetBaseWeight} â†’ ${targetBaseWeight - exampleEffect})`;
                                }
                                effectText += `</span>`;
                            } else {
                                effectText = `${sourceName} <strong>increases</strong> ${targetName} selection weight by <strong>${absValue}</strong> per point`;
                                effectText += `<br><span style="font-size: 0.8rem; color: var(--text-muted);">e.g., at ${sourceNode.name} ${exampleSourceVal} â†’ +${exampleEffect} weight`;
                                if (targetBaseWeight !== null) {
                                    effectText += ` (base ${targetBaseWeight} â†’ ${targetBaseWeight + exampleEffect})`;
                                }
                                effectText += `</span>`;
                            }
                        }
                    } else {
                        if (isNegative) {
                            effectText = `When ${sourceName} is active, ${targetName} selection weight <strong>decreases</strong> by <strong>${absValue}</strong>`;
                            if (targetBaseWeight !== null) {
                                effectText += `<br><span style="font-size: 0.8rem; color: var(--text-muted);">base ${targetBaseWeight} â†’ ${targetBaseWeight - absValue}</span>`;
                            }
                        } else {
                            effectText = `When ${sourceName} is active, ${targetName} selection weight <strong>increases</strong> by <strong>${absValue}</strong>`;
                            if (targetBaseWeight !== null) {
                                effectText += `<br><span style="font-size: 0.8rem; color: var(--text-muted);">base ${targetBaseWeight} â†’ ${targetBaseWeight + absValue}</span>`;
                            }
                        }
                    }
                    break;
                case 'rate_modifier':
                    if (operation === 'multiply') {
                        const pct = Math.round((numValue - 1) * 100);
                        if (isValueSource) {
                            effectText = `${sourceName} value affects ${targetName} rate (multiplied by <strong>${value}</strong>)`;
                        } else {
                            effectText = `When ${sourceName} is active, ${targetName} changes <strong>${pct >= 0 ? pct + '% faster' : Math.abs(pct) + '% slower'}</strong>`;
                        }
                    } else {
                        if (isValueSource) {
                            if (isNegative) {
                                effectText = `${sourceName} value <strong>decreases</strong> ${targetName} rate by <strong>${absValue}</strong> per point`;
                            } else {
                                effectText = `${sourceName} value <strong>increases</strong> ${targetName} rate by <strong>${absValue}</strong> per point`;
                            }
                        } else {
                            if (isNegative) {
                                effectText = `When ${sourceName} is active, ${targetName} rate <strong>decreases</strong> by <strong>${absValue}</strong> per tick`;
                            } else {
                                effectText = `When ${sourceName} is active, ${targetName} rate <strong>increases</strong> by <strong>${absValue}</strong> per tick`;
                            }
                        }
                    }
                    break;
                case 'value_modifier':
                    if (isValueSource) {
                        if (isNegative) {
                            effectText = `${sourceName} <strong>decreases</strong> ${targetName} by <strong>${absValue}</strong> per point`;
                        } else {
                            effectText = `${sourceName} <strong>increases</strong> ${targetName} by <strong>${absValue}</strong> per point`;
                        }
                    } else {
                        if (isNegative) {
                            effectText = `When ${sourceName} is active, ${targetName} value <strong>decreases</strong> by <strong>${absValue}</strong>`;
                        } else {
                            effectText = `When ${sourceName} is active, ${targetName} value <strong>increases</strong> by <strong>${absValue}</strong>`;
                        }
                    }
                    break;
                case 'eligibility_gate':
                    if (isValueSource) {
                        effectText = `When ${sourceName} exceeds threshold, ${targetName} <strong>cannot be selected</strong>`;
                    } else {
                        effectText = `When ${sourceName} is active, ${targetName} <strong>cannot be selected</strong>`;
                    }
                    break;
                case 'requires':
                    effectText = `${targetName} (compound) requires ${sourceName} to be active`;
                    break;
                case 'replaces':
                    effectText = `When ${sourceName} activates, ${targetName} is <strong>deactivated</strong>`;
                    break;
                case 'duration_binding':
                    effectText = `${sourceName} duration is tracked by ${targetName} tick system`;
                    break;
                default:
                    effectText = `${sourceName} affects ${targetName}`;
            }

            preview.innerHTML = `<div style="font-size: 0.9rem;">${effectText}</div>`;
        }

        function populateRelTargets() {
            const targetSelect = document.getElementById('newRelTarget');
            const relType = document.getElementById('newRelType')?.value || 'weight_influence';
            const effectiveSourceId = window._relModalSourceId || selectedNodeId;
            const sourceNode = config.nodes.find(n => n.id === effectiveSourceId);

            // Get valid target types for this relationship type
            const validTargetTypes = getValidTargetTypesForRel(relType);

            // Special case for duration_binding (already handled by getValidTargetTypesForRel)
            if (relType === 'duration_binding') {
                const tickSystems = config.nodes.filter(n => n.type === 'ticksystem');
                if (tickSystems.length === 0) {
                    targetSelect.innerHTML = '<option value="">No tick systems defined</option>';
                    return;
                }
                targetSelect.innerHTML = tickSystems.map(ts =>
                    `<option value="${ts.id}">${ts.name} (${ts.config?.tickUnit?.label || 'tick'})</option>`
                ).join('');
                return;
            }

            // Group labels for display
            const groupLabels = {
                attribute: 'Attributes',
                variable: 'Variables',
                layer: 'Layers',
                item: 'Traits',
                trait: 'Traits',
                modifier: 'Modifiers',
                compound: 'Compounds',
                action: 'Actions',
                derived: 'Derived',
                ticksystem: 'Tick Systems'
            };

            // For weight_influence/eligibility_gate from traits, check for same-layer single-select
            // If source trait is in a layer with max=1, targeting same-layer traits is pointless
            let excludeSameLayerTraits = false;
            let sourceLayerId = null;
            if (sourceNode && (sourceNode.type === 'trait' || sourceNode.type === 'item')) {
                sourceLayerId = sourceNode.config?.layerId;
                if (sourceLayerId && (relType === 'weight_influence' || relType === 'eligibility_gate')) {
                    const layer = config.nodes.find(n => n.id === sourceLayerId);
                    const maxRolls = layer?.config?.selection?.maxRolls ?? layer?.config?.selection?.initialRolls ?? 1;
                    if (maxRolls === 1) {
                        excludeSameLayerTraits = true;
                    }
                }
            }

            // Build options HTML - only include valid target types
            let optionsHtml = '<option value="">-- Select target --</option>';
            const processedGroups = new Set();

            for (const type of validTargetTypes) {
                // Handle trait/item as same group
                const groupKey = (type === 'item') ? 'trait' : type;
                if (processedGroups.has(groupKey)) continue;
                processedGroups.add(groupKey);

                // Get nodes of this type (including both 'item' and 'trait' for trait group)
                let nodes;
                if (groupKey === 'trait') {
                    nodes = config.nodes.filter(n => {
                        if ((n.type !== 'trait' && n.type !== 'item') || n.id === selectedNodeId) return false;
                        // Exclude same-layer traits for single-select layers
                        if (excludeSameLayerTraits && n.config?.layerId === sourceLayerId) return false;
                        return true;
                    });
                    // Sort traits by layer for clarity
                    nodes.sort((a, b) => {
                        const layerA = config.nodes.find(n => n.id === a.config?.layerId)?.name || '';
                        const layerB = config.nodes.find(n => n.id === b.config?.layerId)?.name || '';
                        if (layerA !== layerB) return layerA.localeCompare(layerB);
                        return a.name.localeCompare(b.name);
                    });
                    // Group traits by layer with sub-optgroups
                    const traitsByLayer = {};
                    for (const n of nodes) {
                        const layerName = config.nodes.find(l => l.id === n.config?.layerId)?.name || 'Unassigned';
                        if (!traitsByLayer[layerName]) traitsByLayer[layerName] = [];
                        traitsByLayer[layerName].push(n);
                    }
                    for (const [layerName, layerTraits] of Object.entries(traitsByLayer)) {
                        optionsHtml += `<optgroup label="Traits â€” ${layerName}">`;
                        for (const node of layerTraits) {
                            optionsHtml += `<option value="${node.id}">${node.name}</option>`;
                        }
                        optionsHtml += '</optgroup>';
                    }
                } else {
                    nodes = config.nodes.filter(n =>
                        n.type === type && n.id !== selectedNodeId
                    );

                    if (nodes.length > 0) {
                        const label = groupLabels[groupKey] || groupKey;
                        optionsHtml += `<optgroup label="${label}">`;
                        for (const node of nodes) {
                            optionsHtml += `<option value="${node.id}">${node.name}</option>`;
                        }
                        optionsHtml += '</optgroup>';
                    }
                }
            }

            if (optionsHtml === '<option value="">-- Select target --</option>') {
                optionsHtml = '<option value="">No valid targets for this relationship type</option>';
            }

            targetSelect.innerHTML = optionsHtml;
        }

        function addRelationship() {
            if (typeof TIER_LIMITS !== 'undefined') {
                const check = checkRelationshipLimit();
                if (!check.allowed) {
                    showToast(check.reason, 'warning', TIER_TOAST_DURATION);
                    return;
                }
            }
            // Get source from selected node (add mode), generic mode, or existing relationship (edit mode)
            let sourceId;
            if (editingRelationshipId) {
                const existingRel = config.relationships.find(r => r.id === editingRelationshipId);
                sourceId = existingRel?.sourceId;
            } else if (window._relModalSourceId) {
                sourceId = window._relModalSourceId;
            } else {
                sourceId = selectedNodeId;
            }

            const targetId = document.getElementById('newRelTarget').value;
            const type = document.getElementById('newRelType').value;
            const operation = document.getElementById('newRelOperation').value;
            const value = parseFloat(document.getElementById('newRelValue').value) || 0;

            if (!sourceId || !targetId) {
                alert('Please select a target node');
                return;
            }

            // Special handling for duration_binding
            if (type === 'duration_binding') {
                const sourceNode = config.nodes.find(n => n.id === sourceId);
                if (sourceNode?.type !== 'modifier') {
                    alert('Duration bindings can only be created from modifiers');
                    return;
                }

                // Add to modifier's tickBindings
                if (!sourceNode.config.tickBindings) sourceNode.config.tickBindings = [];

                // Check if already bound (skip check in edit mode for same binding)
                const existingBinding = sourceNode.config.tickBindings.find(b => b.tickSystemId === targetId);
                if (existingBinding && !editingRelationshipId) {
                    alert('This modifier is already bound to this tick system');
                    return;
                }

                if (!existingBinding) {
                    sourceNode.config.tickBindings.push({
                        tickSystemId: targetId,
                        duration: 3,
                        fallbackBehavior: 'pause'
                    });
                }
            }

            // Build relationship config with advanced settings
            let relConfig;
            if (type === 'duration_binding') {
                relConfig = {
                    duration: 3,
                    fallbackBehavior: 'pause'
                };
            } else {
                relConfig = {
                    operation,
                    value
                };

                // Add advanced settings for weight_influence
                if (type === 'weight_influence') {
                    const invert = document.getElementById('newRelInvert')?.checked || false;
                    const scaling = document.getElementById('newRelScaling')?.value || 'perPoint';

                    if (invert) {
                        relConfig.invert = true;
                    }
                    // Always save scaling value for clarity
                    relConfig.scaling = scaling;
                    if (scaling === 'perPoint') {
                        const perPointSource = document.getElementById('newRelScalingSource')?.value;
                        if (perPointSource) {
                            relConfig.perPointSource = perPointSource;
                        }
                    }
                }
            }

            // Edit mode: update existing relationship
            if (editingRelationshipId) {
                const relIndex = config.relationships.findIndex(r => r.id === editingRelationshipId);
                if (relIndex !== -1) {
                    config.relationships[relIndex] = {
                        ...config.relationships[relIndex],
                        targetId,
                        type,
                        config: relConfig
                    };
                }
            } else {
                // Add mode: create new relationship
                const relationship = {
                    id: `rel_${sourceId}_${targetId}_${Date.now()}`,
                    sourceId,
                    targetId,
                    type,
                    config: relConfig
                };
                config.relationships.push(relationship);
            }

            engine.loadConfig(config);
            saveToStorage();
            closeModal('addRelationshipModal');
            editingRelationshipId = null; // Reset edit mode
            render();

            // Check if wizard is active and update progress
            if (typeof checkWizardProgress === 'function') {
                checkWizardProgress();
            }
        }

        // ========================================
        // WELCOME / EMPTY STATE WITH TUTORIAL
        // ========================================
        function renderWelcomeState() {
            return `
                <div class="welcome-banner">
                    <div class="welcome-title">ðŸ‘‹ Welcome to Spawn Engine Editor</div>
                    <div class="welcome-text">
                        Create configurable entity spawners for NPCs, monsters, citizens, or any game characters with layered traits and behaviors.
                    </div>
                    <div class="welcome-actions">
                        <button class="btn btn-primary" onclick="startWizard()">Start Config Wizard</button>
                        <button class="btn btn-secondary" onclick="showTutorial()">Learn the Concepts</button>
                        <button class="btn btn-secondary" onclick="handleJumpIn()">Jump In</button>
                    </div>
                </div>
                <div class="empty-state" style="height: auto; padding: 2rem;">
                    <div class="empty-state-text">No nodes yet</div>
                    <div class="empty-state-hint">Use the <strong>Wizard</strong> to build a config step-by-step, or <strong>Add Node</strong> to start from scratch</div>
                </div>
            `;
        }

        function renderJumpInState() {
            return `
                <div class="jump-in-message">
                    <div class="jump-in-icon">ðŸŽ¯</div>
                    <div class="jump-in-text">Add your first node using the menu on the left side</div>
                    <div class="jump-in-hint">Click the <strong>+ Add Node</strong> button in the sidebar, or use the type folders to add specific node types</div>
                </div>
            `;
        }

        function handleJumpIn() {
            // Set state to show jump-in message
            showJumpInMessage = true;
            // Re-render to show the jump-in message
            renderMainView();
        }

        // checkFirstTimeUser is now provided by js/tutorial.js
        // Called from render() with config check
    </script>
</body>
</html>
